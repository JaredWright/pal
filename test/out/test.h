// 
// Shoulder
// Copyright (C) 2018 Assured Information Security, Inc.
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 

#include <stdint>
#include "regs.h"

#ifndef SHOULDER_AARCH64_H
#define SHOULDER_AARCH64_H

namespace aarch64
{

// ACTLR (Auxiliary Control Register)
// Provides IMPLEMENTATION DEFINED configuration and control options for execution at EL1 and EL0.
namespace actlr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(actlr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(actlr, val) }
}

// ACTLR2 (Auxiliary Control Register 2)
// Provides additional space to the ACTLR register to hold IMPLEMENTATION DEFINED trap functionality for execution at EL1 and EL0.
namespace actlr2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(actlr2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(actlr2, val) }
}

// ADFSR (Auxiliary Data Fault Status Register)
// Provides additional IMPLEMENTATION DEFINED fault status information for Data Abort exceptions taken to EL1 modes, and EL3 modes when EL3 is implemented and is using AArch32.
namespace adfsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(adfsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(adfsr, val) }
}

// AIDR (Auxiliary ID Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace aidr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(aidr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(aidr, val) }
}

// AIFSR (Auxiliary Instruction Fault Status Register)
// Provides additional IMPLEMENTATION DEFINED fault status information for Prefetch Abort exceptions taken to EL1 modes, and EL3 modes when EL3 is implemented and is using AArch32.
namespace aifsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(aifsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(aifsr, val) }
}

// AMAIR0 (Auxiliary Memory Attribute Indirection Register 0)
// When using the Long-descriptor format translation tables for stage 1 translations, provides IMPLEMENTATION DEFINED memory attributes for the memory regions specified by MAIR0.
namespace amair0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(amair0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(amair0, val) }
}

// AMAIR1 (Auxiliary Memory Attribute Indirection Register 1)
// When using the Long-descriptor format translation tables for stage 1 translations, provides IMPLEMENTATION DEFINED memory attributes for the memory regions specified by MAIR1.
namespace amair1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(amair1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(amair1, val) }
}

// APSR (Application Program Status Register)
// Hold program status and control information.
namespace apsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(apsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(apsr, val) }

	namespace n
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(apsr, 31) }
		inline uint32_t is_enabled(uint32_t apsr_val) noexcept { IS_BIT_ENABLED_FUNC(apsr_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(apsr, 31) }
		inline uint32_t is_disabled(uint32_t apsr_val) noexcept { IS_BIT_DISABLED_FUNC(apsr_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(apsr, 0x80000000) }
		inline uint32_t enable(uint32_t apsr_val) noexcept { SET_BITS_BY_MASK_FUNC(apsr_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(apsr, 0x80000000) }
		inline uint32_t disable(uint32_t apsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(apsr_val, 0x80000000) }
	}

	namespace z
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(apsr, 30) }
		inline uint32_t is_enabled(uint32_t apsr_val) noexcept { IS_BIT_ENABLED_FUNC(apsr_val, 30) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(apsr, 30) }
		inline uint32_t is_disabled(uint32_t apsr_val) noexcept { IS_BIT_DISABLED_FUNC(apsr_val, 30) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(apsr, 0x40000000) }
		inline uint32_t enable(uint32_t apsr_val) noexcept { SET_BITS_BY_MASK_FUNC(apsr_val, 0x40000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(apsr, 0x40000000) }
		inline uint32_t disable(uint32_t apsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(apsr_val, 0x40000000) }
	}

	namespace c
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(apsr, 29) }
		inline uint32_t is_enabled(uint32_t apsr_val) noexcept { IS_BIT_ENABLED_FUNC(apsr_val, 29) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(apsr, 29) }
		inline uint32_t is_disabled(uint32_t apsr_val) noexcept { IS_BIT_DISABLED_FUNC(apsr_val, 29) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(apsr, 0x20000000) }
		inline uint32_t enable(uint32_t apsr_val) noexcept { SET_BITS_BY_MASK_FUNC(apsr_val, 0x20000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(apsr, 0x20000000) }
		inline uint32_t disable(uint32_t apsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(apsr_val, 0x20000000) }
	}

	namespace v
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(apsr, 28) }
		inline uint32_t is_enabled(uint32_t apsr_val) noexcept { IS_BIT_ENABLED_FUNC(apsr_val, 28) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(apsr, 28) }
		inline uint32_t is_disabled(uint32_t apsr_val) noexcept { IS_BIT_DISABLED_FUNC(apsr_val, 28) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(apsr, 0x10000000) }
		inline uint32_t enable(uint32_t apsr_val) noexcept { SET_BITS_BY_MASK_FUNC(apsr_val, 0x10000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(apsr, 0x10000000) }
		inline uint32_t disable(uint32_t apsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(apsr_val, 0x10000000) }
	}

	namespace q
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(apsr, 27) }
		inline uint32_t is_enabled(uint32_t apsr_val) noexcept { IS_BIT_ENABLED_FUNC(apsr_val, 27) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(apsr, 27) }
		inline uint32_t is_disabled(uint32_t apsr_val) noexcept { IS_BIT_DISABLED_FUNC(apsr_val, 27) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(apsr, 0x8000000) }
		inline uint32_t enable(uint32_t apsr_val) noexcept { SET_BITS_BY_MASK_FUNC(apsr_val, 0x8000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(apsr, 0x8000000) }
		inline uint32_t disable(uint32_t apsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(apsr_val, 0x8000000) }
	}

	namespace ge
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(apsr, 0xf0000, 16) }
		inline uint32_t get(uint32_t apsr_val) noexcept { GET_BITFIELD_FUNC(apsr_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(apsr, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t apsr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(apsr, value, 0xf0000, 16) }
	}
}

// ATS12NSOPR (Address Translate Stages 1 and 2 Non-secure Only PL1 Read)
// Performs stage 1 and 2 address translations as defined for PL1 and the Non-secure state, with permissions as if reading from the given virtual address.
namespace ats12nsopr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ats12nsopr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ats12nsopr, val) }

	namespace input_address_for_translation
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ats12nsopr, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ats12nsopr_val) noexcept { GET_BITFIELD_FUNC(ats12nsopr_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ats12nsopr, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ats12nsopr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ats12nsopr, value, 0xffffffff, 0) }
	}
}

// ATS12NSOPW (Address Translate Stages 1 and 2 Non-secure Only PL1 Write)
// Performs stage 1 and 2 address translations as defined for PL1 and the Non-secure state, with permissions as if writing to the given virtual address.
namespace ats12nsopw
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ats12nsopw) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ats12nsopw, val) }

	namespace input_address_for_translation
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ats12nsopw, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ats12nsopw_val) noexcept { GET_BITFIELD_FUNC(ats12nsopw_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ats12nsopw, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ats12nsopw, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ats12nsopw, value, 0xffffffff, 0) }
	}
}

// ATS12NSOUR (Address Translate Stages 1 and 2 Non-secure Only Unprivileged Read)
// Performs stage 1 and 2 address translations as defined for PL0 and the Non-secure state, with permissions as if reading from the given virtual address.
namespace ats12nsour
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ats12nsour) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ats12nsour, val) }

	namespace input_address_for_translation
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ats12nsour, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ats12nsour_val) noexcept { GET_BITFIELD_FUNC(ats12nsour_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ats12nsour, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ats12nsour, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ats12nsour, value, 0xffffffff, 0) }
	}
}

// ATS12NSOUW (Address Translate Stages 1 and 2 Non-secure Only Unprivileged Write)
// Performs stage 1 and 2 address translations as defined for PL0 and the Non-secure state, with permissions as if writing to the given virtual address.
namespace ats12nsouw
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ats12nsouw) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ats12nsouw, val) }

	namespace input_address_for_translation
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ats12nsouw, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ats12nsouw_val) noexcept { GET_BITFIELD_FUNC(ats12nsouw_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ats12nsouw, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ats12nsouw, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ats12nsouw, value, 0xffffffff, 0) }
	}
}

// ATS1CPR (Address Translate Stage 1 Current state PL1 Read)
// Performs stage 1 address translation as defined for PL1 and the current Security state, with permissions as if reading from the given virtual address.
namespace ats1cpr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ats1cpr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ats1cpr, val) }

	namespace input_address_for_translation
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ats1cpr, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ats1cpr_val) noexcept { GET_BITFIELD_FUNC(ats1cpr_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ats1cpr, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ats1cpr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ats1cpr, value, 0xffffffff, 0) }
	}
}

// ATS1CPRP (Address Translate Stage 1 Current state PL1 Read PAN)
// When 
namespace ats1cprp
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ats1cprp) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ats1cprp, val) }

	namespace input_address_for_translation
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ats1cprp, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ats1cprp_val) noexcept { GET_BITFIELD_FUNC(ats1cprp_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ats1cprp, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ats1cprp, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ats1cprp, value, 0xffffffff, 0) }
	}
}

// ATS1CPW (Address Translate Stage 1 Current state PL1 Write)
// Performs stage 1 address translation as defined for PL1 and the current Security state, with permissions as if writing to the given virtual address.
namespace ats1cpw
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ats1cpw) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ats1cpw, val) }

	namespace input_address_for_translation
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ats1cpw, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ats1cpw_val) noexcept { GET_BITFIELD_FUNC(ats1cpw_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ats1cpw, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ats1cpw, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ats1cpw, value, 0xffffffff, 0) }
	}
}

// ATS1CPWP (Address Translate Stage 1 Current state PL1 Write PAN)
// When 
namespace ats1cpwp
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ats1cpwp) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ats1cpwp, val) }

	namespace input_address_for_translation
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ats1cpwp, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ats1cpwp_val) noexcept { GET_BITFIELD_FUNC(ats1cpwp_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ats1cpwp, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ats1cpwp, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ats1cpwp, value, 0xffffffff, 0) }
	}
}

// ATS1CUR (Address Translate Stage 1 Current state Unprivileged Read)
// Performs stage 1 address translation as defined for PL0 and the current Security state, with permissions as if reading from the given virtual address.
namespace ats1cur
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ats1cur) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ats1cur, val) }

	namespace input_address_for_translation
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ats1cur, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ats1cur_val) noexcept { GET_BITFIELD_FUNC(ats1cur_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ats1cur, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ats1cur, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ats1cur, value, 0xffffffff, 0) }
	}
}

// ATS1CUW (Address Translate Stage 1 Current state Unprivileged Write)
// Performs stage 1 address translation as defined for PL0 and the current Security state, with permissions as if writing to the given virtual address.
namespace ats1cuw
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ats1cuw) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ats1cuw, val) }

	namespace input_address_for_translation
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ats1cuw, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ats1cuw_val) noexcept { GET_BITFIELD_FUNC(ats1cuw_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ats1cuw, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ats1cuw, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ats1cuw, value, 0xffffffff, 0) }
	}
}

// ATS1HR (Address Translate Stage 1 Hyp mode Read)
// Performs stage 1 address translation as defined for PL2 and the Non-secure state, with permissions as if reading from the given virtual address.
namespace ats1hr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ats1hr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ats1hr, val) }

	namespace input_address_for_translation
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ats1hr, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ats1hr_val) noexcept { GET_BITFIELD_FUNC(ats1hr_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ats1hr, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ats1hr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ats1hr, value, 0xffffffff, 0) }
	}
}

// ATS1HW (Address Translate Stage 1 Hyp mode Write)
// Performs stage 1 address translation as defined for PL2 and the Non-secure state, with permissions as if writing to the given virtual address.
namespace ats1hw
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ats1hw) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ats1hw, val) }

	namespace input_address_for_translation
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ats1hw, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ats1hw_val) noexcept { GET_BITFIELD_FUNC(ats1hw_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ats1hw, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ats1hw, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ats1hw, value, 0xffffffff, 0) }
	}
}

// BPIALL (Branch Predictor Invalidate All)
// Invalidate all entries from branch predictors.
namespace bpiall
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(bpiall) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(bpiall, val) }
}

// BPIALLIS (Branch Predictor Invalidate All, Inner Shareable)
// Invalidate all entries from branch predictors Inner Shareable.
namespace bpiallis
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(bpiallis) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(bpiallis, val) }
}

// BPIMVA (Branch Predictor Invalidate by VA)
// Invalidate virtual address from branch predictors.
namespace bpimva
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(bpimva) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(bpimva, val) }

	namespace virtual_address_to_use
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(bpimva, 0xffffffff, 0) }
		inline uint32_t get(uint32_t bpimva_val) noexcept { GET_BITFIELD_FUNC(bpimva_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(bpimva, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t bpimva, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(bpimva, value, 0xffffffff, 0) }
	}
}

// CCSIDR (Current Cache Size ID Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace ccsidr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ccsidr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ccsidr, val) }

	// Fieldset valid when: ID_MMFR4.CCIDX==0000
	namespace fieldset_1
	{
		namespace unknown
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ccsidr, 0xf0000000, 28) }
			inline uint32_t get(uint32_t ccsidr_val) noexcept { GET_BITFIELD_FUNC(ccsidr_val, 0xf0000000, 28) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ccsidr, value, 0xf0000000, 28) }
			inline uint32_t set(uint32_t ccsidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ccsidr, value, 0xf0000000, 28) }
		}

		namespace numsets
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ccsidr, 0xfffe000, 13) }
			inline uint32_t get(uint32_t ccsidr_val) noexcept { GET_BITFIELD_FUNC(ccsidr_val, 0xfffe000, 13) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ccsidr, value, 0xfffe000, 13) }
			inline uint32_t set(uint32_t ccsidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ccsidr, value, 0xfffe000, 13) }
		}

		namespace associativity
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ccsidr, 0x1ff8, 3) }
			inline uint32_t get(uint32_t ccsidr_val) noexcept { GET_BITFIELD_FUNC(ccsidr_val, 0x1ff8, 3) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ccsidr, value, 0x1ff8, 3) }
			inline uint32_t set(uint32_t ccsidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ccsidr, value, 0x1ff8, 3) }
		}

		namespace linesize
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ccsidr, 0x7, 0) }
			inline uint32_t get(uint32_t ccsidr_val) noexcept { GET_BITFIELD_FUNC(ccsidr_val, 0x7, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ccsidr, value, 0x7, 0) }
			inline uint32_t set(uint32_t ccsidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ccsidr, value, 0x7, 0) }
		}
	}

	// Fieldset valid when: ID_MMFR4.CCIDX==0001
	namespace fieldset_2
	{
		namespace associativity
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ccsidr, 0xfffff8, 3) }
			inline uint32_t get(uint32_t ccsidr_val) noexcept { GET_BITFIELD_FUNC(ccsidr_val, 0xfffff8, 3) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ccsidr, value, 0xfffff8, 3) }
			inline uint32_t set(uint32_t ccsidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ccsidr, value, 0xfffff8, 3) }
		}

		namespace linesize
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ccsidr, 0x7, 0) }
			inline uint32_t get(uint32_t ccsidr_val) noexcept { GET_BITFIELD_FUNC(ccsidr_val, 0x7, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ccsidr, value, 0x7, 0) }
			inline uint32_t set(uint32_t ccsidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ccsidr, value, 0x7, 0) }
		}
	}
}

// CCSIDR2 (Current Cache Size ID Register 2)
// See the ARMv8 architecture reference manual for a description of this register
namespace ccsidr2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ccsidr2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ccsidr2, val) }

	namespace numsets
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ccsidr2, 0xffffff, 0) }
		inline uint32_t get(uint32_t ccsidr2_val) noexcept { GET_BITFIELD_FUNC(ccsidr2_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ccsidr2, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t ccsidr2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ccsidr2, value, 0xffffff, 0) }
	}
}

// CLIDR (Cache Level ID Register)
// Identifies the type of cache, or caches, that are implemented at each level and can be managed using the architected cache maintenance instructions that operate by set/way, up to a maximum of seven levels. Also identifies the Level of Coherence (LoC) and Level of Unification (LoU) for the cache hierarchy.
namespace clidr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(clidr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(clidr, val) }

	namespace icb
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(clidr, 0xc0000000, 30) }
		inline uint32_t get(uint32_t clidr_val) noexcept { GET_BITFIELD_FUNC(clidr_val, 0xc0000000, 30) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(clidr, value, 0xc0000000, 30) }
		inline uint32_t set(uint32_t clidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(clidr, value, 0xc0000000, 30) }
	}

	namespace louu
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(clidr, 0x38000000, 27) }
		inline uint32_t get(uint32_t clidr_val) noexcept { GET_BITFIELD_FUNC(clidr_val, 0x38000000, 27) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(clidr, value, 0x38000000, 27) }
		inline uint32_t set(uint32_t clidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(clidr, value, 0x38000000, 27) }
	}

	namespace loc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(clidr, 0x7000000, 24) }
		inline uint32_t get(uint32_t clidr_val) noexcept { GET_BITFIELD_FUNC(clidr_val, 0x7000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(clidr, value, 0x7000000, 24) }
		inline uint32_t set(uint32_t clidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(clidr, value, 0x7000000, 24) }
	}

	namespace louis
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(clidr, 0xe00000, 21) }
		inline uint32_t get(uint32_t clidr_val) noexcept { GET_BITFIELD_FUNC(clidr_val, 0xe00000, 21) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(clidr, value, 0xe00000, 21) }
		inline uint32_t set(uint32_t clidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(clidr, value, 0xe00000, 21) }
	}

	namespace ctype_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(clidr, 0x1fffff, 0) }
		inline uint32_t get(uint32_t clidr_val) noexcept { GET_BITFIELD_FUNC(clidr_val, 0x1fffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(clidr, value, 0x1fffff, 0) }
		inline uint32_t set(uint32_t clidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(clidr, value, 0x1fffff, 0) }
	}
}

// CNTFRQ (Counter-timer Frequency register)
// This register is provided so that software can discover the frequency of the system counter. It must be programmed with this value as part of system initialization. The value of the register is not interpreted by hardware.
namespace cntfrq
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntfrq) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntfrq, val) }

	namespace clock_frequency
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntfrq, 0xffffffff, 0) }
		inline uint32_t get(uint32_t cntfrq_val) noexcept { GET_BITFIELD_FUNC(cntfrq_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntfrq, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t cntfrq, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntfrq, value, 0xffffffff, 0) }
	}
}

// CNTHCTL (Counter-timer Hyp Control register)
// Controls the generation of an event stream from the physical counter, and access from Non-secure EL1 modes to the physical counter and the Non-secure EL1 physical timer.
namespace cnthctl
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cnthctl) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cnthctl, val) }

	namespace evnti
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cnthctl, 0xf0, 4) }
		inline uint32_t get(uint32_t cnthctl_val) noexcept { GET_BITFIELD_FUNC(cnthctl_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cnthctl, value, 0xf0, 4) }
		inline uint32_t set(uint32_t cnthctl, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cnthctl, value, 0xf0, 4) }
	}

	namespace evntdir
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthctl, 3) }
		inline uint32_t is_enabled(uint32_t cnthctl_val) noexcept { IS_BIT_ENABLED_FUNC(cnthctl_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthctl, 3) }
		inline uint32_t is_disabled(uint32_t cnthctl_val) noexcept { IS_BIT_DISABLED_FUNC(cnthctl_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthctl, 0x8) }
		inline uint32_t enable(uint32_t cnthctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthctl_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthctl, 0x8) }
		inline uint32_t disable(uint32_t cnthctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthctl_val, 0x8) }
	}

	namespace evnten
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthctl, 2) }
		inline uint32_t is_enabled(uint32_t cnthctl_val) noexcept { IS_BIT_ENABLED_FUNC(cnthctl_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthctl, 2) }
		inline uint32_t is_disabled(uint32_t cnthctl_val) noexcept { IS_BIT_DISABLED_FUNC(cnthctl_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthctl, 0x4) }
		inline uint32_t enable(uint32_t cnthctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthctl_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthctl, 0x4) }
		inline uint32_t disable(uint32_t cnthctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthctl_val, 0x4) }
	}

	namespace pl1pcen
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthctl, 1) }
		inline uint32_t is_enabled(uint32_t cnthctl_val) noexcept { IS_BIT_ENABLED_FUNC(cnthctl_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthctl, 1) }
		inline uint32_t is_disabled(uint32_t cnthctl_val) noexcept { IS_BIT_DISABLED_FUNC(cnthctl_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthctl, 0x2) }
		inline uint32_t enable(uint32_t cnthctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthctl_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthctl, 0x2) }
		inline uint32_t disable(uint32_t cnthctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthctl_val, 0x2) }
	}

	namespace pl1pcten
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthctl, 0) }
		inline uint32_t is_enabled(uint32_t cnthctl_val) noexcept { IS_BIT_ENABLED_FUNC(cnthctl_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthctl, 0) }
		inline uint32_t is_disabled(uint32_t cnthctl_val) noexcept { IS_BIT_DISABLED_FUNC(cnthctl_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthctl, 0x1) }
		inline uint32_t enable(uint32_t cnthctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthctl_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthctl, 0x1) }
		inline uint32_t disable(uint32_t cnthctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthctl_val, 0x1) }
	}
}

// CNTHP_CTL (Counter-timer Hyp Physical Timer Control register)
// Control register for the Hyp mode physical timer.
namespace cnthp_ctl
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cnthp_ctl) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cnthp_ctl, val) }

	namespace istatus
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthp_ctl, 2) }
		inline uint32_t is_enabled(uint32_t cnthp_ctl_val) noexcept { IS_BIT_ENABLED_FUNC(cnthp_ctl_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthp_ctl, 2) }
		inline uint32_t is_disabled(uint32_t cnthp_ctl_val) noexcept { IS_BIT_DISABLED_FUNC(cnthp_ctl_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthp_ctl, 0x4) }
		inline uint32_t enable(uint32_t cnthp_ctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthp_ctl_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthp_ctl, 0x4) }
		inline uint32_t disable(uint32_t cnthp_ctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthp_ctl_val, 0x4) }
	}

	namespace imask
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthp_ctl, 1) }
		inline uint32_t is_enabled(uint32_t cnthp_ctl_val) noexcept { IS_BIT_ENABLED_FUNC(cnthp_ctl_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthp_ctl, 1) }
		inline uint32_t is_disabled(uint32_t cnthp_ctl_val) noexcept { IS_BIT_DISABLED_FUNC(cnthp_ctl_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthp_ctl, 0x2) }
		inline uint32_t enable(uint32_t cnthp_ctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthp_ctl_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthp_ctl, 0x2) }
		inline uint32_t disable(uint32_t cnthp_ctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthp_ctl_val, 0x2) }
	}

	namespace enable
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthp_ctl, 0) }
		inline uint32_t is_enabled(uint32_t cnthp_ctl_val) noexcept { IS_BIT_ENABLED_FUNC(cnthp_ctl_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthp_ctl, 0) }
		inline uint32_t is_disabled(uint32_t cnthp_ctl_val) noexcept { IS_BIT_DISABLED_FUNC(cnthp_ctl_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthp_ctl, 0x1) }
		inline uint32_t enable(uint32_t cnthp_ctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthp_ctl_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthp_ctl, 0x1) }
		inline uint32_t disable(uint32_t cnthp_ctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthp_ctl_val, 0x1) }
	}
}

// CNTHP_CVAL (Counter-timer Hyp Physical CompareValue register)
// Holds the compare value for the Hyp mode physical timer.
namespace cnthp_cval
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(cnthp_cval) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cnthp_cval, val) }

	namespace comparevalue
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(cnthp_cval, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t cnthp_cval_val) noexcept { GET_BITFIELD_FUNC(cnthp_cval_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cnthp_cval, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t cnthp_cval, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cnthp_cval, value, 0xffffffffffffffff, 0) }
	}
}

// CNTHP_TVAL (Counter-timer Hyp Physical Timer TimerValue register)
// Holds the timer value for the Hyp mode physical timer.
namespace cnthp_tval
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cnthp_tval) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cnthp_tval, val) }

	namespace timervalue
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cnthp_tval, 0xffffffff, 0) }
		inline uint32_t get(uint32_t cnthp_tval_val) noexcept { GET_BITFIELD_FUNC(cnthp_tval_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cnthp_tval, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t cnthp_tval, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cnthp_tval, value, 0xffffffff, 0) }
	}
}

// CNTHV_CTL (Counter-timer Virtual Timer Control register (EL2))
// See the ARMv8 architecture reference manual for a description of this register
namespace cnthv_ctl
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cnthv_ctl) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cnthv_ctl, val) }

	namespace istatus
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthv_ctl, 2) }
		inline uint32_t is_enabled(uint32_t cnthv_ctl_val) noexcept { IS_BIT_ENABLED_FUNC(cnthv_ctl_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthv_ctl, 2) }
		inline uint32_t is_disabled(uint32_t cnthv_ctl_val) noexcept { IS_BIT_DISABLED_FUNC(cnthv_ctl_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthv_ctl, 0x4) }
		inline uint32_t enable(uint32_t cnthv_ctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthv_ctl_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthv_ctl, 0x4) }
		inline uint32_t disable(uint32_t cnthv_ctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthv_ctl_val, 0x4) }
	}

	namespace imask
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthv_ctl, 1) }
		inline uint32_t is_enabled(uint32_t cnthv_ctl_val) noexcept { IS_BIT_ENABLED_FUNC(cnthv_ctl_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthv_ctl, 1) }
		inline uint32_t is_disabled(uint32_t cnthv_ctl_val) noexcept { IS_BIT_DISABLED_FUNC(cnthv_ctl_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthv_ctl, 0x2) }
		inline uint32_t enable(uint32_t cnthv_ctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthv_ctl_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthv_ctl, 0x2) }
		inline uint32_t disable(uint32_t cnthv_ctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthv_ctl_val, 0x2) }
	}

	namespace enable
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthv_ctl, 0) }
		inline uint32_t is_enabled(uint32_t cnthv_ctl_val) noexcept { IS_BIT_ENABLED_FUNC(cnthv_ctl_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthv_ctl, 0) }
		inline uint32_t is_disabled(uint32_t cnthv_ctl_val) noexcept { IS_BIT_DISABLED_FUNC(cnthv_ctl_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthv_ctl, 0x1) }
		inline uint32_t enable(uint32_t cnthv_ctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthv_ctl_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthv_ctl, 0x1) }
		inline uint32_t disable(uint32_t cnthv_ctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthv_ctl_val, 0x1) }
	}
}

// CNTHV_CVAL (Counter-timer Virtual Timer CompareValue register (EL2))
// See the ARMv8 architecture reference manual for a description of this register
namespace cnthv_cval
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(cnthv_cval) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cnthv_cval, val) }

	namespace comparevalue
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(cnthv_cval, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t cnthv_cval_val) noexcept { GET_BITFIELD_FUNC(cnthv_cval_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cnthv_cval, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t cnthv_cval, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cnthv_cval, value, 0xffffffffffffffff, 0) }
	}
}

// CNTHV_TVAL (Counter-timer Virtual Timer TimerValue register (EL2))
// See the ARMv8 architecture reference manual for a description of this register
namespace cnthv_tval
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cnthv_tval) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cnthv_tval, val) }

	namespace timervalue
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cnthv_tval, 0xffffffff, 0) }
		inline uint32_t get(uint32_t cnthv_tval_val) noexcept { GET_BITFIELD_FUNC(cnthv_tval_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cnthv_tval, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t cnthv_tval, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cnthv_tval, value, 0xffffffff, 0) }
	}
}

// CNTKCTL (Counter-timer Kernel Control register)
// Controls the generation of an event stream from the virtual counter, and access from EL0 modes to the physical counter, virtual counter, EL1 physical timers, and the virtual timer.
namespace cntkctl
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntkctl) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntkctl, val) }

	namespace pl0pten
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntkctl, 9) }
		inline uint32_t is_enabled(uint32_t cntkctl_val) noexcept { IS_BIT_ENABLED_FUNC(cntkctl_val, 9) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntkctl, 9) }
		inline uint32_t is_disabled(uint32_t cntkctl_val) noexcept { IS_BIT_DISABLED_FUNC(cntkctl_val, 9) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntkctl, 0x200) }
		inline uint32_t enable(uint32_t cntkctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cntkctl_val, 0x200) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntkctl, 0x200) }
		inline uint32_t disable(uint32_t cntkctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntkctl_val, 0x200) }
	}

	namespace pl0vten
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntkctl, 8) }
		inline uint32_t is_enabled(uint32_t cntkctl_val) noexcept { IS_BIT_ENABLED_FUNC(cntkctl_val, 8) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntkctl, 8) }
		inline uint32_t is_disabled(uint32_t cntkctl_val) noexcept { IS_BIT_DISABLED_FUNC(cntkctl_val, 8) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntkctl, 0x100) }
		inline uint32_t enable(uint32_t cntkctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cntkctl_val, 0x100) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntkctl, 0x100) }
		inline uint32_t disable(uint32_t cntkctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntkctl_val, 0x100) }
	}

	namespace evnti
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntkctl, 0xf0, 4) }
		inline uint32_t get(uint32_t cntkctl_val) noexcept { GET_BITFIELD_FUNC(cntkctl_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntkctl, value, 0xf0, 4) }
		inline uint32_t set(uint32_t cntkctl, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntkctl, value, 0xf0, 4) }
	}

	namespace evntdir
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntkctl, 3) }
		inline uint32_t is_enabled(uint32_t cntkctl_val) noexcept { IS_BIT_ENABLED_FUNC(cntkctl_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntkctl, 3) }
		inline uint32_t is_disabled(uint32_t cntkctl_val) noexcept { IS_BIT_DISABLED_FUNC(cntkctl_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntkctl, 0x8) }
		inline uint32_t enable(uint32_t cntkctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cntkctl_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntkctl, 0x8) }
		inline uint32_t disable(uint32_t cntkctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntkctl_val, 0x8) }
	}

	namespace evnten
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntkctl, 2) }
		inline uint32_t is_enabled(uint32_t cntkctl_val) noexcept { IS_BIT_ENABLED_FUNC(cntkctl_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntkctl, 2) }
		inline uint32_t is_disabled(uint32_t cntkctl_val) noexcept { IS_BIT_DISABLED_FUNC(cntkctl_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntkctl, 0x4) }
		inline uint32_t enable(uint32_t cntkctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cntkctl_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntkctl, 0x4) }
		inline uint32_t disable(uint32_t cntkctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntkctl_val, 0x4) }
	}

	namespace pl0vcten
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntkctl, 1) }
		inline uint32_t is_enabled(uint32_t cntkctl_val) noexcept { IS_BIT_ENABLED_FUNC(cntkctl_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntkctl, 1) }
		inline uint32_t is_disabled(uint32_t cntkctl_val) noexcept { IS_BIT_DISABLED_FUNC(cntkctl_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntkctl, 0x2) }
		inline uint32_t enable(uint32_t cntkctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cntkctl_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntkctl, 0x2) }
		inline uint32_t disable(uint32_t cntkctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntkctl_val, 0x2) }
	}

	namespace pl0pcten
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntkctl, 0) }
		inline uint32_t is_enabled(uint32_t cntkctl_val) noexcept { IS_BIT_ENABLED_FUNC(cntkctl_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntkctl, 0) }
		inline uint32_t is_disabled(uint32_t cntkctl_val) noexcept { IS_BIT_DISABLED_FUNC(cntkctl_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntkctl, 0x1) }
		inline uint32_t enable(uint32_t cntkctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cntkctl_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntkctl, 0x1) }
		inline uint32_t disable(uint32_t cntkctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntkctl_val, 0x1) }
	}
}

// CNTP_CTL (Counter-timer Physical Timer Control register)
// Control register for the EL1 physical timer.
namespace cntp_ctl
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntp_ctl) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntp_ctl, val) }

	namespace istatus
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntp_ctl, 2) }
		inline uint32_t is_enabled(uint32_t cntp_ctl_val) noexcept { IS_BIT_ENABLED_FUNC(cntp_ctl_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntp_ctl, 2) }
		inline uint32_t is_disabled(uint32_t cntp_ctl_val) noexcept { IS_BIT_DISABLED_FUNC(cntp_ctl_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntp_ctl, 0x4) }
		inline uint32_t enable(uint32_t cntp_ctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cntp_ctl_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntp_ctl, 0x4) }
		inline uint32_t disable(uint32_t cntp_ctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntp_ctl_val, 0x4) }
	}

	namespace imask
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntp_ctl, 1) }
		inline uint32_t is_enabled(uint32_t cntp_ctl_val) noexcept { IS_BIT_ENABLED_FUNC(cntp_ctl_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntp_ctl, 1) }
		inline uint32_t is_disabled(uint32_t cntp_ctl_val) noexcept { IS_BIT_DISABLED_FUNC(cntp_ctl_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntp_ctl, 0x2) }
		inline uint32_t enable(uint32_t cntp_ctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cntp_ctl_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntp_ctl, 0x2) }
		inline uint32_t disable(uint32_t cntp_ctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntp_ctl_val, 0x2) }
	}

	namespace enable
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntp_ctl, 0) }
		inline uint32_t is_enabled(uint32_t cntp_ctl_val) noexcept { IS_BIT_ENABLED_FUNC(cntp_ctl_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntp_ctl, 0) }
		inline uint32_t is_disabled(uint32_t cntp_ctl_val) noexcept { IS_BIT_DISABLED_FUNC(cntp_ctl_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntp_ctl, 0x1) }
		inline uint32_t enable(uint32_t cntp_ctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cntp_ctl_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntp_ctl, 0x1) }
		inline uint32_t disable(uint32_t cntp_ctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntp_ctl_val, 0x1) }
	}
}

// CNTP_CVAL (Counter-timer Physical Timer CompareValue register)
// Holds the compare value for the EL1 physical timer.
namespace cntp_cval
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(cntp_cval) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntp_cval, val) }

	namespace comparevalue
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntp_cval, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t cntp_cval_val) noexcept { GET_BITFIELD_FUNC(cntp_cval_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntp_cval, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t cntp_cval, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntp_cval, value, 0xffffffffffffffff, 0) }
	}
}

// CNTP_TVAL (Counter-timer Physical Timer TimerValue register)
// Holds the timer value for the EL1 physical timer.
namespace cntp_tval
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntp_tval) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntp_tval, val) }

	namespace timervalue
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntp_tval, 0xffffffff, 0) }
		inline uint32_t get(uint32_t cntp_tval_val) noexcept { GET_BITFIELD_FUNC(cntp_tval_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntp_tval, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t cntp_tval, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntp_tval, value, 0xffffffff, 0) }
	}
}

// CNTPCT (Counter-timer Physical Count register)
// Holds the 64-bit physical count value.
namespace cntpct
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(cntpct) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntpct, val) }

	namespace physical_count_value
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntpct, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t cntpct_val) noexcept { GET_BITFIELD_FUNC(cntpct_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntpct, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t cntpct, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntpct, value, 0xffffffffffffffff, 0) }
	}
}

// CNTV_CTL (Counter-timer Virtual Timer Control register)
// Control register for the virtual timer.
namespace cntv_ctl
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntv_ctl) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntv_ctl, val) }

	namespace istatus
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntv_ctl, 2) }
		inline uint32_t is_enabled(uint32_t cntv_ctl_val) noexcept { IS_BIT_ENABLED_FUNC(cntv_ctl_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntv_ctl, 2) }
		inline uint32_t is_disabled(uint32_t cntv_ctl_val) noexcept { IS_BIT_DISABLED_FUNC(cntv_ctl_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntv_ctl, 0x4) }
		inline uint32_t enable(uint32_t cntv_ctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cntv_ctl_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntv_ctl, 0x4) }
		inline uint32_t disable(uint32_t cntv_ctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntv_ctl_val, 0x4) }
	}

	namespace imask
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntv_ctl, 1) }
		inline uint32_t is_enabled(uint32_t cntv_ctl_val) noexcept { IS_BIT_ENABLED_FUNC(cntv_ctl_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntv_ctl, 1) }
		inline uint32_t is_disabled(uint32_t cntv_ctl_val) noexcept { IS_BIT_DISABLED_FUNC(cntv_ctl_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntv_ctl, 0x2) }
		inline uint32_t enable(uint32_t cntv_ctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cntv_ctl_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntv_ctl, 0x2) }
		inline uint32_t disable(uint32_t cntv_ctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntv_ctl_val, 0x2) }
	}

	namespace enable
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntv_ctl, 0) }
		inline uint32_t is_enabled(uint32_t cntv_ctl_val) noexcept { IS_BIT_ENABLED_FUNC(cntv_ctl_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntv_ctl, 0) }
		inline uint32_t is_disabled(uint32_t cntv_ctl_val) noexcept { IS_BIT_DISABLED_FUNC(cntv_ctl_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntv_ctl, 0x1) }
		inline uint32_t enable(uint32_t cntv_ctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cntv_ctl_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntv_ctl, 0x1) }
		inline uint32_t disable(uint32_t cntv_ctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntv_ctl_val, 0x1) }
	}
}

// CNTV_CVAL (Counter-timer Virtual Timer CompareValue register)
// Holds the compare value for the virtual timer.
namespace cntv_cval
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(cntv_cval) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntv_cval, val) }

	namespace comparevalue
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntv_cval, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t cntv_cval_val) noexcept { GET_BITFIELD_FUNC(cntv_cval_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntv_cval, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t cntv_cval, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntv_cval, value, 0xffffffffffffffff, 0) }
	}
}

// CNTV_TVAL (Counter-timer Virtual Timer TimerValue register)
// Holds the timer value for the virtual timer.
namespace cntv_tval
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntv_tval) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntv_tval, val) }

	namespace timervalue
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntv_tval, 0xffffffff, 0) }
		inline uint32_t get(uint32_t cntv_tval_val) noexcept { GET_BITFIELD_FUNC(cntv_tval_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntv_tval, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t cntv_tval, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntv_tval, value, 0xffffffff, 0) }
	}
}

// CNTVCT (Counter-timer Virtual Count register)
// Holds the 64-bit virtual count value. The virtual count value is equal to the physical count value visible in CNTPCT minus the virtual offset visible in CNTVOFF.
namespace cntvct
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(cntvct) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntvct, val) }

	namespace virtual_count_value
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntvct, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t cntvct_val) noexcept { GET_BITFIELD_FUNC(cntvct_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntvct, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t cntvct, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntvct, value, 0xffffffffffffffff, 0) }
	}
}

// CNTVOFF (Counter-timer Virtual Offset register)
// Holds the 64-bit virtual offset. This is the offset between the physical count value visible in CNTPCT and the virtual count value visible in CNTVCT.
namespace cntvoff
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(cntvoff) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntvoff, val) }

	namespace virtual_offset
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntvoff, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t cntvoff_val) noexcept { GET_BITFIELD_FUNC(cntvoff_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntvoff, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t cntvoff, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntvoff, value, 0xffffffffffffffff, 0) }
	}
}

// CONTEXTIDR (Context ID Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace contextidr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(contextidr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(contextidr, val) }

	// Fieldset valid when: TTBCR.EAE==0
	namespace fieldset_1
	{
		namespace procid
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(contextidr, 0xffffff00, 8) }
			inline uint32_t get(uint32_t contextidr_val) noexcept { GET_BITFIELD_FUNC(contextidr_val, 0xffffff00, 8) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(contextidr, value, 0xffffff00, 8) }
			inline uint32_t set(uint32_t contextidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(contextidr, value, 0xffffff00, 8) }
		}

		namespace asid
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(contextidr, 0xff, 0) }
			inline uint32_t get(uint32_t contextidr_val) noexcept { GET_BITFIELD_FUNC(contextidr_val, 0xff, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(contextidr, value, 0xff, 0) }
			inline uint32_t set(uint32_t contextidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(contextidr, value, 0xff, 0) }
		}
	}

	// Fieldset valid when: TTBCR.EAE==1
	namespace fieldset_2
	{
		namespace procid
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(contextidr, 0xffffffff, 0) }
			inline uint32_t get(uint32_t contextidr_val) noexcept { GET_BITFIELD_FUNC(contextidr_val, 0xffffffff, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(contextidr, value, 0xffffffff, 0) }
			inline uint32_t set(uint32_t contextidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(contextidr, value, 0xffffffff, 0) }
		}
	}
}

// CP15DMB (Data Memory Barrier System instruction)
// See the ARMv8 architecture reference manual for a description of this register
namespace cp15dmb
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cp15dmb) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cp15dmb, val) }
}

// CP15DSB (Data Synchronization Barrier System instruction)
// See the ARMv8 architecture reference manual for a description of this register
namespace cp15dsb
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cp15dsb) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cp15dsb, val) }
}

// CP15ISB (Instruction Synchronization Barrier System instruction)
// See the ARMv8 architecture reference manual for a description of this register
namespace cp15isb
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cp15isb) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cp15isb, val) }
}

// CPACR (Architectural Feature Access Control Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace cpacr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cpacr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cpacr, val) }

	namespace asedis
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cpacr, 31) }
		inline uint32_t is_enabled(uint32_t cpacr_val) noexcept { IS_BIT_ENABLED_FUNC(cpacr_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cpacr, 31) }
		inline uint32_t is_disabled(uint32_t cpacr_val) noexcept { IS_BIT_DISABLED_FUNC(cpacr_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cpacr, 0x80000000) }
		inline uint32_t enable(uint32_t cpacr_val) noexcept { SET_BITS_BY_MASK_FUNC(cpacr_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cpacr, 0x80000000) }
		inline uint32_t disable(uint32_t cpacr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cpacr_val, 0x80000000) }
	}

	namespace trcdis
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cpacr, 28) }
		inline uint32_t is_enabled(uint32_t cpacr_val) noexcept { IS_BIT_ENABLED_FUNC(cpacr_val, 28) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cpacr, 28) }
		inline uint32_t is_disabled(uint32_t cpacr_val) noexcept { IS_BIT_DISABLED_FUNC(cpacr_val, 28) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cpacr, 0x10000000) }
		inline uint32_t enable(uint32_t cpacr_val) noexcept { SET_BITS_BY_MASK_FUNC(cpacr_val, 0x10000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cpacr, 0x10000000) }
		inline uint32_t disable(uint32_t cpacr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cpacr_val, 0x10000000) }
	}

	namespace cp11
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cpacr, 0xc00000, 22) }
		inline uint32_t get(uint32_t cpacr_val) noexcept { GET_BITFIELD_FUNC(cpacr_val, 0xc00000, 22) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cpacr, value, 0xc00000, 22) }
		inline uint32_t set(uint32_t cpacr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cpacr, value, 0xc00000, 22) }
	}

	namespace cp10
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cpacr, 0x300000, 20) }
		inline uint32_t get(uint32_t cpacr_val) noexcept { GET_BITFIELD_FUNC(cpacr_val, 0x300000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cpacr, value, 0x300000, 20) }
		inline uint32_t set(uint32_t cpacr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cpacr, value, 0x300000, 20) }
	}
}

// CPSR (Current Program Status Register)
// Holds PE status and control information.
namespace cpsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cpsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cpsr, val) }
}

// CSSELR (Cache Size Selection Register)
// Selects the current Cache Size ID Register, CCSIDR, by specifying the required cache level and the cache type (either instruction or data cache).
namespace csselr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(csselr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(csselr, val) }

	namespace level
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(csselr, 0xe, 1) }
		inline uint32_t get(uint32_t csselr_val) noexcept { GET_BITFIELD_FUNC(csselr_val, 0xe, 1) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(csselr, value, 0xe, 1) }
		inline uint32_t set(uint32_t csselr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(csselr, value, 0xe, 1) }
	}

	namespace ind
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(csselr, 0) }
		inline uint32_t is_enabled(uint32_t csselr_val) noexcept { IS_BIT_ENABLED_FUNC(csselr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(csselr, 0) }
		inline uint32_t is_disabled(uint32_t csselr_val) noexcept { IS_BIT_DISABLED_FUNC(csselr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(csselr, 0x1) }
		inline uint32_t enable(uint32_t csselr_val) noexcept { SET_BITS_BY_MASK_FUNC(csselr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(csselr, 0x1) }
		inline uint32_t disable(uint32_t csselr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(csselr_val, 0x1) }
	}
}

// CTR (Cache Type Register)
// Provides information about the architecture of the caches.
namespace ctr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctr, val) }

	namespace cwg
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctr, 0xf000000, 24) }
		inline uint32_t get(uint32_t ctr_val) noexcept { GET_BITFIELD_FUNC(ctr_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctr, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t ctr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctr, value, 0xf000000, 24) }
	}

	namespace erg
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctr, 0xf00000, 20) }
		inline uint32_t get(uint32_t ctr_val) noexcept { GET_BITFIELD_FUNC(ctr_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctr, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t ctr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctr, value, 0xf00000, 20) }
	}

	namespace dminline
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctr, 0xf0000, 16) }
		inline uint32_t get(uint32_t ctr_val) noexcept { GET_BITFIELD_FUNC(ctr_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctr, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t ctr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctr, value, 0xf0000, 16) }
	}

	namespace l1ip
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctr, 0xc000, 14) }
		inline uint32_t get(uint32_t ctr_val) noexcept { GET_BITFIELD_FUNC(ctr_val, 0xc000, 14) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctr, value, 0xc000, 14) }
		inline uint32_t set(uint32_t ctr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctr, value, 0xc000, 14) }
	}

	namespace iminline
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctr, 0xf, 0) }
		inline uint32_t get(uint32_t ctr_val) noexcept { GET_BITFIELD_FUNC(ctr_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctr, value, 0xf, 0) }
		inline uint32_t set(uint32_t ctr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctr, value, 0xf, 0) }
	}
}

// DACR (Domain Access Control Register)
// Defines the access permission for each of the sixteen memory domains.
namespace dacr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dacr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dacr, val) }

	namespace d_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dacr, 0xffffffff, 0) }
		inline uint32_t get(uint32_t dacr_val) noexcept { GET_BITFIELD_FUNC(dacr_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dacr, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t dacr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dacr, value, 0xffffffff, 0) }
	}
}

// DBGAUTHSTATUS (Debug Authentication Status register)
// Provides information about the state of the IMPLEMENTATION DEFINED authentication interface for debug.
namespace dbgauthstatus
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgauthstatus) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgauthstatus, val) }

	namespace snid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgauthstatus, 0xc0, 6) }
		inline uint32_t get(uint32_t dbgauthstatus_val) noexcept { GET_BITFIELD_FUNC(dbgauthstatus_val, 0xc0, 6) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgauthstatus, value, 0xc0, 6) }
		inline uint32_t set(uint32_t dbgauthstatus, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgauthstatus, value, 0xc0, 6) }
	}

	namespace sid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgauthstatus, 0x30, 4) }
		inline uint32_t get(uint32_t dbgauthstatus_val) noexcept { GET_BITFIELD_FUNC(dbgauthstatus_val, 0x30, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgauthstatus, value, 0x30, 4) }
		inline uint32_t set(uint32_t dbgauthstatus, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgauthstatus, value, 0x30, 4) }
	}

	namespace nsnid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgauthstatus, 0xc, 2) }
		inline uint32_t get(uint32_t dbgauthstatus_val) noexcept { GET_BITFIELD_FUNC(dbgauthstatus_val, 0xc, 2) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgauthstatus, value, 0xc, 2) }
		inline uint32_t set(uint32_t dbgauthstatus, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgauthstatus, value, 0xc, 2) }
	}

	namespace nsid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgauthstatus, 0x3, 0) }
		inline uint32_t get(uint32_t dbgauthstatus_val) noexcept { GET_BITFIELD_FUNC(dbgauthstatus_val, 0x3, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgauthstatus, value, 0x3, 0) }
		inline uint32_t set(uint32_t dbgauthstatus, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgauthstatus, value, 0x3, 0) }
	}
}

// DBGBCR<n> (Debug Breakpoint Control Registers)
// Holds control information for a breakpoint. Forms breakpoint n together with value register DBGBVR<n>. If EL2 is implemented and this breakpoint supports Context matching, DBGBVR<n> can be associated with a Breakpoint Extended Value Register DBGBXVR<n> for VMID matching.
namespace dbgbcr<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgbcr<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgbcr<n>, val) }

	namespace bt
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbcr<n>, 0xf00000, 20) }
		inline uint32_t get(uint32_t dbgbcr<n>_val) noexcept { GET_BITFIELD_FUNC(dbgbcr<n>_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbcr<n>, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t dbgbcr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbcr<n>, value, 0xf00000, 20) }
	}

	namespace lbn
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbcr<n>, 0xf0000, 16) }
		inline uint32_t get(uint32_t dbgbcr<n>_val) noexcept { GET_BITFIELD_FUNC(dbgbcr<n>_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbcr<n>, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t dbgbcr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbcr<n>, value, 0xf0000, 16) }
	}

	namespace ssc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbcr<n>, 0xc000, 14) }
		inline uint32_t get(uint32_t dbgbcr<n>_val) noexcept { GET_BITFIELD_FUNC(dbgbcr<n>_val, 0xc000, 14) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbcr<n>, value, 0xc000, 14) }
		inline uint32_t set(uint32_t dbgbcr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbcr<n>, value, 0xc000, 14) }
	}

	namespace hmc
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgbcr<n>, 13) }
		inline uint32_t is_enabled(uint32_t dbgbcr<n>_val) noexcept { IS_BIT_ENABLED_FUNC(dbgbcr<n>_val, 13) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgbcr<n>, 13) }
		inline uint32_t is_disabled(uint32_t dbgbcr<n>_val) noexcept { IS_BIT_DISABLED_FUNC(dbgbcr<n>_val, 13) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgbcr<n>, 0x2000) }
		inline uint32_t enable(uint32_t dbgbcr<n>_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgbcr<n>_val, 0x2000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgbcr<n>, 0x2000) }
		inline uint32_t disable(uint32_t dbgbcr<n>_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgbcr<n>_val, 0x2000) }
	}

	namespace bas
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbcr<n>, 0x1e0, 5) }
		inline uint32_t get(uint32_t dbgbcr<n>_val) noexcept { GET_BITFIELD_FUNC(dbgbcr<n>_val, 0x1e0, 5) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbcr<n>, value, 0x1e0, 5) }
		inline uint32_t set(uint32_t dbgbcr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbcr<n>, value, 0x1e0, 5) }
	}

	namespace pmc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbcr<n>, 0x6, 1) }
		inline uint32_t get(uint32_t dbgbcr<n>_val) noexcept { GET_BITFIELD_FUNC(dbgbcr<n>_val, 0x6, 1) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbcr<n>, value, 0x6, 1) }
		inline uint32_t set(uint32_t dbgbcr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbcr<n>, value, 0x6, 1) }
	}

	namespace e
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgbcr<n>, 0) }
		inline uint32_t is_enabled(uint32_t dbgbcr<n>_val) noexcept { IS_BIT_ENABLED_FUNC(dbgbcr<n>_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgbcr<n>, 0) }
		inline uint32_t is_disabled(uint32_t dbgbcr<n>_val) noexcept { IS_BIT_DISABLED_FUNC(dbgbcr<n>_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgbcr<n>, 0x1) }
		inline uint32_t enable(uint32_t dbgbcr<n>_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgbcr<n>_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgbcr<n>, 0x1) }
		inline uint32_t disable(uint32_t dbgbcr<n>_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgbcr<n>_val, 0x1) }
	}
}

// DBGBVR<n> (Debug Breakpoint Value Registers)
// Holds a value for use in breakpoint matching, either the virtual address of an instruction or a context ID. Forms breakpoint n together with control register DBGBCR<n>. If EL2 is implemented and this breakpoint supports Context matching, DBGBVR<n> can be associated with a Breakpoint Extended Value Register DBGBXVR<n> for VMID matching.
namespace dbgbvr<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgbvr<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgbvr<n>, val) }

	// Fieldset valid when: DBGBCR<n>.BT==0b0x0x
	namespace fieldset_1
	{
		namespace va_31:2_
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbvr<n>, 0xfffffffc, 2) }
			inline uint32_t get(uint32_t dbgbvr<n>_val) noexcept { GET_BITFIELD_FUNC(dbgbvr<n>_val, 0xfffffffc, 2) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbvr<n>, value, 0xfffffffc, 2) }
			inline uint32_t set(uint32_t dbgbvr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbvr<n>, value, 0xfffffffc, 2) }
		}
	}

	// Fieldset valid when: DBGBCR<n>.BT==0b001x
	namespace fieldset_2
	{
		namespace contextid
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbvr<n>, 0xffffffff, 0) }
			inline uint32_t get(uint32_t dbgbvr<n>_val) noexcept { GET_BITFIELD_FUNC(dbgbvr<n>_val, 0xffffffff, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbvr<n>, value, 0xffffffff, 0) }
			inline uint32_t set(uint32_t dbgbvr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbvr<n>, value, 0xffffffff, 0) }
		}
	}

	// Fieldset valid when: DBGBCR<n>.BT==0b101x and EL2 implemented
	namespace fieldset_3
	{
		namespace contextid
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbvr<n>, 0xffffffff, 0) }
			inline uint32_t get(uint32_t dbgbvr<n>_val) noexcept { GET_BITFIELD_FUNC(dbgbvr<n>_val, 0xffffffff, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbvr<n>, value, 0xffffffff, 0) }
			inline uint32_t set(uint32_t dbgbvr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbvr<n>, value, 0xffffffff, 0) }
		}
	}

	// Fieldset valid when: DBGBCR<n>.BT==0b111x and EL2 implemented
	namespace fieldset_4
	{
		namespace contextid
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbvr<n>, 0xffffffff, 0) }
			inline uint32_t get(uint32_t dbgbvr<n>_val) noexcept { GET_BITFIELD_FUNC(dbgbvr<n>_val, 0xffffffff, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbvr<n>, value, 0xffffffff, 0) }
			inline uint32_t set(uint32_t dbgbvr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbvr<n>, value, 0xffffffff, 0) }
		}
	}
}

// DBGBXVR<n> (Debug Breakpoint Extended Value Registers)
// Holds a value for use in breakpoint matching, to support VMID matching. Used in conjunction with a control register DBGBCR<n> and a value register DBGBVR<n>, where EL2 is implemented and breakpoint n supports Context matching.
namespace dbgbxvr<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgbxvr<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgbxvr<n>, val) }

	// Fieldset valid when: DBGBCR<n>.BT==0b10xx and EL2 implemented
	namespace fieldset_1
	{	}

	// Fieldset valid when: DBGBCR<n>.BT==0b11xx and EL2 implemented
	namespace fieldset_2
	{
		namespace contextid2
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbxvr<n>, 0xffffffff, 0) }
			inline uint32_t get(uint32_t dbgbxvr<n>_val) noexcept { GET_BITFIELD_FUNC(dbgbxvr<n>_val, 0xffffffff, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbxvr<n>, value, 0xffffffff, 0) }
			inline uint32_t set(uint32_t dbgbxvr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbxvr<n>, value, 0xffffffff, 0) }
		}
	}
}

// DBGCLAIMCLR (Debug Claim Tag Clear register)
// See the ARMv8 architecture reference manual for a description of this register
namespace dbgclaimclr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgclaimclr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgclaimclr, val) }

	namespace claim
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgclaimclr, 0xff, 0) }
		inline uint32_t get(uint32_t dbgclaimclr_val) noexcept { GET_BITFIELD_FUNC(dbgclaimclr_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgclaimclr, value, 0xff, 0) }
		inline uint32_t set(uint32_t dbgclaimclr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgclaimclr, value, 0xff, 0) }
	}
}

// DBGCLAIMSET (Debug Claim Tag Set register)
// See the ARMv8 architecture reference manual for a description of this register
namespace dbgclaimset
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgclaimset) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgclaimset, val) }

	namespace claim
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgclaimset, 0xff, 0) }
		inline uint32_t get(uint32_t dbgclaimset_val) noexcept { GET_BITFIELD_FUNC(dbgclaimset_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgclaimset, value, 0xff, 0) }
		inline uint32_t set(uint32_t dbgclaimset, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgclaimset, value, 0xff, 0) }
	}
}

// DBGDCCINT (DCC Interrupt Enable Register)
// Enables interrupt requests to be signaled based on the DCC status flags.
namespace dbgdccint
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgdccint) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgdccint, val) }

	namespace rx
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgdccint, 30) }
		inline uint32_t is_enabled(uint32_t dbgdccint_val) noexcept { IS_BIT_ENABLED_FUNC(dbgdccint_val, 30) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgdccint, 30) }
		inline uint32_t is_disabled(uint32_t dbgdccint_val) noexcept { IS_BIT_DISABLED_FUNC(dbgdccint_val, 30) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgdccint, 0x40000000) }
		inline uint32_t enable(uint32_t dbgdccint_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgdccint_val, 0x40000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgdccint, 0x40000000) }
		inline uint32_t disable(uint32_t dbgdccint_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgdccint_val, 0x40000000) }
	}

	namespace tx
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgdccint, 29) }
		inline uint32_t is_enabled(uint32_t dbgdccint_val) noexcept { IS_BIT_ENABLED_FUNC(dbgdccint_val, 29) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgdccint, 29) }
		inline uint32_t is_disabled(uint32_t dbgdccint_val) noexcept { IS_BIT_DISABLED_FUNC(dbgdccint_val, 29) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgdccint, 0x20000000) }
		inline uint32_t enable(uint32_t dbgdccint_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgdccint_val, 0x20000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgdccint, 0x20000000) }
		inline uint32_t disable(uint32_t dbgdccint_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgdccint_val, 0x20000000) }
	}
}

// DBGDEVID (Debug Device ID register 0)
// Adds to the information given by the DBGDIDR by describing other features of the debug implementation.
namespace dbgdevid
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgdevid) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgdevid, val) }

	namespace cidmask
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdevid, 0xf0000000, 28) }
		inline uint32_t get(uint32_t dbgdevid_val) noexcept { GET_BITFIELD_FUNC(dbgdevid_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdevid, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t dbgdevid, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdevid, value, 0xf0000000, 28) }
	}

	namespace auxregs
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdevid, 0xf000000, 24) }
		inline uint32_t get(uint32_t dbgdevid_val) noexcept { GET_BITFIELD_FUNC(dbgdevid_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdevid, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t dbgdevid, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdevid, value, 0xf000000, 24) }
	}

	namespace doublelock
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdevid, 0xf00000, 20) }
		inline uint32_t get(uint32_t dbgdevid_val) noexcept { GET_BITFIELD_FUNC(dbgdevid_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdevid, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t dbgdevid, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdevid, value, 0xf00000, 20) }
	}

	namespace virtextns
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdevid, 0xf0000, 16) }
		inline uint32_t get(uint32_t dbgdevid_val) noexcept { GET_BITFIELD_FUNC(dbgdevid_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdevid, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t dbgdevid, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdevid, value, 0xf0000, 16) }
	}

	namespace vectorcatch
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdevid, 0xf000, 12) }
		inline uint32_t get(uint32_t dbgdevid_val) noexcept { GET_BITFIELD_FUNC(dbgdevid_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdevid, value, 0xf000, 12) }
		inline uint32_t set(uint32_t dbgdevid, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdevid, value, 0xf000, 12) }
	}

	namespace bpaddrmask
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdevid, 0xf00, 8) }
		inline uint32_t get(uint32_t dbgdevid_val) noexcept { GET_BITFIELD_FUNC(dbgdevid_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdevid, value, 0xf00, 8) }
		inline uint32_t set(uint32_t dbgdevid, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdevid, value, 0xf00, 8) }
	}

	namespace wpaddrmask
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdevid, 0xf0, 4) }
		inline uint32_t get(uint32_t dbgdevid_val) noexcept { GET_BITFIELD_FUNC(dbgdevid_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdevid, value, 0xf0, 4) }
		inline uint32_t set(uint32_t dbgdevid, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdevid, value, 0xf0, 4) }
	}

	namespace pcsample
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdevid, 0xf, 0) }
		inline uint32_t get(uint32_t dbgdevid_val) noexcept { GET_BITFIELD_FUNC(dbgdevid_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdevid, value, 0xf, 0) }
		inline uint32_t set(uint32_t dbgdevid, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdevid, value, 0xf, 0) }
	}
}

// DBGDEVID1 (Debug Device ID register 1)
// Adds to the information given by the DBGDIDR by describing other features of the debug implementation.
namespace dbgdevid1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgdevid1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgdevid1, val) }

	namespace pcsroffset
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdevid1, 0xf, 0) }
		inline uint32_t get(uint32_t dbgdevid1_val) noexcept { GET_BITFIELD_FUNC(dbgdevid1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdevid1, value, 0xf, 0) }
		inline uint32_t set(uint32_t dbgdevid1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdevid1, value, 0xf, 0) }
	}
}

// DBGDEVID2 (Debug Device ID register 2)
// Reserved for future descriptions of features of the debug implementation.
namespace dbgdevid2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgdevid2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgdevid2, val) }
}

// DBGDIDR (Debug ID Register)
// Specifies which version of the Debug architecture is implemented, and some features of the debug implementation.
namespace dbgdidr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgdidr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgdidr, val) }

	namespace wrps
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdidr, 0xf0000000, 28) }
		inline uint32_t get(uint32_t dbgdidr_val) noexcept { GET_BITFIELD_FUNC(dbgdidr_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdidr, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t dbgdidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdidr, value, 0xf0000000, 28) }
	}

	namespace brps
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdidr, 0xf000000, 24) }
		inline uint32_t get(uint32_t dbgdidr_val) noexcept { GET_BITFIELD_FUNC(dbgdidr_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdidr, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t dbgdidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdidr, value, 0xf000000, 24) }
	}

	namespace ctx_cmps
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdidr, 0xf00000, 20) }
		inline uint32_t get(uint32_t dbgdidr_val) noexcept { GET_BITFIELD_FUNC(dbgdidr_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdidr, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t dbgdidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdidr, value, 0xf00000, 20) }
	}

	namespace version
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdidr, 0xf0000, 16) }
		inline uint32_t get(uint32_t dbgdidr_val) noexcept { GET_BITFIELD_FUNC(dbgdidr_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdidr, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t dbgdidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdidr, value, 0xf0000, 16) }
	}

	namespace nsuhd_imp
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgdidr, 14) }
		inline uint32_t is_enabled(uint32_t dbgdidr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgdidr_val, 14) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgdidr, 14) }
		inline uint32_t is_disabled(uint32_t dbgdidr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgdidr_val, 14) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgdidr, 0x4000) }
		inline uint32_t enable(uint32_t dbgdidr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgdidr_val, 0x4000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgdidr, 0x4000) }
		inline uint32_t disable(uint32_t dbgdidr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgdidr_val, 0x4000) }
	}

	namespace se_imp
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgdidr, 12) }
		inline uint32_t is_enabled(uint32_t dbgdidr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgdidr_val, 12) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgdidr, 12) }
		inline uint32_t is_disabled(uint32_t dbgdidr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgdidr_val, 12) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgdidr, 0x1000) }
		inline uint32_t enable(uint32_t dbgdidr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgdidr_val, 0x1000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgdidr, 0x1000) }
		inline uint32_t disable(uint32_t dbgdidr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgdidr_val, 0x1000) }
	}
}

// DBGDRAR (Debug ROM Address Register)
// Defines the base physical address of a 4KB-aligned memory-mapped debug component, usually a ROM table that locates and describes the memory-mapped debug components in the system. ARMv8 deprecates any use of this register.
namespace dbgdrar
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgdrar) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgdrar, val) }

	// Fieldset valid when: accessing as a 32-bit register
	namespace fieldset_1
	{
		namespace romaddr_31:12_
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdrar, 0xfffff000, 12) }
			inline uint32_t get(uint32_t dbgdrar_val) noexcept { GET_BITFIELD_FUNC(dbgdrar_val, 0xfffff000, 12) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdrar, value, 0xfffff000, 12) }
			inline uint32_t set(uint32_t dbgdrar, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdrar, value, 0xfffff000, 12) }
		}

		namespace valid
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdrar, 0x3, 0) }
			inline uint32_t get(uint32_t dbgdrar_val) noexcept { GET_BITFIELD_FUNC(dbgdrar_val, 0x3, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdrar, value, 0x3, 0) }
			inline uint32_t set(uint32_t dbgdrar, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdrar, value, 0x3, 0) }
		}
	}

	// Fieldset valid when: accessing as a 64-bit register
	namespace fieldset_2
	{	}
}

// DBGDSAR (Debug Self Address Register)
// In earlier versions of the ARM Architecture, this register defines the offset from the base address defined in DBGDRAR of the physical base address of the debug registers for the PE. ARMv8 deprecates any use of this register.
namespace dbgdsar
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgdsar) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgdsar, val) }

	// Fieldset valid when: accessing as a 32-bit register
	namespace fieldset_1
	{
		namespace offset
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdsar, 0xffffffff, 0) }
			inline uint32_t get(uint32_t dbgdsar_val) noexcept { GET_BITFIELD_FUNC(dbgdsar_val, 0xffffffff, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdsar, value, 0xffffffff, 0) }
			inline uint32_t set(uint32_t dbgdsar, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdsar, value, 0xffffffff, 0) }
		}
	}

	// Fieldset valid when: accessing as a 64-bit register
	namespace fieldset_2
	{	}
}

// DBGDSCRext (Debug Status and Control Register, External View)
// Main control register for the debug implementation.
namespace dbgdscrext
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgdscrext) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgdscrext, val) }
}

// DBGDSCRint (Debug Status and Control Register, Internal View)
// Main control register for the debug implementation. This is an internal, read-only view.
namespace dbgdscrint
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgdscrint) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgdscrint, val) }

	namespace rxfull
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgdscrint, 30) }
		inline uint32_t is_enabled(uint32_t dbgdscrint_val) noexcept { IS_BIT_ENABLED_FUNC(dbgdscrint_val, 30) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgdscrint, 30) }
		inline uint32_t is_disabled(uint32_t dbgdscrint_val) noexcept { IS_BIT_DISABLED_FUNC(dbgdscrint_val, 30) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgdscrint, 0x40000000) }
		inline uint32_t enable(uint32_t dbgdscrint_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgdscrint_val, 0x40000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgdscrint, 0x40000000) }
		inline uint32_t disable(uint32_t dbgdscrint_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgdscrint_val, 0x40000000) }
	}

	namespace txfull
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgdscrint, 29) }
		inline uint32_t is_enabled(uint32_t dbgdscrint_val) noexcept { IS_BIT_ENABLED_FUNC(dbgdscrint_val, 29) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgdscrint, 29) }
		inline uint32_t is_disabled(uint32_t dbgdscrint_val) noexcept { IS_BIT_DISABLED_FUNC(dbgdscrint_val, 29) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgdscrint, 0x20000000) }
		inline uint32_t enable(uint32_t dbgdscrint_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgdscrint_val, 0x20000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgdscrint, 0x20000000) }
		inline uint32_t disable(uint32_t dbgdscrint_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgdscrint_val, 0x20000000) }
	}

	namespace ns
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgdscrint, 18) }
		inline uint32_t is_enabled(uint32_t dbgdscrint_val) noexcept { IS_BIT_ENABLED_FUNC(dbgdscrint_val, 18) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgdscrint, 18) }
		inline uint32_t is_disabled(uint32_t dbgdscrint_val) noexcept { IS_BIT_DISABLED_FUNC(dbgdscrint_val, 18) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgdscrint, 0x40000) }
		inline uint32_t enable(uint32_t dbgdscrint_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgdscrint_val, 0x40000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgdscrint, 0x40000) }
		inline uint32_t disable(uint32_t dbgdscrint_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgdscrint_val, 0x40000) }
	}

	namespace spniddis
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgdscrint, 17) }
		inline uint32_t is_enabled(uint32_t dbgdscrint_val) noexcept { IS_BIT_ENABLED_FUNC(dbgdscrint_val, 17) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgdscrint, 17) }
		inline uint32_t is_disabled(uint32_t dbgdscrint_val) noexcept { IS_BIT_DISABLED_FUNC(dbgdscrint_val, 17) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgdscrint, 0x20000) }
		inline uint32_t enable(uint32_t dbgdscrint_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgdscrint_val, 0x20000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgdscrint, 0x20000) }
		inline uint32_t disable(uint32_t dbgdscrint_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgdscrint_val, 0x20000) }
	}

	namespace spiddis
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgdscrint, 16) }
		inline uint32_t is_enabled(uint32_t dbgdscrint_val) noexcept { IS_BIT_ENABLED_FUNC(dbgdscrint_val, 16) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgdscrint, 16) }
		inline uint32_t is_disabled(uint32_t dbgdscrint_val) noexcept { IS_BIT_DISABLED_FUNC(dbgdscrint_val, 16) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgdscrint, 0x10000) }
		inline uint32_t enable(uint32_t dbgdscrint_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgdscrint_val, 0x10000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgdscrint, 0x10000) }
		inline uint32_t disable(uint32_t dbgdscrint_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgdscrint_val, 0x10000) }
	}

	namespace mdbgen
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgdscrint, 15) }
		inline uint32_t is_enabled(uint32_t dbgdscrint_val) noexcept { IS_BIT_ENABLED_FUNC(dbgdscrint_val, 15) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgdscrint, 15) }
		inline uint32_t is_disabled(uint32_t dbgdscrint_val) noexcept { IS_BIT_DISABLED_FUNC(dbgdscrint_val, 15) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgdscrint, 0x8000) }
		inline uint32_t enable(uint32_t dbgdscrint_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgdscrint_val, 0x8000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgdscrint, 0x8000) }
		inline uint32_t disable(uint32_t dbgdscrint_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgdscrint_val, 0x8000) }
	}

	namespace udccdis
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgdscrint, 12) }
		inline uint32_t is_enabled(uint32_t dbgdscrint_val) noexcept { IS_BIT_ENABLED_FUNC(dbgdscrint_val, 12) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgdscrint, 12) }
		inline uint32_t is_disabled(uint32_t dbgdscrint_val) noexcept { IS_BIT_DISABLED_FUNC(dbgdscrint_val, 12) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgdscrint, 0x1000) }
		inline uint32_t enable(uint32_t dbgdscrint_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgdscrint_val, 0x1000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgdscrint, 0x1000) }
		inline uint32_t disable(uint32_t dbgdscrint_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgdscrint_val, 0x1000) }
	}

	namespace moe
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdscrint, 0x3c, 2) }
		inline uint32_t get(uint32_t dbgdscrint_val) noexcept { GET_BITFIELD_FUNC(dbgdscrint_val, 0x3c, 2) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdscrint, value, 0x3c, 2) }
		inline uint32_t set(uint32_t dbgdscrint, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdscrint, value, 0x3c, 2) }
	}
}

// DBGDTRRXext (Debug OS Lock Data Transfer Register, Receive, External View)
// Used for save/restore of DBGDTRRXint. It is a component of the Debug Communications Channel.
namespace dbgdtrrxext
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgdtrrxext) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgdtrrxext, val) }

	namespace update_dtrrx_without_side-effect
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdtrrxext, 0xffffffff, 0) }
		inline uint32_t get(uint32_t dbgdtrrxext_val) noexcept { GET_BITFIELD_FUNC(dbgdtrrxext_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdtrrxext, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t dbgdtrrxext, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdtrrxext, value, 0xffffffff, 0) }
	}
}

// DBGDTRRXint (Debug Data Transfer Register, Receive)
// Transfers data from an external debugger to the PE. For example, it is used by a debugger transferring commands and data to a debug target. It is a component of the Debug Communications Channel.
namespace dbgdtrrxint
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgdtrrxint) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgdtrrxint, val) }

	namespace update_dtrrx
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdtrrxint, 0xffffffff, 0) }
		inline uint32_t get(uint32_t dbgdtrrxint_val) noexcept { GET_BITFIELD_FUNC(dbgdtrrxint_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdtrrxint, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t dbgdtrrxint, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdtrrxint, value, 0xffffffff, 0) }
	}
}

// DBGDTRTXext (Debug OS Lock Data Transfer Register, Transmit)
// Used for save/restore of DBGDTRTXint. It is a component of the Debug Communication Channel.
namespace dbgdtrtxext
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgdtrtxext) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgdtrtxext, val) }

	namespace return_dtrtx_without_side-effect
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdtrtxext, 0xffffffff, 0) }
		inline uint32_t get(uint32_t dbgdtrtxext_val) noexcept { GET_BITFIELD_FUNC(dbgdtrtxext_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdtrtxext, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t dbgdtrtxext, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdtrtxext, value, 0xffffffff, 0) }
	}
}

// DBGDTRTXint (Debug Data Transfer Register, Transmit)
// Transfers data from the PE to an external debugger. For example, it is used by a debug target to transfer data to the debugger. It is a component of the Debug Communication Channel.
namespace dbgdtrtxint
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgdtrtxint) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgdtrtxint, val) }

	namespace return_dtrtx
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdtrtxint, 0xffffffff, 0) }
		inline uint32_t get(uint32_t dbgdtrtxint_val) noexcept { GET_BITFIELD_FUNC(dbgdtrtxint_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdtrtxint, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t dbgdtrtxint, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdtrtxint, value, 0xffffffff, 0) }
	}
}

// DBGOSDLR (Debug OS Double Lock Register)
// Locks out the external debug interface.
namespace dbgosdlr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgosdlr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgosdlr, val) }

	namespace dlk
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgosdlr, 0) }
		inline uint32_t is_enabled(uint32_t dbgosdlr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgosdlr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgosdlr, 0) }
		inline uint32_t is_disabled(uint32_t dbgosdlr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgosdlr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgosdlr, 0x1) }
		inline uint32_t enable(uint32_t dbgosdlr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgosdlr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgosdlr, 0x1) }
		inline uint32_t disable(uint32_t dbgosdlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgosdlr_val, 0x1) }
	}
}

// DBGOSECCR (Debug OS Lock Exception Catch Control Register)
// Provides a mechanism for an operating system to access the contents of EDECCR that are otherwise invisible to software, so it can save/restore the contents of EDECCR over powerdown on behalf of the external debugger.
namespace dbgoseccr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgoseccr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgoseccr, val) }

	namespace edeccr
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgoseccr, 0xffffffff, 0) }
		inline uint32_t get(uint32_t dbgoseccr_val) noexcept { GET_BITFIELD_FUNC(dbgoseccr_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgoseccr, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t dbgoseccr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgoseccr, value, 0xffffffff, 0) }
	}
}

// DBGOSLAR (Debug OS Lock Access Register)
// Provides a lock for the debug registers. The OS lock also disables some debug exceptions and debug events.
namespace dbgoslar
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgoslar) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgoslar, val) }

	namespace os_lock_access
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgoslar, 0xffffffff, 0) }
		inline uint32_t get(uint32_t dbgoslar_val) noexcept { GET_BITFIELD_FUNC(dbgoslar_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgoslar, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t dbgoslar, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgoslar, value, 0xffffffff, 0) }
	}
}

// DBGOSLSR (Debug OS Lock Status Register)
// Provides status information for the OS lock.
namespace dbgoslsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgoslsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgoslsr, val) }

	namespace oslm_1_
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgoslsr, 3) }
		inline uint32_t is_enabled(uint32_t dbgoslsr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgoslsr_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgoslsr, 3) }
		inline uint32_t is_disabled(uint32_t dbgoslsr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgoslsr_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgoslsr, 0x8) }
		inline uint32_t enable(uint32_t dbgoslsr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgoslsr_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgoslsr, 0x8) }
		inline uint32_t disable(uint32_t dbgoslsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgoslsr_val, 0x8) }
	}

	namespace ntt
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgoslsr, 2) }
		inline uint32_t is_enabled(uint32_t dbgoslsr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgoslsr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgoslsr, 2) }
		inline uint32_t is_disabled(uint32_t dbgoslsr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgoslsr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgoslsr, 0x4) }
		inline uint32_t enable(uint32_t dbgoslsr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgoslsr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgoslsr, 0x4) }
		inline uint32_t disable(uint32_t dbgoslsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgoslsr_val, 0x4) }
	}

	namespace oslk
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgoslsr, 1) }
		inline uint32_t is_enabled(uint32_t dbgoslsr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgoslsr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgoslsr, 1) }
		inline uint32_t is_disabled(uint32_t dbgoslsr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgoslsr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgoslsr, 0x2) }
		inline uint32_t enable(uint32_t dbgoslsr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgoslsr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgoslsr, 0x2) }
		inline uint32_t disable(uint32_t dbgoslsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgoslsr_val, 0x2) }
	}

	namespace oslm_0_
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgoslsr, 0) }
		inline uint32_t is_enabled(uint32_t dbgoslsr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgoslsr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgoslsr, 0) }
		inline uint32_t is_disabled(uint32_t dbgoslsr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgoslsr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgoslsr, 0x1) }
		inline uint32_t enable(uint32_t dbgoslsr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgoslsr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgoslsr, 0x1) }
		inline uint32_t disable(uint32_t dbgoslsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgoslsr_val, 0x1) }
	}
}

// DBGPRCR (Debug Power Control Register)
// Controls behavior of the PE on powerdown request.
namespace dbgprcr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgprcr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgprcr, val) }

	namespace corenpdrq
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgprcr, 0) }
		inline uint32_t is_enabled(uint32_t dbgprcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgprcr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgprcr, 0) }
		inline uint32_t is_disabled(uint32_t dbgprcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgprcr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgprcr, 0x1) }
		inline uint32_t enable(uint32_t dbgprcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgprcr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgprcr, 0x1) }
		inline uint32_t disable(uint32_t dbgprcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgprcr_val, 0x1) }
	}
}

// DBGVCR (Debug Vector Catch Register)
// Controls Vector Catch debug events.
namespace dbgvcr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgvcr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgvcr, val) }

	// Fieldset valid when: EL3 implemented and using AArch32
	namespace fieldset_1
	{
		namespace nsf
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 31) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 31) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 31) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 31) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x80000000) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x80000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x80000000) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x80000000) }
		}

		namespace nsi
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 30) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 30) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 30) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 30) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x40000000) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x40000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x40000000) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x40000000) }
		}

		namespace nsd
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 28) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 28) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 28) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 28) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x10000000) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x10000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x10000000) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x10000000) }
		}

		namespace nsp
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 27) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 27) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 27) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 27) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x8000000) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x8000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x8000000) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x8000000) }
		}

		namespace nss
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 26) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 26) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 26) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 26) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x4000000) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x4000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x4000000) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x4000000) }
		}

		namespace nsu
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 25) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 25) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 25) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 25) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x2000000) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x2000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x2000000) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x2000000) }
		}

		namespace mf
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 15) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 15) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 15) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 15) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x8000) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x8000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x8000) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x8000) }
		}

		namespace mi
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 14) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 14) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 14) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 14) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x4000) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x4000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x4000) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x4000) }
		}

		namespace md
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 12) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 12) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 12) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 12) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x1000) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x1000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x1000) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x1000) }
		}

		namespace mp
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 11) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 11) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 11) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 11) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x800) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x800) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x800) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x800) }
		}

		namespace ms
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 10) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 10) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 10) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 10) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x400) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x400) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x400) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x400) }
		}

		namespace sf
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 7) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 7) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 7) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 7) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x80) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x80) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x80) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x80) }
		}

		namespace si
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 6) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 6) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 6) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 6) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x40) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x40) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x40) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x40) }
		}

		namespace sd
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 4) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 4) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 4) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 4) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x10) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x10) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x10) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x10) }
		}

		namespace sp
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 3) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 3) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 3) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 3) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x8) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x8) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x8) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x8) }
		}

		namespace ss
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 2) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 2) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 2) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 2) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x4) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x4) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x4) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x4) }
		}

		namespace su
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 1) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 1) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 1) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 1) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x2) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x2) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x2) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x2) }
		}
	}

	// Fieldset valid when: EL3 implemented and using AArch64
	namespace fieldset_2
	{
		namespace nsf
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 31) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 31) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 31) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 31) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x80000000) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x80000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x80000000) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x80000000) }
		}

		namespace nsi
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 30) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 30) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 30) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 30) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x40000000) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x40000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x40000000) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x40000000) }
		}

		namespace nsd
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 28) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 28) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 28) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 28) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x10000000) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x10000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x10000000) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x10000000) }
		}

		namespace nsp
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 27) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 27) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 27) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 27) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x8000000) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x8000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x8000000) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x8000000) }
		}

		namespace nss
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 26) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 26) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 26) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 26) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x4000000) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x4000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x4000000) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x4000000) }
		}

		namespace nsu
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 25) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 25) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 25) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 25) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x2000000) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x2000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x2000000) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x2000000) }
		}

		namespace sf
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 7) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 7) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 7) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 7) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x80) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x80) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x80) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x80) }
		}

		namespace si
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 6) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 6) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 6) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 6) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x40) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x40) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x40) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x40) }
		}

		namespace sd
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 4) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 4) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 4) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 4) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x10) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x10) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x10) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x10) }
		}

		namespace sp
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 3) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 3) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 3) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 3) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x8) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x8) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x8) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x8) }
		}

		namespace ss
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 2) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 2) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 2) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 2) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x4) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x4) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x4) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x4) }
		}

		namespace su
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 1) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 1) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 1) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 1) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x2) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x2) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x2) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x2) }
		}
	}

	// Fieldset valid when: EL3 not implemented
	namespace fieldset_3
	{
		namespace f
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 7) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 7) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 7) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 7) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x80) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x80) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x80) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x80) }
		}

		namespace i
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 6) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 6) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 6) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 6) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x40) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x40) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x40) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x40) }
		}

		namespace d
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 4) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 4) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 4) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 4) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x10) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x10) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x10) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x10) }
		}

		namespace p
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 3) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 3) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 3) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 3) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x8) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x8) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x8) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x8) }
		}

		namespace s
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 2) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 2) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 2) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 2) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x4) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x4) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x4) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x4) }
		}

		namespace u
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr, 1) }
			inline uint32_t is_enabled(uint32_t dbgvcr_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr_val, 1) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr, 1) }
			inline uint32_t is_disabled(uint32_t dbgvcr_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr_val, 1) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x2) }
			inline uint32_t enable(uint32_t dbgvcr_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr_val, 0x2) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr, 0x2) }
			inline uint32_t disable(uint32_t dbgvcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr_val, 0x2) }
		}
	}
}

// DBGWCR<n> (Debug Watchpoint Control Registers)
// Holds control information for a watchpoint. Forms watchpoint n together with value register DBGWVR<n>.
namespace dbgwcr<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgwcr<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgwcr<n>, val) }

	namespace mask
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgwcr<n>, 0x1f000000, 24) }
		inline uint32_t get(uint32_t dbgwcr<n>_val) noexcept { GET_BITFIELD_FUNC(dbgwcr<n>_val, 0x1f000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgwcr<n>, value, 0x1f000000, 24) }
		inline uint32_t set(uint32_t dbgwcr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgwcr<n>, value, 0x1f000000, 24) }
	}

	namespace wt
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgwcr<n>, 20) }
		inline uint32_t is_enabled(uint32_t dbgwcr<n>_val) noexcept { IS_BIT_ENABLED_FUNC(dbgwcr<n>_val, 20) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgwcr<n>, 20) }
		inline uint32_t is_disabled(uint32_t dbgwcr<n>_val) noexcept { IS_BIT_DISABLED_FUNC(dbgwcr<n>_val, 20) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgwcr<n>, 0x100000) }
		inline uint32_t enable(uint32_t dbgwcr<n>_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgwcr<n>_val, 0x100000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgwcr<n>, 0x100000) }
		inline uint32_t disable(uint32_t dbgwcr<n>_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgwcr<n>_val, 0x100000) }
	}

	namespace lbn
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgwcr<n>, 0xf0000, 16) }
		inline uint32_t get(uint32_t dbgwcr<n>_val) noexcept { GET_BITFIELD_FUNC(dbgwcr<n>_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgwcr<n>, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t dbgwcr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgwcr<n>, value, 0xf0000, 16) }
	}

	namespace ssc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgwcr<n>, 0xc000, 14) }
		inline uint32_t get(uint32_t dbgwcr<n>_val) noexcept { GET_BITFIELD_FUNC(dbgwcr<n>_val, 0xc000, 14) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgwcr<n>, value, 0xc000, 14) }
		inline uint32_t set(uint32_t dbgwcr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgwcr<n>, value, 0xc000, 14) }
	}

	namespace hmc
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgwcr<n>, 13) }
		inline uint32_t is_enabled(uint32_t dbgwcr<n>_val) noexcept { IS_BIT_ENABLED_FUNC(dbgwcr<n>_val, 13) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgwcr<n>, 13) }
		inline uint32_t is_disabled(uint32_t dbgwcr<n>_val) noexcept { IS_BIT_DISABLED_FUNC(dbgwcr<n>_val, 13) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgwcr<n>, 0x2000) }
		inline uint32_t enable(uint32_t dbgwcr<n>_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgwcr<n>_val, 0x2000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgwcr<n>, 0x2000) }
		inline uint32_t disable(uint32_t dbgwcr<n>_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgwcr<n>_val, 0x2000) }
	}

	namespace bas
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgwcr<n>, 0x1fe0, 5) }
		inline uint32_t get(uint32_t dbgwcr<n>_val) noexcept { GET_BITFIELD_FUNC(dbgwcr<n>_val, 0x1fe0, 5) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgwcr<n>, value, 0x1fe0, 5) }
		inline uint32_t set(uint32_t dbgwcr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgwcr<n>, value, 0x1fe0, 5) }
	}

	namespace lsc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgwcr<n>, 0x18, 3) }
		inline uint32_t get(uint32_t dbgwcr<n>_val) noexcept { GET_BITFIELD_FUNC(dbgwcr<n>_val, 0x18, 3) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgwcr<n>, value, 0x18, 3) }
		inline uint32_t set(uint32_t dbgwcr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgwcr<n>, value, 0x18, 3) }
	}

	namespace pac
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgwcr<n>, 0x6, 1) }
		inline uint32_t get(uint32_t dbgwcr<n>_val) noexcept { GET_BITFIELD_FUNC(dbgwcr<n>_val, 0x6, 1) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgwcr<n>, value, 0x6, 1) }
		inline uint32_t set(uint32_t dbgwcr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgwcr<n>, value, 0x6, 1) }
	}

	namespace e
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgwcr<n>, 0) }
		inline uint32_t is_enabled(uint32_t dbgwcr<n>_val) noexcept { IS_BIT_ENABLED_FUNC(dbgwcr<n>_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgwcr<n>, 0) }
		inline uint32_t is_disabled(uint32_t dbgwcr<n>_val) noexcept { IS_BIT_DISABLED_FUNC(dbgwcr<n>_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgwcr<n>, 0x1) }
		inline uint32_t enable(uint32_t dbgwcr<n>_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgwcr<n>_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgwcr<n>, 0x1) }
		inline uint32_t disable(uint32_t dbgwcr<n>_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgwcr<n>_val, 0x1) }
	}
}

// DBGWFAR (Debug Watchpoint Fault Address Register)
// Previously returned information about the address of the instruction that accessed a watchpointed address. Is now deprecated and RES0.
namespace dbgwfar
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgwfar) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgwfar, val) }
}

// DBGWVR<n> (Debug Watchpoint Value Registers)
// Holds a data address value for use in watchpoint matching. Forms watchpoint n together with control register DBGWCR<n>.
namespace dbgwvr<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgwvr<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgwvr<n>, val) }

	namespace va
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgwvr<n>, 0xfffffffc, 2) }
		inline uint32_t get(uint32_t dbgwvr<n>_val) noexcept { GET_BITFIELD_FUNC(dbgwvr<n>_val, 0xfffffffc, 2) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgwvr<n>, value, 0xfffffffc, 2) }
		inline uint32_t set(uint32_t dbgwvr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgwvr<n>, value, 0xfffffffc, 2) }
	}
}

// DCCIMVAC (Data Cache line Clean and Invalidate by VA to PoC)
// Clean and Invalidate data or unified cache line by virtual address to PoC.
namespace dccimvac
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dccimvac) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dccimvac, val) }

	namespace virtual_address_to_use
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dccimvac, 0xffffffff, 0) }
		inline uint32_t get(uint32_t dccimvac_val) noexcept { GET_BITFIELD_FUNC(dccimvac_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dccimvac, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t dccimvac, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dccimvac, value, 0xffffffff, 0) }
	}
}

// DCCISW (Data Cache line Clean and Invalidate by Set/Way)
// Clean and Invalidate data or unified cache line by set/way.
namespace dccisw
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dccisw) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dccisw, val) }

	namespace setway
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dccisw, 0xfffffff0, 4) }
		inline uint32_t get(uint32_t dccisw_val) noexcept { GET_BITFIELD_FUNC(dccisw_val, 0xfffffff0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dccisw, value, 0xfffffff0, 4) }
		inline uint32_t set(uint32_t dccisw, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dccisw, value, 0xfffffff0, 4) }
	}

	namespace level
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dccisw, 0xe, 1) }
		inline uint32_t get(uint32_t dccisw_val) noexcept { GET_BITFIELD_FUNC(dccisw_val, 0xe, 1) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dccisw, value, 0xe, 1) }
		inline uint32_t set(uint32_t dccisw, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dccisw, value, 0xe, 1) }
	}
}

// DCCMVAC (Data Cache line Clean by VA to PoC)
// Clean data or unified cache line by virtual address to PoC.
namespace dccmvac
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dccmvac) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dccmvac, val) }

	namespace virtual_address_to_use
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dccmvac, 0xffffffff, 0) }
		inline uint32_t get(uint32_t dccmvac_val) noexcept { GET_BITFIELD_FUNC(dccmvac_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dccmvac, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t dccmvac, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dccmvac, value, 0xffffffff, 0) }
	}
}

// DCCMVAU (Data Cache line Clean by VA to PoU)
// Clean data or unified cache line by virtual address to PoU.
namespace dccmvau
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dccmvau) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dccmvau, val) }

	namespace virtual_address_to_use
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dccmvau, 0xffffffff, 0) }
		inline uint32_t get(uint32_t dccmvau_val) noexcept { GET_BITFIELD_FUNC(dccmvau_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dccmvau, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t dccmvau, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dccmvau, value, 0xffffffff, 0) }
	}
}

// DCCSW (Data Cache line Clean by Set/Way)
// Clean data or unified cache line by set/way.
namespace dccsw
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dccsw) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dccsw, val) }

	namespace setway
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dccsw, 0xfffffff0, 4) }
		inline uint32_t get(uint32_t dccsw_val) noexcept { GET_BITFIELD_FUNC(dccsw_val, 0xfffffff0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dccsw, value, 0xfffffff0, 4) }
		inline uint32_t set(uint32_t dccsw, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dccsw, value, 0xfffffff0, 4) }
	}

	namespace level
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dccsw, 0xe, 1) }
		inline uint32_t get(uint32_t dccsw_val) noexcept { GET_BITFIELD_FUNC(dccsw_val, 0xe, 1) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dccsw, value, 0xe, 1) }
		inline uint32_t set(uint32_t dccsw, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dccsw, value, 0xe, 1) }
	}
}

// DCIMVAC (Data Cache line Invalidate by VA to PoC)
// Invalidate data or unified cache line by virtual address to PoC.
namespace dcimvac
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dcimvac) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dcimvac, val) }

	namespace virtual_address_to_use
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dcimvac, 0xffffffff, 0) }
		inline uint32_t get(uint32_t dcimvac_val) noexcept { GET_BITFIELD_FUNC(dcimvac_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dcimvac, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t dcimvac, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dcimvac, value, 0xffffffff, 0) }
	}
}

// DCISW (Data Cache line Invalidate by Set/Way)
// Invalidate data or unified cache line by set/way.
namespace dcisw
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dcisw) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dcisw, val) }

	namespace setway
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dcisw, 0xfffffff0, 4) }
		inline uint32_t get(uint32_t dcisw_val) noexcept { GET_BITFIELD_FUNC(dcisw_val, 0xfffffff0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dcisw, value, 0xfffffff0, 4) }
		inline uint32_t set(uint32_t dcisw, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dcisw, value, 0xfffffff0, 4) }
	}

	namespace level
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dcisw, 0xe, 1) }
		inline uint32_t get(uint32_t dcisw_val) noexcept { GET_BITFIELD_FUNC(dcisw_val, 0xe, 1) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dcisw, value, 0xe, 1) }
		inline uint32_t set(uint32_t dcisw, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dcisw, value, 0xe, 1) }
	}
}

// DFAR (Data Fault Address Register)
// Holds the virtual address of the faulting address that caused a synchronous Data Abort exception.
namespace dfar
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dfar) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dfar, val) }

	namespace va_of_faulting_address_of_synchronous_data_abort_exception
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dfar, 0xffffffff, 0) }
		inline uint32_t get(uint32_t dfar_val) noexcept { GET_BITFIELD_FUNC(dfar_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dfar, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t dfar, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dfar, value, 0xffffffff, 0) }
	}
}

// DFSR (Data Fault Status Register)
// Holds status information about the last data fault.
namespace dfsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dfsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dfsr, val) }

	// Fieldset valid when: TTBCR.EAE==0
	namespace fieldset_1
	{
		namespace fnv
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dfsr, 16) }
			inline uint32_t is_enabled(uint32_t dfsr_val) noexcept { IS_BIT_ENABLED_FUNC(dfsr_val, 16) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dfsr, 16) }
			inline uint32_t is_disabled(uint32_t dfsr_val) noexcept { IS_BIT_DISABLED_FUNC(dfsr_val, 16) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dfsr, 0x10000) }
			inline uint32_t enable(uint32_t dfsr_val) noexcept { SET_BITS_BY_MASK_FUNC(dfsr_val, 0x10000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dfsr, 0x10000) }
			inline uint32_t disable(uint32_t dfsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dfsr_val, 0x10000) }
		}

		namespace aet
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dfsr, 0xc000, 14) }
			inline uint32_t get(uint32_t dfsr_val) noexcept { GET_BITFIELD_FUNC(dfsr_val, 0xc000, 14) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dfsr, value, 0xc000, 14) }
			inline uint32_t set(uint32_t dfsr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dfsr, value, 0xc000, 14) }
		}

		namespace cm
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dfsr, 13) }
			inline uint32_t is_enabled(uint32_t dfsr_val) noexcept { IS_BIT_ENABLED_FUNC(dfsr_val, 13) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dfsr, 13) }
			inline uint32_t is_disabled(uint32_t dfsr_val) noexcept { IS_BIT_DISABLED_FUNC(dfsr_val, 13) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dfsr, 0x2000) }
			inline uint32_t enable(uint32_t dfsr_val) noexcept { SET_BITS_BY_MASK_FUNC(dfsr_val, 0x2000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dfsr, 0x2000) }
			inline uint32_t disable(uint32_t dfsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dfsr_val, 0x2000) }
		}

		namespace ext
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dfsr, 12) }
			inline uint32_t is_enabled(uint32_t dfsr_val) noexcept { IS_BIT_ENABLED_FUNC(dfsr_val, 12) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dfsr, 12) }
			inline uint32_t is_disabled(uint32_t dfsr_val) noexcept { IS_BIT_DISABLED_FUNC(dfsr_val, 12) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dfsr, 0x1000) }
			inline uint32_t enable(uint32_t dfsr_val) noexcept { SET_BITS_BY_MASK_FUNC(dfsr_val, 0x1000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dfsr, 0x1000) }
			inline uint32_t disable(uint32_t dfsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dfsr_val, 0x1000) }
		}

		namespace wnr
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dfsr, 11) }
			inline uint32_t is_enabled(uint32_t dfsr_val) noexcept { IS_BIT_ENABLED_FUNC(dfsr_val, 11) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dfsr, 11) }
			inline uint32_t is_disabled(uint32_t dfsr_val) noexcept { IS_BIT_DISABLED_FUNC(dfsr_val, 11) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dfsr, 0x800) }
			inline uint32_t enable(uint32_t dfsr_val) noexcept { SET_BITS_BY_MASK_FUNC(dfsr_val, 0x800) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dfsr, 0x800) }
			inline uint32_t disable(uint32_t dfsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dfsr_val, 0x800) }
		}

		namespace fs_4_
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dfsr, 10) }
			inline uint32_t is_enabled(uint32_t dfsr_val) noexcept { IS_BIT_ENABLED_FUNC(dfsr_val, 10) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dfsr, 10) }
			inline uint32_t is_disabled(uint32_t dfsr_val) noexcept { IS_BIT_DISABLED_FUNC(dfsr_val, 10) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dfsr, 0x400) }
			inline uint32_t enable(uint32_t dfsr_val) noexcept { SET_BITS_BY_MASK_FUNC(dfsr_val, 0x400) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dfsr, 0x400) }
			inline uint32_t disable(uint32_t dfsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dfsr_val, 0x400) }
		}

		namespace lpae
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dfsr, 9) }
			inline uint32_t is_enabled(uint32_t dfsr_val) noexcept { IS_BIT_ENABLED_FUNC(dfsr_val, 9) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dfsr, 9) }
			inline uint32_t is_disabled(uint32_t dfsr_val) noexcept { IS_BIT_DISABLED_FUNC(dfsr_val, 9) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dfsr, 0x200) }
			inline uint32_t enable(uint32_t dfsr_val) noexcept { SET_BITS_BY_MASK_FUNC(dfsr_val, 0x200) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dfsr, 0x200) }
			inline uint32_t disable(uint32_t dfsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dfsr_val, 0x200) }
		}

		namespace domain
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dfsr, 0xf0, 4) }
			inline uint32_t get(uint32_t dfsr_val) noexcept { GET_BITFIELD_FUNC(dfsr_val, 0xf0, 4) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dfsr, value, 0xf0, 4) }
			inline uint32_t set(uint32_t dfsr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dfsr, value, 0xf0, 4) }
		}

		namespace fs_3:0_
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dfsr, 0xf, 0) }
			inline uint32_t get(uint32_t dfsr_val) noexcept { GET_BITFIELD_FUNC(dfsr_val, 0xf, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dfsr, value, 0xf, 0) }
			inline uint32_t set(uint32_t dfsr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dfsr, value, 0xf, 0) }
		}
	}

	// Fieldset valid when: TTBCR.EAE==1
	namespace fieldset_2
	{
		namespace fnv
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dfsr, 16) }
			inline uint32_t is_enabled(uint32_t dfsr_val) noexcept { IS_BIT_ENABLED_FUNC(dfsr_val, 16) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dfsr, 16) }
			inline uint32_t is_disabled(uint32_t dfsr_val) noexcept { IS_BIT_DISABLED_FUNC(dfsr_val, 16) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dfsr, 0x10000) }
			inline uint32_t enable(uint32_t dfsr_val) noexcept { SET_BITS_BY_MASK_FUNC(dfsr_val, 0x10000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dfsr, 0x10000) }
			inline uint32_t disable(uint32_t dfsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dfsr_val, 0x10000) }
		}

		namespace aet
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dfsr, 0xc000, 14) }
			inline uint32_t get(uint32_t dfsr_val) noexcept { GET_BITFIELD_FUNC(dfsr_val, 0xc000, 14) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dfsr, value, 0xc000, 14) }
			inline uint32_t set(uint32_t dfsr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dfsr, value, 0xc000, 14) }
		}

		namespace cm
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dfsr, 13) }
			inline uint32_t is_enabled(uint32_t dfsr_val) noexcept { IS_BIT_ENABLED_FUNC(dfsr_val, 13) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dfsr, 13) }
			inline uint32_t is_disabled(uint32_t dfsr_val) noexcept { IS_BIT_DISABLED_FUNC(dfsr_val, 13) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dfsr, 0x2000) }
			inline uint32_t enable(uint32_t dfsr_val) noexcept { SET_BITS_BY_MASK_FUNC(dfsr_val, 0x2000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dfsr, 0x2000) }
			inline uint32_t disable(uint32_t dfsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dfsr_val, 0x2000) }
		}

		namespace ext
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dfsr, 12) }
			inline uint32_t is_enabled(uint32_t dfsr_val) noexcept { IS_BIT_ENABLED_FUNC(dfsr_val, 12) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dfsr, 12) }
			inline uint32_t is_disabled(uint32_t dfsr_val) noexcept { IS_BIT_DISABLED_FUNC(dfsr_val, 12) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dfsr, 0x1000) }
			inline uint32_t enable(uint32_t dfsr_val) noexcept { SET_BITS_BY_MASK_FUNC(dfsr_val, 0x1000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dfsr, 0x1000) }
			inline uint32_t disable(uint32_t dfsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dfsr_val, 0x1000) }
		}

		namespace wnr
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dfsr, 11) }
			inline uint32_t is_enabled(uint32_t dfsr_val) noexcept { IS_BIT_ENABLED_FUNC(dfsr_val, 11) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dfsr, 11) }
			inline uint32_t is_disabled(uint32_t dfsr_val) noexcept { IS_BIT_DISABLED_FUNC(dfsr_val, 11) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dfsr, 0x800) }
			inline uint32_t enable(uint32_t dfsr_val) noexcept { SET_BITS_BY_MASK_FUNC(dfsr_val, 0x800) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dfsr, 0x800) }
			inline uint32_t disable(uint32_t dfsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dfsr_val, 0x800) }
		}

		namespace lpae
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dfsr, 9) }
			inline uint32_t is_enabled(uint32_t dfsr_val) noexcept { IS_BIT_ENABLED_FUNC(dfsr_val, 9) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dfsr, 9) }
			inline uint32_t is_disabled(uint32_t dfsr_val) noexcept { IS_BIT_DISABLED_FUNC(dfsr_val, 9) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dfsr, 0x200) }
			inline uint32_t enable(uint32_t dfsr_val) noexcept { SET_BITS_BY_MASK_FUNC(dfsr_val, 0x200) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dfsr, 0x200) }
			inline uint32_t disable(uint32_t dfsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dfsr_val, 0x200) }
		}

		namespace status
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dfsr, 0x3f, 0) }
			inline uint32_t get(uint32_t dfsr_val) noexcept { GET_BITFIELD_FUNC(dfsr_val, 0x3f, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dfsr, value, 0x3f, 0) }
			inline uint32_t set(uint32_t dfsr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dfsr, value, 0x3f, 0) }
		}
	}
}

// DLR (Debug Link Register)
// In Debug state, holds the address to restart from.
namespace dlr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dlr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dlr, val) }

	namespace restart_address
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dlr, 0xffffffff, 0) }
		inline uint32_t get(uint32_t dlr_val) noexcept { GET_BITFIELD_FUNC(dlr_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dlr, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t dlr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dlr, value, 0xffffffff, 0) }
	}
}

// DSPSR (Debug Saved Program Status Register)
// Holds the saved process state on entry to Debug state.
namespace dspsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dspsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dspsr, val) }
}

// DTLBIALL (Data TLB Invalidate All)
// See the ARMv8 architecture reference manual for a description of this register
namespace dtlbiall
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dtlbiall) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dtlbiall, val) }
}

// DTLBIASID (Data TLB Invalidate by ASID match)
// See the ARMv8 architecture reference manual for a description of this register
namespace dtlbiasid
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dtlbiasid) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dtlbiasid, val) }

	namespace asid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dtlbiasid, 0xff, 0) }
		inline uint32_t get(uint32_t dtlbiasid_val) noexcept { GET_BITFIELD_FUNC(dtlbiasid_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dtlbiasid, value, 0xff, 0) }
		inline uint32_t set(uint32_t dtlbiasid, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dtlbiasid, value, 0xff, 0) }
	}
}

// DTLBIMVA (Data TLB Invalidate by VA)
// See the ARMv8 architecture reference manual for a description of this register
namespace dtlbimva
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dtlbimva) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dtlbimva, val) }

	namespace va
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dtlbimva, 0xfffff000, 12) }
		inline uint32_t get(uint32_t dtlbimva_val) noexcept { GET_BITFIELD_FUNC(dtlbimva_val, 0xfffff000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dtlbimva, value, 0xfffff000, 12) }
		inline uint32_t set(uint32_t dtlbimva, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dtlbimva, value, 0xfffff000, 12) }
	}

	namespace asid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dtlbimva, 0xff, 0) }
		inline uint32_t get(uint32_t dtlbimva_val) noexcept { GET_BITFIELD_FUNC(dtlbimva_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dtlbimva, value, 0xff, 0) }
		inline uint32_t set(uint32_t dtlbimva, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dtlbimva, value, 0xff, 0) }
	}
}

// ELR_hyp (Exception Link Register (Hyp mode))
// When taking an exception to Hyp mode, holds the address to return to.
namespace elr_hyp
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(elr_hyp) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(elr_hyp, val) }

	namespace return_address
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(elr_hyp, 0xffffffff, 0) }
		inline uint32_t get(uint32_t elr_hyp_val) noexcept { GET_BITFIELD_FUNC(elr_hyp_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(elr_hyp, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t elr_hyp, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(elr_hyp, value, 0xffffffff, 0) }
	}
}

// FCSEIDR (FCSE Process ID register)
// See the ARMv8 architecture reference manual for a description of this register
namespace fcseidr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(fcseidr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(fcseidr, val) }
}

// FPEXC (Floating-Point Exception Control register)
// Provides a global enable for the implemented Advanced SIMD and floating-point functionality, and reports floating-point status information.
namespace fpexc
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(fpexc) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(fpexc, val) }

	namespace ex
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(fpexc, 31) }
		inline uint32_t is_enabled(uint32_t fpexc_val) noexcept { IS_BIT_ENABLED_FUNC(fpexc_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(fpexc, 31) }
		inline uint32_t is_disabled(uint32_t fpexc_val) noexcept { IS_BIT_DISABLED_FUNC(fpexc_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(fpexc, 0x80000000) }
		inline uint32_t enable(uint32_t fpexc_val) noexcept { SET_BITS_BY_MASK_FUNC(fpexc_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(fpexc, 0x80000000) }
		inline uint32_t disable(uint32_t fpexc_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(fpexc_val, 0x80000000) }
	}

	namespace en
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(fpexc, 30) }
		inline uint32_t is_enabled(uint32_t fpexc_val) noexcept { IS_BIT_ENABLED_FUNC(fpexc_val, 30) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(fpexc, 30) }
		inline uint32_t is_disabled(uint32_t fpexc_val) noexcept { IS_BIT_DISABLED_FUNC(fpexc_val, 30) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(fpexc, 0x40000000) }
		inline uint32_t enable(uint32_t fpexc_val) noexcept { SET_BITS_BY_MASK_FUNC(fpexc_val, 0x40000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(fpexc, 0x40000000) }
		inline uint32_t disable(uint32_t fpexc_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(fpexc_val, 0x40000000) }
	}

	namespace dex
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(fpexc, 29) }
		inline uint32_t is_enabled(uint32_t fpexc_val) noexcept { IS_BIT_ENABLED_FUNC(fpexc_val, 29) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(fpexc, 29) }
		inline uint32_t is_disabled(uint32_t fpexc_val) noexcept { IS_BIT_DISABLED_FUNC(fpexc_val, 29) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(fpexc, 0x20000000) }
		inline uint32_t enable(uint32_t fpexc_val) noexcept { SET_BITS_BY_MASK_FUNC(fpexc_val, 0x20000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(fpexc, 0x20000000) }
		inline uint32_t disable(uint32_t fpexc_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(fpexc_val, 0x20000000) }
	}

	namespace fp2v
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(fpexc, 28) }
		inline uint32_t is_enabled(uint32_t fpexc_val) noexcept { IS_BIT_ENABLED_FUNC(fpexc_val, 28) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(fpexc, 28) }
		inline uint32_t is_disabled(uint32_t fpexc_val) noexcept { IS_BIT_DISABLED_FUNC(fpexc_val, 28) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(fpexc, 0x10000000) }
		inline uint32_t enable(uint32_t fpexc_val) noexcept { SET_BITS_BY_MASK_FUNC(fpexc_val, 0x10000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(fpexc, 0x10000000) }
		inline uint32_t disable(uint32_t fpexc_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(fpexc_val, 0x10000000) }
	}

	namespace vv
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(fpexc, 27) }
		inline uint32_t is_enabled(uint32_t fpexc_val) noexcept { IS_BIT_ENABLED_FUNC(fpexc_val, 27) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(fpexc, 27) }
		inline uint32_t is_disabled(uint32_t fpexc_val) noexcept { IS_BIT_DISABLED_FUNC(fpexc_val, 27) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(fpexc, 0x8000000) }
		inline uint32_t enable(uint32_t fpexc_val) noexcept { SET_BITS_BY_MASK_FUNC(fpexc_val, 0x8000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(fpexc, 0x8000000) }
		inline uint32_t disable(uint32_t fpexc_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(fpexc_val, 0x8000000) }
	}

	namespace tfv
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(fpexc, 26) }
		inline uint32_t is_enabled(uint32_t fpexc_val) noexcept { IS_BIT_ENABLED_FUNC(fpexc_val, 26) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(fpexc, 26) }
		inline uint32_t is_disabled(uint32_t fpexc_val) noexcept { IS_BIT_DISABLED_FUNC(fpexc_val, 26) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(fpexc, 0x4000000) }
		inline uint32_t enable(uint32_t fpexc_val) noexcept { SET_BITS_BY_MASK_FUNC(fpexc_val, 0x4000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(fpexc, 0x4000000) }
		inline uint32_t disable(uint32_t fpexc_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(fpexc_val, 0x4000000) }
	}

	namespace vecitr
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(fpexc, 0x700, 8) }
		inline uint32_t get(uint32_t fpexc_val) noexcept { GET_BITFIELD_FUNC(fpexc_val, 0x700, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(fpexc, value, 0x700, 8) }
		inline uint32_t set(uint32_t fpexc, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(fpexc, value, 0x700, 8) }
	}

	namespace idf
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(fpexc, 7) }
		inline uint32_t is_enabled(uint32_t fpexc_val) noexcept { IS_BIT_ENABLED_FUNC(fpexc_val, 7) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(fpexc, 7) }
		inline uint32_t is_disabled(uint32_t fpexc_val) noexcept { IS_BIT_DISABLED_FUNC(fpexc_val, 7) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(fpexc, 0x80) }
		inline uint32_t enable(uint32_t fpexc_val) noexcept { SET_BITS_BY_MASK_FUNC(fpexc_val, 0x80) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(fpexc, 0x80) }
		inline uint32_t disable(uint32_t fpexc_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(fpexc_val, 0x80) }
	}

	namespace ixf
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(fpexc, 4) }
		inline uint32_t is_enabled(uint32_t fpexc_val) noexcept { IS_BIT_ENABLED_FUNC(fpexc_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(fpexc, 4) }
		inline uint32_t is_disabled(uint32_t fpexc_val) noexcept { IS_BIT_DISABLED_FUNC(fpexc_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(fpexc, 0x10) }
		inline uint32_t enable(uint32_t fpexc_val) noexcept { SET_BITS_BY_MASK_FUNC(fpexc_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(fpexc, 0x10) }
		inline uint32_t disable(uint32_t fpexc_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(fpexc_val, 0x10) }
	}

	namespace uff
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(fpexc, 3) }
		inline uint32_t is_enabled(uint32_t fpexc_val) noexcept { IS_BIT_ENABLED_FUNC(fpexc_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(fpexc, 3) }
		inline uint32_t is_disabled(uint32_t fpexc_val) noexcept { IS_BIT_DISABLED_FUNC(fpexc_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(fpexc, 0x8) }
		inline uint32_t enable(uint32_t fpexc_val) noexcept { SET_BITS_BY_MASK_FUNC(fpexc_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(fpexc, 0x8) }
		inline uint32_t disable(uint32_t fpexc_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(fpexc_val, 0x8) }
	}

	namespace off
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(fpexc, 2) }
		inline uint32_t is_enabled(uint32_t fpexc_val) noexcept { IS_BIT_ENABLED_FUNC(fpexc_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(fpexc, 2) }
		inline uint32_t is_disabled(uint32_t fpexc_val) noexcept { IS_BIT_DISABLED_FUNC(fpexc_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(fpexc, 0x4) }
		inline uint32_t enable(uint32_t fpexc_val) noexcept { SET_BITS_BY_MASK_FUNC(fpexc_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(fpexc, 0x4) }
		inline uint32_t disable(uint32_t fpexc_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(fpexc_val, 0x4) }
	}

	namespace dzf
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(fpexc, 1) }
		inline uint32_t is_enabled(uint32_t fpexc_val) noexcept { IS_BIT_ENABLED_FUNC(fpexc_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(fpexc, 1) }
		inline uint32_t is_disabled(uint32_t fpexc_val) noexcept { IS_BIT_DISABLED_FUNC(fpexc_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(fpexc, 0x2) }
		inline uint32_t enable(uint32_t fpexc_val) noexcept { SET_BITS_BY_MASK_FUNC(fpexc_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(fpexc, 0x2) }
		inline uint32_t disable(uint32_t fpexc_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(fpexc_val, 0x2) }
	}

	namespace iof
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(fpexc, 0) }
		inline uint32_t is_enabled(uint32_t fpexc_val) noexcept { IS_BIT_ENABLED_FUNC(fpexc_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(fpexc, 0) }
		inline uint32_t is_disabled(uint32_t fpexc_val) noexcept { IS_BIT_DISABLED_FUNC(fpexc_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(fpexc, 0x1) }
		inline uint32_t enable(uint32_t fpexc_val) noexcept { SET_BITS_BY_MASK_FUNC(fpexc_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(fpexc, 0x1) }
		inline uint32_t disable(uint32_t fpexc_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(fpexc_val, 0x1) }
	}
}

// FPSCR (Floating-Point Status and Control Register)
// Provides floating-point system status information and control.
namespace fpscr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(fpscr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(fpscr, val) }
}

// FPSID (Floating-Point System ID register)
// See the ARMv8 architecture reference manual for a description of this register
namespace fpsid
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(fpsid) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(fpsid, val) }

	namespace implementer
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(fpsid, 0xff000000, 24) }
		inline uint32_t get(uint32_t fpsid_val) noexcept { GET_BITFIELD_FUNC(fpsid_val, 0xff000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(fpsid, value, 0xff000000, 24) }
		inline uint32_t set(uint32_t fpsid, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(fpsid, value, 0xff000000, 24) }
	}

	namespace sw
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(fpsid, 23) }
		inline uint32_t is_enabled(uint32_t fpsid_val) noexcept { IS_BIT_ENABLED_FUNC(fpsid_val, 23) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(fpsid, 23) }
		inline uint32_t is_disabled(uint32_t fpsid_val) noexcept { IS_BIT_DISABLED_FUNC(fpsid_val, 23) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(fpsid, 0x800000) }
		inline uint32_t enable(uint32_t fpsid_val) noexcept { SET_BITS_BY_MASK_FUNC(fpsid_val, 0x800000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(fpsid, 0x800000) }
		inline uint32_t disable(uint32_t fpsid_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(fpsid_val, 0x800000) }
	}

	namespace subarchitecture
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(fpsid, 0x7f0000, 16) }
		inline uint32_t get(uint32_t fpsid_val) noexcept { GET_BITFIELD_FUNC(fpsid_val, 0x7f0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(fpsid, value, 0x7f0000, 16) }
		inline uint32_t set(uint32_t fpsid, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(fpsid, value, 0x7f0000, 16) }
	}

	namespace partnum
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(fpsid, 0xff00, 8) }
		inline uint32_t get(uint32_t fpsid_val) noexcept { GET_BITFIELD_FUNC(fpsid_val, 0xff00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(fpsid, value, 0xff00, 8) }
		inline uint32_t set(uint32_t fpsid, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(fpsid, value, 0xff00, 8) }
	}

	namespace variant
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(fpsid, 0xf0, 4) }
		inline uint32_t get(uint32_t fpsid_val) noexcept { GET_BITFIELD_FUNC(fpsid_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(fpsid, value, 0xf0, 4) }
		inline uint32_t set(uint32_t fpsid, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(fpsid, value, 0xf0, 4) }
	}

	namespace revision
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(fpsid, 0xf, 0) }
		inline uint32_t get(uint32_t fpsid_val) noexcept { GET_BITFIELD_FUNC(fpsid_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(fpsid, value, 0xf, 0) }
		inline uint32_t set(uint32_t fpsid, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(fpsid, value, 0xf, 0) }
	}
}

// HACR (Hyp Auxiliary Configuration Register)
// Controls trapping to Hyp mode of IMPLEMENTATION DEFINED aspects of Non-secure EL1 or EL0 operation.
namespace hacr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(hacr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(hacr, val) }
}

// HACTLR (Hyp Auxiliary Control Register)
// Controls IMPLEMENTATION DEFINED features of Hyp mode operation.
namespace hactlr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(hactlr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(hactlr, val) }
}

// HACTLR2 (Hyp Auxiliary Control Register 2)
// Provides additional space to the HACTLR register to hold IMPLEMENTATION DEFINED trap functionality.
namespace hactlr2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(hactlr2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(hactlr2, val) }
}

// HADFSR (Hyp Auxiliary Data Fault Status Register)
// Provides additional IMPLEMENTATION DEFINED syndrome information for Data Abort exceptions taken to Hyp mode.
namespace hadfsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(hadfsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(hadfsr, val) }
}

// HAIFSR (Hyp Auxiliary Instruction Fault Status Register)
// Provides additional IMPLEMENTATION DEFINED syndrome information for Prefetch Abort exceptions taken to Hyp mode.
namespace haifsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(haifsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(haifsr, val) }
}

// HAMAIR0 (Hyp Auxiliary Memory Attribute Indirection Register 0)
// Provides IMPLEMENTATION DEFINED memory attributes for the memory attribute encodings defined by HMAIR0. These IMPLEMENTATION DEFINED attributes can only provide additional qualifiers for the memory attribute encodings, and cannot change the memory attributes defined in HMAIR0.
namespace hamair0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(hamair0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(hamair0, val) }
}

// HAMAIR1 (Hyp Auxiliary Memory Attribute Indirection Register 1)
// Provides IMPLEMENTATION DEFINED memory attributes for the memory attribute encodings defined by HMAIR1. These IMPLEMENTATION DEFINED attributes can only provide additional qualifiers for the memory attribute encodings, and cannot change the memory attributes defined in HMAIR1.
namespace hamair1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(hamair1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(hamair1, val) }
}

// HCPTR (Hyp Architectural Feature Trap Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace hcptr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(hcptr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(hcptr, val) }

	namespace tcpac
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcptr, 31) }
		inline uint32_t is_enabled(uint32_t hcptr_val) noexcept { IS_BIT_ENABLED_FUNC(hcptr_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcptr, 31) }
		inline uint32_t is_disabled(uint32_t hcptr_val) noexcept { IS_BIT_DISABLED_FUNC(hcptr_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcptr, 0x80000000) }
		inline uint32_t enable(uint32_t hcptr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcptr_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcptr, 0x80000000) }
		inline uint32_t disable(uint32_t hcptr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcptr_val, 0x80000000) }
	}

	namespace tta
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcptr, 20) }
		inline uint32_t is_enabled(uint32_t hcptr_val) noexcept { IS_BIT_ENABLED_FUNC(hcptr_val, 20) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcptr, 20) }
		inline uint32_t is_disabled(uint32_t hcptr_val) noexcept { IS_BIT_DISABLED_FUNC(hcptr_val, 20) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcptr, 0x100000) }
		inline uint32_t enable(uint32_t hcptr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcptr_val, 0x100000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcptr, 0x100000) }
		inline uint32_t disable(uint32_t hcptr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcptr_val, 0x100000) }
	}

	namespace tase
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcptr, 15) }
		inline uint32_t is_enabled(uint32_t hcptr_val) noexcept { IS_BIT_ENABLED_FUNC(hcptr_val, 15) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcptr, 15) }
		inline uint32_t is_disabled(uint32_t hcptr_val) noexcept { IS_BIT_DISABLED_FUNC(hcptr_val, 15) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcptr, 0x8000) }
		inline uint32_t enable(uint32_t hcptr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcptr_val, 0x8000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcptr, 0x8000) }
		inline uint32_t disable(uint32_t hcptr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcptr_val, 0x8000) }
	}

	namespace tcp11
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcptr, 11) }
		inline uint32_t is_enabled(uint32_t hcptr_val) noexcept { IS_BIT_ENABLED_FUNC(hcptr_val, 11) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcptr, 11) }
		inline uint32_t is_disabled(uint32_t hcptr_val) noexcept { IS_BIT_DISABLED_FUNC(hcptr_val, 11) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcptr, 0x800) }
		inline uint32_t enable(uint32_t hcptr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcptr_val, 0x800) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcptr, 0x800) }
		inline uint32_t disable(uint32_t hcptr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcptr_val, 0x800) }
	}

	namespace tcp10
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcptr, 10) }
		inline uint32_t is_enabled(uint32_t hcptr_val) noexcept { IS_BIT_ENABLED_FUNC(hcptr_val, 10) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcptr, 10) }
		inline uint32_t is_disabled(uint32_t hcptr_val) noexcept { IS_BIT_DISABLED_FUNC(hcptr_val, 10) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcptr, 0x400) }
		inline uint32_t enable(uint32_t hcptr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcptr_val, 0x400) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcptr, 0x400) }
		inline uint32_t disable(uint32_t hcptr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcptr_val, 0x400) }
	}
}

// HCR (Hyp Configuration Register)
// Provides configuration controls for virtualization, including defining whether various Non-secure operations are trapped to Hyp mode.
namespace hcr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(hcr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(hcr, val) }

	namespace trvm
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 30) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 30) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 30) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 30) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x40000000) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x40000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x40000000) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x40000000) }
	}

	namespace hcd
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 29) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 29) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 29) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 29) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x20000000) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x20000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x20000000) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x20000000) }
	}

	namespace tge
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 27) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 27) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 27) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 27) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x8000000) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x8000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x8000000) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x8000000) }
	}

	namespace tvm
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 26) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 26) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 26) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 26) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x4000000) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x4000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x4000000) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x4000000) }
	}

	namespace ttlb
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 25) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 25) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 25) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 25) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x2000000) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x2000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x2000000) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x2000000) }
	}

	namespace tpu
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 24) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 24) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 24) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 24) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x1000000) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x1000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x1000000) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x1000000) }
	}

	namespace tpc
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 23) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 23) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 23) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 23) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x800000) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x800000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x800000) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x800000) }
	}

	namespace tsw
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 22) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 22) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 22) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 22) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x400000) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x400000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x400000) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x400000) }
	}

	namespace tac
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 21) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 21) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 21) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 21) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x200000) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x200000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x200000) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x200000) }
	}

	namespace tidcp
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 20) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 20) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 20) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 20) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x100000) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x100000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x100000) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x100000) }
	}

	namespace tsc
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 19) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 19) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 19) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 19) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x80000) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x80000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x80000) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x80000) }
	}

	namespace tid3
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 18) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 18) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 18) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 18) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x40000) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x40000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x40000) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x40000) }
	}

	namespace tid2
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 17) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 17) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 17) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 17) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x20000) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x20000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x20000) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x20000) }
	}

	namespace tid1
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 16) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 16) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 16) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 16) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x10000) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x10000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x10000) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x10000) }
	}

	namespace tid0
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 15) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 15) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 15) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 15) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x8000) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x8000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x8000) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x8000) }
	}

	namespace twe
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 14) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 14) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 14) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 14) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x4000) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x4000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x4000) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x4000) }
	}

	namespace twi
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 13) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 13) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 13) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 13) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x2000) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x2000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x2000) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x2000) }
	}

	namespace dc
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 12) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 12) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 12) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 12) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x1000) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x1000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x1000) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x1000) }
	}

	namespace bsu
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(hcr, 0xc00, 10) }
		inline uint32_t get(uint32_t hcr_val) noexcept { GET_BITFIELD_FUNC(hcr_val, 0xc00, 10) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(hcr, value, 0xc00, 10) }
		inline uint32_t set(uint32_t hcr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(hcr, value, 0xc00, 10) }
	}

	namespace fb
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 9) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 9) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 9) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 9) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x200) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x200) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x200) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x200) }
	}

	namespace va
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 8) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 8) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 8) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 8) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x100) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x100) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x100) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x100) }
	}

	namespace vi
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 7) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 7) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 7) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 7) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x80) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x80) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x80) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x80) }
	}

	namespace vf
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 6) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 6) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 6) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 6) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x40) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x40) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x40) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x40) }
	}

	namespace amo
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 5) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 5) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 5) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 5) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x20) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x20) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x20) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x20) }
	}

	namespace imo
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 4) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 4) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x10) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x10) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x10) }
	}

	namespace fmo
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 3) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 3) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x8) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x8) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x8) }
	}

	namespace ptw
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 2) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 2) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x4) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x4) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x4) }
	}

	namespace swio
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 1) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 1) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x2) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x2) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x2) }
	}

	namespace vm
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr, 0) }
		inline uint32_t is_enabled(uint32_t hcr_val) noexcept { IS_BIT_ENABLED_FUNC(hcr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr, 0) }
		inline uint32_t is_disabled(uint32_t hcr_val) noexcept { IS_BIT_DISABLED_FUNC(hcr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x1) }
		inline uint32_t enable(uint32_t hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr, 0x1) }
		inline uint32_t disable(uint32_t hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr_val, 0x1) }
	}
}

// HCR2 (Hyp Configuration Register 2)
// Provides additional configuration controls for virtualization.
namespace hcr2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(hcr2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(hcr2, val) }

	namespace miocnce
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr2, 6) }
		inline uint32_t is_enabled(uint32_t hcr2_val) noexcept { IS_BIT_ENABLED_FUNC(hcr2_val, 6) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr2, 6) }
		inline uint32_t is_disabled(uint32_t hcr2_val) noexcept { IS_BIT_DISABLED_FUNC(hcr2_val, 6) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr2, 0x40) }
		inline uint32_t enable(uint32_t hcr2_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr2_val, 0x40) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr2, 0x40) }
		inline uint32_t disable(uint32_t hcr2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr2_val, 0x40) }
	}

	namespace tea
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr2, 5) }
		inline uint32_t is_enabled(uint32_t hcr2_val) noexcept { IS_BIT_ENABLED_FUNC(hcr2_val, 5) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr2, 5) }
		inline uint32_t is_disabled(uint32_t hcr2_val) noexcept { IS_BIT_DISABLED_FUNC(hcr2_val, 5) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr2, 0x20) }
		inline uint32_t enable(uint32_t hcr2_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr2_val, 0x20) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr2, 0x20) }
		inline uint32_t disable(uint32_t hcr2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr2_val, 0x20) }
	}

	namespace terr
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr2, 4) }
		inline uint32_t is_enabled(uint32_t hcr2_val) noexcept { IS_BIT_ENABLED_FUNC(hcr2_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr2, 4) }
		inline uint32_t is_disabled(uint32_t hcr2_val) noexcept { IS_BIT_DISABLED_FUNC(hcr2_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr2, 0x10) }
		inline uint32_t enable(uint32_t hcr2_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr2_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr2, 0x10) }
		inline uint32_t disable(uint32_t hcr2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr2_val, 0x10) }
	}

	namespace id
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr2, 1) }
		inline uint32_t is_enabled(uint32_t hcr2_val) noexcept { IS_BIT_ENABLED_FUNC(hcr2_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr2, 1) }
		inline uint32_t is_disabled(uint32_t hcr2_val) noexcept { IS_BIT_DISABLED_FUNC(hcr2_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr2, 0x2) }
		inline uint32_t enable(uint32_t hcr2_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr2_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr2, 0x2) }
		inline uint32_t disable(uint32_t hcr2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr2_val, 0x2) }
	}

	namespace cd
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hcr2, 0) }
		inline uint32_t is_enabled(uint32_t hcr2_val) noexcept { IS_BIT_ENABLED_FUNC(hcr2_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hcr2, 0) }
		inline uint32_t is_disabled(uint32_t hcr2_val) noexcept { IS_BIT_DISABLED_FUNC(hcr2_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hcr2, 0x1) }
		inline uint32_t enable(uint32_t hcr2_val) noexcept { SET_BITS_BY_MASK_FUNC(hcr2_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hcr2, 0x1) }
		inline uint32_t disable(uint32_t hcr2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hcr2_val, 0x1) }
	}
}

// HDCR (Hyp Debug Control Register)
// Controls the trapping to Hyp mode of Non-secure accesses, at EL1 or lower, to functions provided by the debug and trace architectures and the Performance Monitors Extension.
namespace hdcr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(hdcr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(hdcr, val) }
}

// HDFAR (Hyp Data Fault Address Register)
// Holds the virtual address of the faulting address that caused a synchronous Data Abort exception that is taken to Hyp mode.
namespace hdfar
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(hdfar) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(hdfar, val) }

	namespace va_of_faulting_address_of_synchronous_data_abort_exception_taken_to_hyp_mode
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(hdfar, 0xffffffff, 0) }
		inline uint32_t get(uint32_t hdfar_val) noexcept { GET_BITFIELD_FUNC(hdfar_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(hdfar, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t hdfar, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(hdfar, value, 0xffffffff, 0) }
	}
}

// HIFAR (Hyp Instruction Fault Address Register)
// Holds the virtual address of the faulting address that caused a synchronous Prefetch Abort exception that is taken to Hyp mode.
namespace hifar
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(hifar) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(hifar, val) }

	namespace va_of_faulting_address_of_synchronous_prefetch_abort_exception_taken_to_hyp_mode
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(hifar, 0xffffffff, 0) }
		inline uint32_t get(uint32_t hifar_val) noexcept { GET_BITFIELD_FUNC(hifar_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(hifar, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t hifar, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(hifar, value, 0xffffffff, 0) }
	}
}

// HMAIR0 (Hyp Memory Attribute Indirection Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace hmair0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(hmair0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(hmair0, val) }

	namespace attr_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(hmair0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t hmair0_val) noexcept { GET_BITFIELD_FUNC(hmair0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(hmair0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t hmair0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(hmair0, value, 0xffffffff, 0) }
	}
}

// HMAIR1 (Hyp Memory Attribute Indirection Register 1)
// See the ARMv8 architecture reference manual for a description of this register
namespace hmair1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(hmair1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(hmair1, val) }

	namespace attr_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(hmair1, 0xffffffff, 0) }
		inline uint32_t get(uint32_t hmair1_val) noexcept { GET_BITFIELD_FUNC(hmair1_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(hmair1, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t hmair1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(hmair1, value, 0xffffffff, 0) }
	}
}

// HPFAR (Hyp IPA Fault Address Register)
// Holds the faulting IPA for some aborts on a stage 2 translation taken to Hyp mode.
namespace hpfar
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(hpfar) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(hpfar, val) }

	namespace fipa_39:12_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(hpfar, 0xfffffff0, 4) }
		inline uint32_t get(uint32_t hpfar_val) noexcept { GET_BITFIELD_FUNC(hpfar_val, 0xfffffff0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(hpfar, value, 0xfffffff0, 4) }
		inline uint32_t set(uint32_t hpfar, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(hpfar, value, 0xfffffff0, 4) }
	}
}

// HRMR (Hyp Reset Management Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace hrmr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(hrmr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(hrmr, val) }

	namespace rr
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hrmr, 1) }
		inline uint32_t is_enabled(uint32_t hrmr_val) noexcept { IS_BIT_ENABLED_FUNC(hrmr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hrmr, 1) }
		inline uint32_t is_disabled(uint32_t hrmr_val) noexcept { IS_BIT_DISABLED_FUNC(hrmr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hrmr, 0x2) }
		inline uint32_t enable(uint32_t hrmr_val) noexcept { SET_BITS_BY_MASK_FUNC(hrmr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hrmr, 0x2) }
		inline uint32_t disable(uint32_t hrmr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hrmr_val, 0x2) }
	}

	namespace aa64
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hrmr, 0) }
		inline uint32_t is_enabled(uint32_t hrmr_val) noexcept { IS_BIT_ENABLED_FUNC(hrmr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hrmr, 0) }
		inline uint32_t is_disabled(uint32_t hrmr_val) noexcept { IS_BIT_DISABLED_FUNC(hrmr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hrmr, 0x1) }
		inline uint32_t enable(uint32_t hrmr_val) noexcept { SET_BITS_BY_MASK_FUNC(hrmr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hrmr, 0x1) }
		inline uint32_t disable(uint32_t hrmr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hrmr_val, 0x1) }
	}
}

// HSCTLR (Hyp System Control Register)
// Provides top level control of the system operation in Hyp mode.
namespace hsctlr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(hsctlr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(hsctlr, val) }
}

// HSR (Hyp Syndrome Register)
// Holds syndrome information for an exception taken to Hyp mode.
namespace hsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(hsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(hsr, val) }

	namespace ec
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(hsr, 0xfc000000, 26) }
		inline uint32_t get(uint32_t hsr_val) noexcept { GET_BITFIELD_FUNC(hsr_val, 0xfc000000, 26) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(hsr, value, 0xfc000000, 26) }
		inline uint32_t set(uint32_t hsr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(hsr, value, 0xfc000000, 26) }
	}

	namespace il
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(hsr, 25) }
		inline uint32_t is_enabled(uint32_t hsr_val) noexcept { IS_BIT_ENABLED_FUNC(hsr_val, 25) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(hsr, 25) }
		inline uint32_t is_disabled(uint32_t hsr_val) noexcept { IS_BIT_DISABLED_FUNC(hsr_val, 25) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(hsr, 0x2000000) }
		inline uint32_t enable(uint32_t hsr_val) noexcept { SET_BITS_BY_MASK_FUNC(hsr_val, 0x2000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(hsr, 0x2000000) }
		inline uint32_t disable(uint32_t hsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(hsr_val, 0x2000000) }
	}

	namespace iss
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(hsr, 0x1ffffff, 0) }
		inline uint32_t get(uint32_t hsr_val) noexcept { GET_BITFIELD_FUNC(hsr_val, 0x1ffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(hsr, value, 0x1ffffff, 0) }
		inline uint32_t set(uint32_t hsr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(hsr, value, 0x1ffffff, 0) }
	}
}

// HSTR (Hyp System Trap Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace hstr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(hstr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(hstr, val) }

	namespace t_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(hstr, 0xffff, 0) }
		inline uint32_t get(uint32_t hstr_val) noexcept { GET_BITFIELD_FUNC(hstr_val, 0xffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(hstr, value, 0xffff, 0) }
		inline uint32_t set(uint32_t hstr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(hstr, value, 0xffff, 0) }
	}
}

// HTCR (Hyp Translation Control Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace htcr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(htcr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(htcr, val) }
}

// HTPIDR (Hyp Software Thread ID Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace htpidr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(htpidr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(htpidr, val) }

	namespace thread_id
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(htpidr, 0xffffffff, 0) }
		inline uint32_t get(uint32_t htpidr_val) noexcept { GET_BITFIELD_FUNC(htpidr_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(htpidr, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t htpidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(htpidr, value, 0xffffffff, 0) }
	}
}

// HTTBR (Hyp Translation Table Base Register)
// Holds the base address of the translation table for the initial lookup for stage 1 of an address translation in the EL2 translation regime, and other information for this translation regime.
namespace httbr
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(httbr) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(httbr, val) }
}

// HVBAR (Hyp Vector Base Address Register)
// Holds the vector base address for any exception that is taken to Hyp mode.
namespace hvbar
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(hvbar) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(hvbar, val) }

	namespace vector_base_address
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(hvbar, 0xffffffe0, 5) }
		inline uint32_t get(uint32_t hvbar_val) noexcept { GET_BITFIELD_FUNC(hvbar_val, 0xffffffe0, 5) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(hvbar, value, 0xffffffe0, 5) }
		inline uint32_t set(uint32_t hvbar, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(hvbar, value, 0xffffffe0, 5) }
	}
}

// ICC_AP0R<n> (Interrupt Controller Active Priorities Group 0 Registers)
// Provides information about Group 0 active priorities.
namespace icc_ap0r<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_ap0r<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_ap0r<n>, val) }
}

// ICC_AP1R<n> (Interrupt Controller Active Priorities Group 1 Registers)
// Provides information about Group 1 active priorities.
namespace icc_ap1r<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_ap1r<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_ap1r<n>, val) }
}

// ICC_ASGI1R (Interrupt Controller Alias Software Generated Interrupt Group 1 Register)
// Generates Group 1 SGIs for the Security state that is not the current Security state.
namespace icc_asgi1r
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(icc_asgi1r) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_asgi1r, val) }

	namespace aff3
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_asgi1r, 0xff000000000000, 48) }
		inline uint64_t get(uint64_t icc_asgi1r_val) noexcept { GET_BITFIELD_FUNC(icc_asgi1r_val, 0xff000000000000, 48) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_asgi1r, value, 0xff000000000000, 48) }
		inline uint64_t set(uint64_t icc_asgi1r, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_asgi1r, value, 0xff000000000000, 48) }
	}

	namespace rs
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_asgi1r, 0xf00000000000, 44) }
		inline uint64_t get(uint64_t icc_asgi1r_val) noexcept { GET_BITFIELD_FUNC(icc_asgi1r_val, 0xf00000000000, 44) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_asgi1r, value, 0xf00000000000, 44) }
		inline uint64_t set(uint64_t icc_asgi1r, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_asgi1r, value, 0xf00000000000, 44) }
	}

	namespace irm
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_asgi1r, 40) }
		inline uint64_t is_enabled(uint64_t icc_asgi1r_val) noexcept { IS_BIT_ENABLED_FUNC(icc_asgi1r_val, 40) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_asgi1r, 40) }
		inline uint64_t is_disabled(uint64_t icc_asgi1r_val) noexcept { IS_BIT_DISABLED_FUNC(icc_asgi1r_val, 40) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_asgi1r, 0x10000000000) }
		inline uint64_t enable(uint64_t icc_asgi1r_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_asgi1r_val, 0x10000000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_asgi1r, 0x10000000000) }
		inline uint64_t disable(uint64_t icc_asgi1r_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_asgi1r_val, 0x10000000000) }
	}

	namespace aff2
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_asgi1r, 0xff00000000, 32) }
		inline uint64_t get(uint64_t icc_asgi1r_val) noexcept { GET_BITFIELD_FUNC(icc_asgi1r_val, 0xff00000000, 32) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_asgi1r, value, 0xff00000000, 32) }
		inline uint64_t set(uint64_t icc_asgi1r, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_asgi1r, value, 0xff00000000, 32) }
	}

	namespace intid
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_asgi1r, 0xf000000, 24) }
		inline uint64_t get(uint64_t icc_asgi1r_val) noexcept { GET_BITFIELD_FUNC(icc_asgi1r_val, 0xf000000, 24) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_asgi1r, value, 0xf000000, 24) }
		inline uint64_t set(uint64_t icc_asgi1r, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_asgi1r, value, 0xf000000, 24) }
	}

	namespace aff1
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_asgi1r, 0xff0000, 16) }
		inline uint64_t get(uint64_t icc_asgi1r_val) noexcept { GET_BITFIELD_FUNC(icc_asgi1r_val, 0xff0000, 16) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_asgi1r, value, 0xff0000, 16) }
		inline uint64_t set(uint64_t icc_asgi1r, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_asgi1r, value, 0xff0000, 16) }
	}

	namespace targetlist
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_asgi1r, 0xffff, 0) }
		inline uint64_t get(uint64_t icc_asgi1r_val) noexcept { GET_BITFIELD_FUNC(icc_asgi1r_val, 0xffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_asgi1r, value, 0xffff, 0) }
		inline uint64_t set(uint64_t icc_asgi1r, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_asgi1r, value, 0xffff, 0) }
	}
}

// ICC_BPR0 (Interrupt Controller Binary Point Register 0)
// Defines the point at which the priority value fields split into two parts, the group priority field and the subpriority field. The group priority field determines Group 0 interrupt preemption.
namespace icc_bpr0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_bpr0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_bpr0, val) }

	namespace binarypoint
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_bpr0, 0x7, 0) }
		inline uint32_t get(uint32_t icc_bpr0_val) noexcept { GET_BITFIELD_FUNC(icc_bpr0_val, 0x7, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_bpr0, value, 0x7, 0) }
		inline uint32_t set(uint32_t icc_bpr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_bpr0, value, 0x7, 0) }
	}
}

// ICC_BPR1 (Interrupt Controller Binary Point Register 1)
// Defines the point at which the priority value fields split into two parts, the group priority field and the subpriority field. The group priority field determines Group 1 interrupt preemption.
namespace icc_bpr1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_bpr1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_bpr1, val) }

	namespace binarypoint
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_bpr1, 0x7, 0) }
		inline uint32_t get(uint32_t icc_bpr1_val) noexcept { GET_BITFIELD_FUNC(icc_bpr1_val, 0x7, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_bpr1, value, 0x7, 0) }
		inline uint32_t set(uint32_t icc_bpr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_bpr1, value, 0x7, 0) }
	}
}

// ICC_CTLR (Interrupt Controller Control Register)
// Controls aspects of the behavior of the GIC CPU interface and provides information about the features implemented.
namespace icc_ctlr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_ctlr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_ctlr, val) }

	namespace rss
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_ctlr, 18) }
		inline uint32_t is_enabled(uint32_t icc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(icc_ctlr_val, 18) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_ctlr, 18) }
		inline uint32_t is_disabled(uint32_t icc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(icc_ctlr_val, 18) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr, 0x40000) }
		inline uint32_t enable(uint32_t icc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_ctlr_val, 0x40000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr, 0x40000) }
		inline uint32_t disable(uint32_t icc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_ctlr_val, 0x40000) }
	}

	namespace a3v
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_ctlr, 15) }
		inline uint32_t is_enabled(uint32_t icc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(icc_ctlr_val, 15) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_ctlr, 15) }
		inline uint32_t is_disabled(uint32_t icc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(icc_ctlr_val, 15) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr, 0x8000) }
		inline uint32_t enable(uint32_t icc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_ctlr_val, 0x8000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr, 0x8000) }
		inline uint32_t disable(uint32_t icc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_ctlr_val, 0x8000) }
	}

	namespace seis
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_ctlr, 14) }
		inline uint32_t is_enabled(uint32_t icc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(icc_ctlr_val, 14) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_ctlr, 14) }
		inline uint32_t is_disabled(uint32_t icc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(icc_ctlr_val, 14) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr, 0x4000) }
		inline uint32_t enable(uint32_t icc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_ctlr_val, 0x4000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr, 0x4000) }
		inline uint32_t disable(uint32_t icc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_ctlr_val, 0x4000) }
	}

	namespace idbits
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_ctlr, 0x3800, 11) }
		inline uint32_t get(uint32_t icc_ctlr_val) noexcept { GET_BITFIELD_FUNC(icc_ctlr_val, 0x3800, 11) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_ctlr, value, 0x3800, 11) }
		inline uint32_t set(uint32_t icc_ctlr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_ctlr, value, 0x3800, 11) }
	}

	namespace pribits
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_ctlr, 0x700, 8) }
		inline uint32_t get(uint32_t icc_ctlr_val) noexcept { GET_BITFIELD_FUNC(icc_ctlr_val, 0x700, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_ctlr, value, 0x700, 8) }
		inline uint32_t set(uint32_t icc_ctlr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_ctlr, value, 0x700, 8) }
	}

	namespace pmhe
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_ctlr, 6) }
		inline uint32_t is_enabled(uint32_t icc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(icc_ctlr_val, 6) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_ctlr, 6) }
		inline uint32_t is_disabled(uint32_t icc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(icc_ctlr_val, 6) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr, 0x40) }
		inline uint32_t enable(uint32_t icc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_ctlr_val, 0x40) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr, 0x40) }
		inline uint32_t disable(uint32_t icc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_ctlr_val, 0x40) }
	}

	namespace eoimode
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_ctlr, 1) }
		inline uint32_t is_enabled(uint32_t icc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(icc_ctlr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_ctlr, 1) }
		inline uint32_t is_disabled(uint32_t icc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(icc_ctlr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr, 0x2) }
		inline uint32_t enable(uint32_t icc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_ctlr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr, 0x2) }
		inline uint32_t disable(uint32_t icc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_ctlr_val, 0x2) }
	}

	namespace cbpr
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_ctlr, 0) }
		inline uint32_t is_enabled(uint32_t icc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(icc_ctlr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_ctlr, 0) }
		inline uint32_t is_disabled(uint32_t icc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(icc_ctlr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr, 0x1) }
		inline uint32_t enable(uint32_t icc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_ctlr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr, 0x1) }
		inline uint32_t disable(uint32_t icc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_ctlr_val, 0x1) }
	}
}

// ICC_DIR (Interrupt Controller Deactivate Interrupt Register)
// When interrupt priority drop is separated from interrupt deactivation, a write to this register deactivates the specified interrupt.
namespace icc_dir
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_dir) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_dir, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_dir, 0xffffff, 0) }
		inline uint32_t get(uint32_t icc_dir_val) noexcept { GET_BITFIELD_FUNC(icc_dir_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_dir, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icc_dir, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_dir, value, 0xffffff, 0) }
	}
}

// ICC_EOIR0 (Interrupt Controller End Of Interrupt Register 0)
// A PE writes to this register to inform the CPU interface that it has completed the processing of the specified Group 0 interrupt.
namespace icc_eoir0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_eoir0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_eoir0, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_eoir0, 0xffffff, 0) }
		inline uint32_t get(uint32_t icc_eoir0_val) noexcept { GET_BITFIELD_FUNC(icc_eoir0_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_eoir0, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icc_eoir0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_eoir0, value, 0xffffff, 0) }
	}
}

// ICC_EOIR1 (Interrupt Controller End Of Interrupt Register 1)
// A PE writes to this register to inform the CPU interface that it has completed the processing of the specified Group 1 interrupt.
namespace icc_eoir1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_eoir1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_eoir1, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_eoir1, 0xffffff, 0) }
		inline uint32_t get(uint32_t icc_eoir1_val) noexcept { GET_BITFIELD_FUNC(icc_eoir1_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_eoir1, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icc_eoir1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_eoir1, value, 0xffffff, 0) }
	}
}

// ICC_HPPIR0 (Interrupt Controller Highest Priority Pending Interrupt Register 0)
// Indicates the highest priority pending Group 0 interrupt on the CPU interface.
namespace icc_hppir0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_hppir0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_hppir0, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_hppir0, 0xffffff, 0) }
		inline uint32_t get(uint32_t icc_hppir0_val) noexcept { GET_BITFIELD_FUNC(icc_hppir0_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_hppir0, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icc_hppir0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_hppir0, value, 0xffffff, 0) }
	}
}

// ICC_HPPIR1 (Interrupt Controller Highest Priority Pending Interrupt Register 1)
// Indicates the highest priority pending Group 1 interrupt on the CPU interface.
namespace icc_hppir1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_hppir1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_hppir1, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_hppir1, 0xffffff, 0) }
		inline uint32_t get(uint32_t icc_hppir1_val) noexcept { GET_BITFIELD_FUNC(icc_hppir1_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_hppir1, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icc_hppir1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_hppir1, value, 0xffffff, 0) }
	}
}

// ICC_HSRE (Interrupt Controller Hyp System Register Enable register)
// Controls whether the System register interface or the memory-mapped interface to the GIC CPU interface is used for EL2.
namespace icc_hsre
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_hsre) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_hsre, val) }

	namespace enable
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_hsre, 3) }
		inline uint32_t is_enabled(uint32_t icc_hsre_val) noexcept { IS_BIT_ENABLED_FUNC(icc_hsre_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_hsre, 3) }
		inline uint32_t is_disabled(uint32_t icc_hsre_val) noexcept { IS_BIT_DISABLED_FUNC(icc_hsre_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_hsre, 0x8) }
		inline uint32_t enable(uint32_t icc_hsre_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_hsre_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_hsre, 0x8) }
		inline uint32_t disable(uint32_t icc_hsre_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_hsre_val, 0x8) }
	}

	namespace dib
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_hsre, 2) }
		inline uint32_t is_enabled(uint32_t icc_hsre_val) noexcept { IS_BIT_ENABLED_FUNC(icc_hsre_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_hsre, 2) }
		inline uint32_t is_disabled(uint32_t icc_hsre_val) noexcept { IS_BIT_DISABLED_FUNC(icc_hsre_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_hsre, 0x4) }
		inline uint32_t enable(uint32_t icc_hsre_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_hsre_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_hsre, 0x4) }
		inline uint32_t disable(uint32_t icc_hsre_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_hsre_val, 0x4) }
	}

	namespace dfb
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_hsre, 1) }
		inline uint32_t is_enabled(uint32_t icc_hsre_val) noexcept { IS_BIT_ENABLED_FUNC(icc_hsre_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_hsre, 1) }
		inline uint32_t is_disabled(uint32_t icc_hsre_val) noexcept { IS_BIT_DISABLED_FUNC(icc_hsre_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_hsre, 0x2) }
		inline uint32_t enable(uint32_t icc_hsre_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_hsre_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_hsre, 0x2) }
		inline uint32_t disable(uint32_t icc_hsre_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_hsre_val, 0x2) }
	}

	namespace sre
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_hsre, 0) }
		inline uint32_t is_enabled(uint32_t icc_hsre_val) noexcept { IS_BIT_ENABLED_FUNC(icc_hsre_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_hsre, 0) }
		inline uint32_t is_disabled(uint32_t icc_hsre_val) noexcept { IS_BIT_DISABLED_FUNC(icc_hsre_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_hsre, 0x1) }
		inline uint32_t enable(uint32_t icc_hsre_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_hsre_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_hsre, 0x1) }
		inline uint32_t disable(uint32_t icc_hsre_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_hsre_val, 0x1) }
	}
}

// ICC_IAR0 (Interrupt Controller Interrupt Acknowledge Register 0)
// The PE reads this register to obtain the INTID of the signaled Group 0 interrupt. This read acts as an acknowledge for the interrupt.
namespace icc_iar0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_iar0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_iar0, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_iar0, 0xffffff, 0) }
		inline uint32_t get(uint32_t icc_iar0_val) noexcept { GET_BITFIELD_FUNC(icc_iar0_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_iar0, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icc_iar0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_iar0, value, 0xffffff, 0) }
	}
}

// ICC_IAR1 (Interrupt Controller Interrupt Acknowledge Register 1)
// The PE reads this register to obtain the INTID of the signaled Group 1 interrupt. This read acts as an acknowledge for the interrupt.
namespace icc_iar1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_iar1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_iar1, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_iar1, 0xffffff, 0) }
		inline uint32_t get(uint32_t icc_iar1_val) noexcept { GET_BITFIELD_FUNC(icc_iar1_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_iar1, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icc_iar1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_iar1, value, 0xffffff, 0) }
	}
}

// ICC_IGRPEN0 (Interrupt Controller Interrupt Group 0 Enable register)
// Controls whether Group 0 interrupts are enabled or not.
namespace icc_igrpen0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_igrpen0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_igrpen0, val) }

	namespace enable
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_igrpen0, 0) }
		inline uint32_t is_enabled(uint32_t icc_igrpen0_val) noexcept { IS_BIT_ENABLED_FUNC(icc_igrpen0_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_igrpen0, 0) }
		inline uint32_t is_disabled(uint32_t icc_igrpen0_val) noexcept { IS_BIT_DISABLED_FUNC(icc_igrpen0_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_igrpen0, 0x1) }
		inline uint32_t enable(uint32_t icc_igrpen0_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_igrpen0_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_igrpen0, 0x1) }
		inline uint32_t disable(uint32_t icc_igrpen0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_igrpen0_val, 0x1) }
	}
}

// ICC_IGRPEN1 (Interrupt Controller Interrupt Group 1 Enable register)
// Controls whether Group 1 interrupts are enabled for the current Security state.
namespace icc_igrpen1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_igrpen1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_igrpen1, val) }

	namespace enable
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_igrpen1, 0) }
		inline uint32_t is_enabled(uint32_t icc_igrpen1_val) noexcept { IS_BIT_ENABLED_FUNC(icc_igrpen1_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_igrpen1, 0) }
		inline uint32_t is_disabled(uint32_t icc_igrpen1_val) noexcept { IS_BIT_DISABLED_FUNC(icc_igrpen1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_igrpen1, 0x1) }
		inline uint32_t enable(uint32_t icc_igrpen1_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_igrpen1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_igrpen1, 0x1) }
		inline uint32_t disable(uint32_t icc_igrpen1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_igrpen1_val, 0x1) }
	}
}

// ICC_MCTLR (Interrupt Controller Monitor Control Register)
// Controls aspects of the behavior of the GIC CPU interface and provides information about the features implemented.
namespace icc_mctlr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_mctlr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_mctlr, val) }

	namespace rss
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_mctlr, 18) }
		inline uint32_t is_enabled(uint32_t icc_mctlr_val) noexcept { IS_BIT_ENABLED_FUNC(icc_mctlr_val, 18) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_mctlr, 18) }
		inline uint32_t is_disabled(uint32_t icc_mctlr_val) noexcept { IS_BIT_DISABLED_FUNC(icc_mctlr_val, 18) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_mctlr, 0x40000) }
		inline uint32_t enable(uint32_t icc_mctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_mctlr_val, 0x40000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_mctlr, 0x40000) }
		inline uint32_t disable(uint32_t icc_mctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_mctlr_val, 0x40000) }
	}

	namespace nds
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_mctlr, 17) }
		inline uint32_t is_enabled(uint32_t icc_mctlr_val) noexcept { IS_BIT_ENABLED_FUNC(icc_mctlr_val, 17) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_mctlr, 17) }
		inline uint32_t is_disabled(uint32_t icc_mctlr_val) noexcept { IS_BIT_DISABLED_FUNC(icc_mctlr_val, 17) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_mctlr, 0x20000) }
		inline uint32_t enable(uint32_t icc_mctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_mctlr_val, 0x20000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_mctlr, 0x20000) }
		inline uint32_t disable(uint32_t icc_mctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_mctlr_val, 0x20000) }
	}

	namespace a3v
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_mctlr, 15) }
		inline uint32_t is_enabled(uint32_t icc_mctlr_val) noexcept { IS_BIT_ENABLED_FUNC(icc_mctlr_val, 15) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_mctlr, 15) }
		inline uint32_t is_disabled(uint32_t icc_mctlr_val) noexcept { IS_BIT_DISABLED_FUNC(icc_mctlr_val, 15) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_mctlr, 0x8000) }
		inline uint32_t enable(uint32_t icc_mctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_mctlr_val, 0x8000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_mctlr, 0x8000) }
		inline uint32_t disable(uint32_t icc_mctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_mctlr_val, 0x8000) }
	}

	namespace seis
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_mctlr, 14) }
		inline uint32_t is_enabled(uint32_t icc_mctlr_val) noexcept { IS_BIT_ENABLED_FUNC(icc_mctlr_val, 14) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_mctlr, 14) }
		inline uint32_t is_disabled(uint32_t icc_mctlr_val) noexcept { IS_BIT_DISABLED_FUNC(icc_mctlr_val, 14) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_mctlr, 0x4000) }
		inline uint32_t enable(uint32_t icc_mctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_mctlr_val, 0x4000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_mctlr, 0x4000) }
		inline uint32_t disable(uint32_t icc_mctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_mctlr_val, 0x4000) }
	}

	namespace idbits
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_mctlr, 0x3800, 11) }
		inline uint32_t get(uint32_t icc_mctlr_val) noexcept { GET_BITFIELD_FUNC(icc_mctlr_val, 0x3800, 11) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_mctlr, value, 0x3800, 11) }
		inline uint32_t set(uint32_t icc_mctlr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_mctlr, value, 0x3800, 11) }
	}

	namespace pribits
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_mctlr, 0x700, 8) }
		inline uint32_t get(uint32_t icc_mctlr_val) noexcept { GET_BITFIELD_FUNC(icc_mctlr_val, 0x700, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_mctlr, value, 0x700, 8) }
		inline uint32_t set(uint32_t icc_mctlr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_mctlr, value, 0x700, 8) }
	}

	namespace pmhe
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_mctlr, 6) }
		inline uint32_t is_enabled(uint32_t icc_mctlr_val) noexcept { IS_BIT_ENABLED_FUNC(icc_mctlr_val, 6) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_mctlr, 6) }
		inline uint32_t is_disabled(uint32_t icc_mctlr_val) noexcept { IS_BIT_DISABLED_FUNC(icc_mctlr_val, 6) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_mctlr, 0x40) }
		inline uint32_t enable(uint32_t icc_mctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_mctlr_val, 0x40) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_mctlr, 0x40) }
		inline uint32_t disable(uint32_t icc_mctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_mctlr_val, 0x40) }
	}

	namespace rm
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_mctlr, 5) }
		inline uint32_t is_enabled(uint32_t icc_mctlr_val) noexcept { IS_BIT_ENABLED_FUNC(icc_mctlr_val, 5) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_mctlr, 5) }
		inline uint32_t is_disabled(uint32_t icc_mctlr_val) noexcept { IS_BIT_DISABLED_FUNC(icc_mctlr_val, 5) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_mctlr, 0x20) }
		inline uint32_t enable(uint32_t icc_mctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_mctlr_val, 0x20) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_mctlr, 0x20) }
		inline uint32_t disable(uint32_t icc_mctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_mctlr_val, 0x20) }
	}

	namespace eoimode_el1ns
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_mctlr, 4) }
		inline uint32_t is_enabled(uint32_t icc_mctlr_val) noexcept { IS_BIT_ENABLED_FUNC(icc_mctlr_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_mctlr, 4) }
		inline uint32_t is_disabled(uint32_t icc_mctlr_val) noexcept { IS_BIT_DISABLED_FUNC(icc_mctlr_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_mctlr, 0x10) }
		inline uint32_t enable(uint32_t icc_mctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_mctlr_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_mctlr, 0x10) }
		inline uint32_t disable(uint32_t icc_mctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_mctlr_val, 0x10) }
	}

	namespace eoimode_el1s
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_mctlr, 3) }
		inline uint32_t is_enabled(uint32_t icc_mctlr_val) noexcept { IS_BIT_ENABLED_FUNC(icc_mctlr_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_mctlr, 3) }
		inline uint32_t is_disabled(uint32_t icc_mctlr_val) noexcept { IS_BIT_DISABLED_FUNC(icc_mctlr_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_mctlr, 0x8) }
		inline uint32_t enable(uint32_t icc_mctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_mctlr_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_mctlr, 0x8) }
		inline uint32_t disable(uint32_t icc_mctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_mctlr_val, 0x8) }
	}

	namespace eoimode_el3
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_mctlr, 2) }
		inline uint32_t is_enabled(uint32_t icc_mctlr_val) noexcept { IS_BIT_ENABLED_FUNC(icc_mctlr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_mctlr, 2) }
		inline uint32_t is_disabled(uint32_t icc_mctlr_val) noexcept { IS_BIT_DISABLED_FUNC(icc_mctlr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_mctlr, 0x4) }
		inline uint32_t enable(uint32_t icc_mctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_mctlr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_mctlr, 0x4) }
		inline uint32_t disable(uint32_t icc_mctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_mctlr_val, 0x4) }
	}

	namespace cbpr_el1ns
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_mctlr, 1) }
		inline uint32_t is_enabled(uint32_t icc_mctlr_val) noexcept { IS_BIT_ENABLED_FUNC(icc_mctlr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_mctlr, 1) }
		inline uint32_t is_disabled(uint32_t icc_mctlr_val) noexcept { IS_BIT_DISABLED_FUNC(icc_mctlr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_mctlr, 0x2) }
		inline uint32_t enable(uint32_t icc_mctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_mctlr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_mctlr, 0x2) }
		inline uint32_t disable(uint32_t icc_mctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_mctlr_val, 0x2) }
	}

	namespace cbpr_el1s
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_mctlr, 0) }
		inline uint32_t is_enabled(uint32_t icc_mctlr_val) noexcept { IS_BIT_ENABLED_FUNC(icc_mctlr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_mctlr, 0) }
		inline uint32_t is_disabled(uint32_t icc_mctlr_val) noexcept { IS_BIT_DISABLED_FUNC(icc_mctlr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_mctlr, 0x1) }
		inline uint32_t enable(uint32_t icc_mctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_mctlr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_mctlr, 0x1) }
		inline uint32_t disable(uint32_t icc_mctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_mctlr_val, 0x1) }
	}
}

// ICC_MGRPEN1 (Interrupt Controller Monitor Interrupt Group 1 Enable register)
// Controls whether Group 1 interrupts are enabled or not.
namespace icc_mgrpen1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_mgrpen1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_mgrpen1, val) }

	namespace enablegrp1s
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_mgrpen1, 1) }
		inline uint32_t is_enabled(uint32_t icc_mgrpen1_val) noexcept { IS_BIT_ENABLED_FUNC(icc_mgrpen1_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_mgrpen1, 1) }
		inline uint32_t is_disabled(uint32_t icc_mgrpen1_val) noexcept { IS_BIT_DISABLED_FUNC(icc_mgrpen1_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_mgrpen1, 0x2) }
		inline uint32_t enable(uint32_t icc_mgrpen1_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_mgrpen1_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_mgrpen1, 0x2) }
		inline uint32_t disable(uint32_t icc_mgrpen1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_mgrpen1_val, 0x2) }
	}

	namespace enablegrp1ns
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_mgrpen1, 0) }
		inline uint32_t is_enabled(uint32_t icc_mgrpen1_val) noexcept { IS_BIT_ENABLED_FUNC(icc_mgrpen1_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_mgrpen1, 0) }
		inline uint32_t is_disabled(uint32_t icc_mgrpen1_val) noexcept { IS_BIT_DISABLED_FUNC(icc_mgrpen1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_mgrpen1, 0x1) }
		inline uint32_t enable(uint32_t icc_mgrpen1_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_mgrpen1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_mgrpen1, 0x1) }
		inline uint32_t disable(uint32_t icc_mgrpen1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_mgrpen1_val, 0x1) }
	}
}

// ICC_MSRE (Interrupt Controller Monitor System Register Enable register)
// Controls whether the System register interface or the memory-mapped interface to the GIC CPU interface is used for EL3.
namespace icc_msre
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_msre) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_msre, val) }

	namespace enable
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_msre, 3) }
		inline uint32_t is_enabled(uint32_t icc_msre_val) noexcept { IS_BIT_ENABLED_FUNC(icc_msre_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_msre, 3) }
		inline uint32_t is_disabled(uint32_t icc_msre_val) noexcept { IS_BIT_DISABLED_FUNC(icc_msre_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_msre, 0x8) }
		inline uint32_t enable(uint32_t icc_msre_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_msre_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_msre, 0x8) }
		inline uint32_t disable(uint32_t icc_msre_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_msre_val, 0x8) }
	}

	namespace dib
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_msre, 2) }
		inline uint32_t is_enabled(uint32_t icc_msre_val) noexcept { IS_BIT_ENABLED_FUNC(icc_msre_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_msre, 2) }
		inline uint32_t is_disabled(uint32_t icc_msre_val) noexcept { IS_BIT_DISABLED_FUNC(icc_msre_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_msre, 0x4) }
		inline uint32_t enable(uint32_t icc_msre_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_msre_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_msre, 0x4) }
		inline uint32_t disable(uint32_t icc_msre_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_msre_val, 0x4) }
	}

	namespace dfb
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_msre, 1) }
		inline uint32_t is_enabled(uint32_t icc_msre_val) noexcept { IS_BIT_ENABLED_FUNC(icc_msre_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_msre, 1) }
		inline uint32_t is_disabled(uint32_t icc_msre_val) noexcept { IS_BIT_DISABLED_FUNC(icc_msre_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_msre, 0x2) }
		inline uint32_t enable(uint32_t icc_msre_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_msre_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_msre, 0x2) }
		inline uint32_t disable(uint32_t icc_msre_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_msre_val, 0x2) }
	}

	namespace sre
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_msre, 0) }
		inline uint32_t is_enabled(uint32_t icc_msre_val) noexcept { IS_BIT_ENABLED_FUNC(icc_msre_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_msre, 0) }
		inline uint32_t is_disabled(uint32_t icc_msre_val) noexcept { IS_BIT_DISABLED_FUNC(icc_msre_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_msre, 0x1) }
		inline uint32_t enable(uint32_t icc_msre_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_msre_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_msre, 0x1) }
		inline uint32_t disable(uint32_t icc_msre_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_msre_val, 0x1) }
	}
}

// ICC_PMR (Interrupt Controller Interrupt Priority Mask Register)
// Provides an interrupt priority filter. Only interrupts with a higher priority than the value in this register are signaled to the PE.
namespace icc_pmr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_pmr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_pmr, val) }

	namespace priority
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_pmr, 0xff, 0) }
		inline uint32_t get(uint32_t icc_pmr_val) noexcept { GET_BITFIELD_FUNC(icc_pmr_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_pmr, value, 0xff, 0) }
		inline uint32_t set(uint32_t icc_pmr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_pmr, value, 0xff, 0) }
	}
}

// ICC_RPR (Interrupt Controller Running Priority Register)
// Indicates the Running priority of the CPU interface.
namespace icc_rpr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_rpr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_rpr, val) }

	namespace priority
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_rpr, 0xff, 0) }
		inline uint32_t get(uint32_t icc_rpr_val) noexcept { GET_BITFIELD_FUNC(icc_rpr_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_rpr, value, 0xff, 0) }
		inline uint32_t set(uint32_t icc_rpr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_rpr, value, 0xff, 0) }
	}
}

// ICC_SGI0R (Interrupt Controller Software Generated Interrupt Group 0 Register)
// Generates Secure Group 0 SGIs.
namespace icc_sgi0r
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(icc_sgi0r) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_sgi0r, val) }

	namespace aff3
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_sgi0r, 0xff000000000000, 48) }
		inline uint64_t get(uint64_t icc_sgi0r_val) noexcept { GET_BITFIELD_FUNC(icc_sgi0r_val, 0xff000000000000, 48) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_sgi0r, value, 0xff000000000000, 48) }
		inline uint64_t set(uint64_t icc_sgi0r, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_sgi0r, value, 0xff000000000000, 48) }
	}

	namespace rs
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_sgi0r, 0xf00000000000, 44) }
		inline uint64_t get(uint64_t icc_sgi0r_val) noexcept { GET_BITFIELD_FUNC(icc_sgi0r_val, 0xf00000000000, 44) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_sgi0r, value, 0xf00000000000, 44) }
		inline uint64_t set(uint64_t icc_sgi0r, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_sgi0r, value, 0xf00000000000, 44) }
	}

	namespace irm
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_sgi0r, 40) }
		inline uint64_t is_enabled(uint64_t icc_sgi0r_val) noexcept { IS_BIT_ENABLED_FUNC(icc_sgi0r_val, 40) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_sgi0r, 40) }
		inline uint64_t is_disabled(uint64_t icc_sgi0r_val) noexcept { IS_BIT_DISABLED_FUNC(icc_sgi0r_val, 40) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_sgi0r, 0x10000000000) }
		inline uint64_t enable(uint64_t icc_sgi0r_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_sgi0r_val, 0x10000000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_sgi0r, 0x10000000000) }
		inline uint64_t disable(uint64_t icc_sgi0r_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_sgi0r_val, 0x10000000000) }
	}

	namespace aff2
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_sgi0r, 0xff00000000, 32) }
		inline uint64_t get(uint64_t icc_sgi0r_val) noexcept { GET_BITFIELD_FUNC(icc_sgi0r_val, 0xff00000000, 32) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_sgi0r, value, 0xff00000000, 32) }
		inline uint64_t set(uint64_t icc_sgi0r, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_sgi0r, value, 0xff00000000, 32) }
	}

	namespace intid
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_sgi0r, 0xf000000, 24) }
		inline uint64_t get(uint64_t icc_sgi0r_val) noexcept { GET_BITFIELD_FUNC(icc_sgi0r_val, 0xf000000, 24) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_sgi0r, value, 0xf000000, 24) }
		inline uint64_t set(uint64_t icc_sgi0r, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_sgi0r, value, 0xf000000, 24) }
	}

	namespace aff1
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_sgi0r, 0xff0000, 16) }
		inline uint64_t get(uint64_t icc_sgi0r_val) noexcept { GET_BITFIELD_FUNC(icc_sgi0r_val, 0xff0000, 16) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_sgi0r, value, 0xff0000, 16) }
		inline uint64_t set(uint64_t icc_sgi0r, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_sgi0r, value, 0xff0000, 16) }
	}

	namespace targetlist
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_sgi0r, 0xffff, 0) }
		inline uint64_t get(uint64_t icc_sgi0r_val) noexcept { GET_BITFIELD_FUNC(icc_sgi0r_val, 0xffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_sgi0r, value, 0xffff, 0) }
		inline uint64_t set(uint64_t icc_sgi0r, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_sgi0r, value, 0xffff, 0) }
	}
}

// ICC_SGI1R (Interrupt Controller Software Generated Interrupt Group 1 Register)
// Generates Group 1 SGIs for the current Security state.
namespace icc_sgi1r
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(icc_sgi1r) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_sgi1r, val) }

	namespace aff3
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_sgi1r, 0xff000000000000, 48) }
		inline uint64_t get(uint64_t icc_sgi1r_val) noexcept { GET_BITFIELD_FUNC(icc_sgi1r_val, 0xff000000000000, 48) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_sgi1r, value, 0xff000000000000, 48) }
		inline uint64_t set(uint64_t icc_sgi1r, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_sgi1r, value, 0xff000000000000, 48) }
	}

	namespace rs
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_sgi1r, 0xf00000000000, 44) }
		inline uint64_t get(uint64_t icc_sgi1r_val) noexcept { GET_BITFIELD_FUNC(icc_sgi1r_val, 0xf00000000000, 44) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_sgi1r, value, 0xf00000000000, 44) }
		inline uint64_t set(uint64_t icc_sgi1r, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_sgi1r, value, 0xf00000000000, 44) }
	}

	namespace irm
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_sgi1r, 40) }
		inline uint64_t is_enabled(uint64_t icc_sgi1r_val) noexcept { IS_BIT_ENABLED_FUNC(icc_sgi1r_val, 40) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_sgi1r, 40) }
		inline uint64_t is_disabled(uint64_t icc_sgi1r_val) noexcept { IS_BIT_DISABLED_FUNC(icc_sgi1r_val, 40) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_sgi1r, 0x10000000000) }
		inline uint64_t enable(uint64_t icc_sgi1r_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_sgi1r_val, 0x10000000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_sgi1r, 0x10000000000) }
		inline uint64_t disable(uint64_t icc_sgi1r_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_sgi1r_val, 0x10000000000) }
	}

	namespace aff2
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_sgi1r, 0xff00000000, 32) }
		inline uint64_t get(uint64_t icc_sgi1r_val) noexcept { GET_BITFIELD_FUNC(icc_sgi1r_val, 0xff00000000, 32) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_sgi1r, value, 0xff00000000, 32) }
		inline uint64_t set(uint64_t icc_sgi1r, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_sgi1r, value, 0xff00000000, 32) }
	}

	namespace intid
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_sgi1r, 0xf000000, 24) }
		inline uint64_t get(uint64_t icc_sgi1r_val) noexcept { GET_BITFIELD_FUNC(icc_sgi1r_val, 0xf000000, 24) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_sgi1r, value, 0xf000000, 24) }
		inline uint64_t set(uint64_t icc_sgi1r, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_sgi1r, value, 0xf000000, 24) }
	}

	namespace aff1
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_sgi1r, 0xff0000, 16) }
		inline uint64_t get(uint64_t icc_sgi1r_val) noexcept { GET_BITFIELD_FUNC(icc_sgi1r_val, 0xff0000, 16) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_sgi1r, value, 0xff0000, 16) }
		inline uint64_t set(uint64_t icc_sgi1r, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_sgi1r, value, 0xff0000, 16) }
	}

	namespace targetlist
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_sgi1r, 0xffff, 0) }
		inline uint64_t get(uint64_t icc_sgi1r_val) noexcept { GET_BITFIELD_FUNC(icc_sgi1r_val, 0xffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_sgi1r, value, 0xffff, 0) }
		inline uint64_t set(uint64_t icc_sgi1r, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_sgi1r, value, 0xffff, 0) }
	}
}

// ICC_SRE (Interrupt Controller System Register Enable register)
// Controls whether the System register interface or the memory-mapped interface to the GIC CPU interface is used for EL0 and EL1.
namespace icc_sre
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_sre) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_sre, val) }

	namespace dib
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_sre, 2) }
		inline uint32_t is_enabled(uint32_t icc_sre_val) noexcept { IS_BIT_ENABLED_FUNC(icc_sre_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_sre, 2) }
		inline uint32_t is_disabled(uint32_t icc_sre_val) noexcept { IS_BIT_DISABLED_FUNC(icc_sre_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_sre, 0x4) }
		inline uint32_t enable(uint32_t icc_sre_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_sre_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_sre, 0x4) }
		inline uint32_t disable(uint32_t icc_sre_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_sre_val, 0x4) }
	}

	namespace dfb
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_sre, 1) }
		inline uint32_t is_enabled(uint32_t icc_sre_val) noexcept { IS_BIT_ENABLED_FUNC(icc_sre_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_sre, 1) }
		inline uint32_t is_disabled(uint32_t icc_sre_val) noexcept { IS_BIT_DISABLED_FUNC(icc_sre_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_sre, 0x2) }
		inline uint32_t enable(uint32_t icc_sre_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_sre_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_sre, 0x2) }
		inline uint32_t disable(uint32_t icc_sre_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_sre_val, 0x2) }
	}

	namespace sre
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_sre, 0) }
		inline uint32_t is_enabled(uint32_t icc_sre_val) noexcept { IS_BIT_ENABLED_FUNC(icc_sre_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_sre, 0) }
		inline uint32_t is_disabled(uint32_t icc_sre_val) noexcept { IS_BIT_DISABLED_FUNC(icc_sre_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_sre, 0x1) }
		inline uint32_t enable(uint32_t icc_sre_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_sre_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_sre, 0x1) }
		inline uint32_t disable(uint32_t icc_sre_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_sre_val, 0x1) }
	}
}

// ICH_AP0R<n> (Interrupt Controller Hyp Active Priorities Group 0 Registers)
// Provides information about Group 0 active priorities for EL2.
namespace ich_ap0r<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ich_ap0r<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ich_ap0r<n>, val) }

	namespace p_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_ap0r<n>, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ich_ap0r<n>_val) noexcept { GET_BITFIELD_FUNC(ich_ap0r<n>_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_ap0r<n>, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ich_ap0r<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_ap0r<n>, value, 0xffffffff, 0) }
	}
}

// ICH_AP1R<n> (Interrupt Controller Hyp Active Priorities Group 1 Registers)
// Provides information about Group 1 active priorities for EL2.
namespace ich_ap1r<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ich_ap1r<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ich_ap1r<n>, val) }

	namespace p_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_ap1r<n>, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ich_ap1r<n>_val) noexcept { GET_BITFIELD_FUNC(ich_ap1r<n>_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_ap1r<n>, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ich_ap1r<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_ap1r<n>, value, 0xffffffff, 0) }
	}
}

// ICH_EISR (Interrupt Controller End of Interrupt Status Register)
// Indicates which List registers have outstanding EOI maintenance interrupts.
namespace ich_eisr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ich_eisr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ich_eisr, val) }

	namespace status_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_eisr, 0xffff, 0) }
		inline uint32_t get(uint32_t ich_eisr_val) noexcept { GET_BITFIELD_FUNC(ich_eisr_val, 0xffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_eisr, value, 0xffff, 0) }
		inline uint32_t set(uint32_t ich_eisr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_eisr, value, 0xffff, 0) }
	}
}

// ICH_ELRSR (Interrupt Controller Empty List Register Status Register)
// Indicates which List registers contain valid interrupts.
namespace ich_elrsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ich_elrsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ich_elrsr, val) }

	namespace status_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_elrsr, 0xffff, 0) }
		inline uint32_t get(uint32_t ich_elrsr_val) noexcept { GET_BITFIELD_FUNC(ich_elrsr_val, 0xffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_elrsr, value, 0xffff, 0) }
		inline uint32_t set(uint32_t ich_elrsr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_elrsr, value, 0xffff, 0) }
	}
}

// ICH_HCR (Interrupt Controller Hyp Control Register)
// Controls the environment for VMs.
namespace ich_hcr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ich_hcr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ich_hcr, val) }

	namespace eoicount
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_hcr, 0xf8000000, 27) }
		inline uint32_t get(uint32_t ich_hcr_val) noexcept { GET_BITFIELD_FUNC(ich_hcr_val, 0xf8000000, 27) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_hcr, value, 0xf8000000, 27) }
		inline uint32_t set(uint32_t ich_hcr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_hcr, value, 0xf8000000, 27) }
	}

	namespace tdir
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr, 14) }
		inline uint32_t is_enabled(uint32_t ich_hcr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_val, 14) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr, 14) }
		inline uint32_t is_disabled(uint32_t ich_hcr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_val, 14) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x4000) }
		inline uint32_t enable(uint32_t ich_hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_val, 0x4000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x4000) }
		inline uint32_t disable(uint32_t ich_hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_val, 0x4000) }
	}

	namespace tsei
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr, 13) }
		inline uint32_t is_enabled(uint32_t ich_hcr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_val, 13) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr, 13) }
		inline uint32_t is_disabled(uint32_t ich_hcr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_val, 13) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x2000) }
		inline uint32_t enable(uint32_t ich_hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_val, 0x2000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x2000) }
		inline uint32_t disable(uint32_t ich_hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_val, 0x2000) }
	}

	namespace tall1
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr, 12) }
		inline uint32_t is_enabled(uint32_t ich_hcr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_val, 12) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr, 12) }
		inline uint32_t is_disabled(uint32_t ich_hcr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_val, 12) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x1000) }
		inline uint32_t enable(uint32_t ich_hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_val, 0x1000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x1000) }
		inline uint32_t disable(uint32_t ich_hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_val, 0x1000) }
	}

	namespace tall0
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr, 11) }
		inline uint32_t is_enabled(uint32_t ich_hcr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_val, 11) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr, 11) }
		inline uint32_t is_disabled(uint32_t ich_hcr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_val, 11) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x800) }
		inline uint32_t enable(uint32_t ich_hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_val, 0x800) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x800) }
		inline uint32_t disable(uint32_t ich_hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_val, 0x800) }
	}

	namespace tc
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr, 10) }
		inline uint32_t is_enabled(uint32_t ich_hcr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_val, 10) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr, 10) }
		inline uint32_t is_disabled(uint32_t ich_hcr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_val, 10) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x400) }
		inline uint32_t enable(uint32_t ich_hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_val, 0x400) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x400) }
		inline uint32_t disable(uint32_t ich_hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_val, 0x400) }
	}

	namespace vgrp1die
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr, 7) }
		inline uint32_t is_enabled(uint32_t ich_hcr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_val, 7) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr, 7) }
		inline uint32_t is_disabled(uint32_t ich_hcr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_val, 7) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x80) }
		inline uint32_t enable(uint32_t ich_hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_val, 0x80) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x80) }
		inline uint32_t disable(uint32_t ich_hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_val, 0x80) }
	}

	namespace vgrp1eie
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr, 6) }
		inline uint32_t is_enabled(uint32_t ich_hcr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_val, 6) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr, 6) }
		inline uint32_t is_disabled(uint32_t ich_hcr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_val, 6) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x40) }
		inline uint32_t enable(uint32_t ich_hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_val, 0x40) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x40) }
		inline uint32_t disable(uint32_t ich_hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_val, 0x40) }
	}

	namespace vgrp0die
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr, 5) }
		inline uint32_t is_enabled(uint32_t ich_hcr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_val, 5) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr, 5) }
		inline uint32_t is_disabled(uint32_t ich_hcr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_val, 5) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x20) }
		inline uint32_t enable(uint32_t ich_hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_val, 0x20) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x20) }
		inline uint32_t disable(uint32_t ich_hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_val, 0x20) }
	}

	namespace vgrp0eie
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr, 4) }
		inline uint32_t is_enabled(uint32_t ich_hcr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr, 4) }
		inline uint32_t is_disabled(uint32_t ich_hcr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x10) }
		inline uint32_t enable(uint32_t ich_hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x10) }
		inline uint32_t disable(uint32_t ich_hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_val, 0x10) }
	}

	namespace npie
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr, 3) }
		inline uint32_t is_enabled(uint32_t ich_hcr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr, 3) }
		inline uint32_t is_disabled(uint32_t ich_hcr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x8) }
		inline uint32_t enable(uint32_t ich_hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x8) }
		inline uint32_t disable(uint32_t ich_hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_val, 0x8) }
	}

	namespace lrenpie
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr, 2) }
		inline uint32_t is_enabled(uint32_t ich_hcr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr, 2) }
		inline uint32_t is_disabled(uint32_t ich_hcr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x4) }
		inline uint32_t enable(uint32_t ich_hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x4) }
		inline uint32_t disable(uint32_t ich_hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_val, 0x4) }
	}

	namespace uie
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr, 1) }
		inline uint32_t is_enabled(uint32_t ich_hcr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr, 1) }
		inline uint32_t is_disabled(uint32_t ich_hcr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x2) }
		inline uint32_t enable(uint32_t ich_hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x2) }
		inline uint32_t disable(uint32_t ich_hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_val, 0x2) }
	}

	namespace en
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr, 0) }
		inline uint32_t is_enabled(uint32_t ich_hcr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr, 0) }
		inline uint32_t is_disabled(uint32_t ich_hcr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x1) }
		inline uint32_t enable(uint32_t ich_hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr, 0x1) }
		inline uint32_t disable(uint32_t ich_hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_val, 0x1) }
	}
}

// ICH_LRC<n> (Interrupt Controller List Registers)
// Provides interrupt context information for the virtual CPU interface.
namespace ich_lrc<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ich_lrc<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ich_lrc<n>, val) }

	namespace state
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_lrc<n>, 0xc0000000, 30) }
		inline uint32_t get(uint32_t ich_lrc<n>_val) noexcept { GET_BITFIELD_FUNC(ich_lrc<n>_val, 0xc0000000, 30) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_lrc<n>, value, 0xc0000000, 30) }
		inline uint32_t set(uint32_t ich_lrc<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_lrc<n>, value, 0xc0000000, 30) }
	}

	namespace hw
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_lrc<n>, 29) }
		inline uint32_t is_enabled(uint32_t ich_lrc<n>_val) noexcept { IS_BIT_ENABLED_FUNC(ich_lrc<n>_val, 29) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_lrc<n>, 29) }
		inline uint32_t is_disabled(uint32_t ich_lrc<n>_val) noexcept { IS_BIT_DISABLED_FUNC(ich_lrc<n>_val, 29) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_lrc<n>, 0x20000000) }
		inline uint32_t enable(uint32_t ich_lrc<n>_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_lrc<n>_val, 0x20000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_lrc<n>, 0x20000000) }
		inline uint32_t disable(uint32_t ich_lrc<n>_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_lrc<n>_val, 0x20000000) }
	}

	namespace group
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_lrc<n>, 28) }
		inline uint32_t is_enabled(uint32_t ich_lrc<n>_val) noexcept { IS_BIT_ENABLED_FUNC(ich_lrc<n>_val, 28) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_lrc<n>, 28) }
		inline uint32_t is_disabled(uint32_t ich_lrc<n>_val) noexcept { IS_BIT_DISABLED_FUNC(ich_lrc<n>_val, 28) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_lrc<n>, 0x10000000) }
		inline uint32_t enable(uint32_t ich_lrc<n>_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_lrc<n>_val, 0x10000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_lrc<n>, 0x10000000) }
		inline uint32_t disable(uint32_t ich_lrc<n>_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_lrc<n>_val, 0x10000000) }
	}

	namespace priority
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_lrc<n>, 0xff0000, 16) }
		inline uint32_t get(uint32_t ich_lrc<n>_val) noexcept { GET_BITFIELD_FUNC(ich_lrc<n>_val, 0xff0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_lrc<n>, value, 0xff0000, 16) }
		inline uint32_t set(uint32_t ich_lrc<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_lrc<n>, value, 0xff0000, 16) }
	}

	namespace pintid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_lrc<n>, 0x3ff, 0) }
		inline uint32_t get(uint32_t ich_lrc<n>_val) noexcept { GET_BITFIELD_FUNC(ich_lrc<n>_val, 0x3ff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_lrc<n>, value, 0x3ff, 0) }
		inline uint32_t set(uint32_t ich_lrc<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_lrc<n>, value, 0x3ff, 0) }
	}
}

// ICH_LR<n> (Interrupt Controller List Registers)
// Provides interrupt context information for the virtual CPU interface.
namespace ich_lr<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ich_lr<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ich_lr<n>, val) }

	namespace vintid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_lr<n>, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ich_lr<n>_val) noexcept { GET_BITFIELD_FUNC(ich_lr<n>_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_lr<n>, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ich_lr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_lr<n>, value, 0xffffffff, 0) }
	}
}

// ICH_MISR (Interrupt Controller Maintenance Interrupt State Register)
// Indicates which maintenance interrupts are asserted.
namespace ich_misr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ich_misr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ich_misr, val) }

	namespace vgrp1d
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_misr, 7) }
		inline uint32_t is_enabled(uint32_t ich_misr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_misr_val, 7) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_misr, 7) }
		inline uint32_t is_disabled(uint32_t ich_misr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_misr_val, 7) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_misr, 0x80) }
		inline uint32_t enable(uint32_t ich_misr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_misr_val, 0x80) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_misr, 0x80) }
		inline uint32_t disable(uint32_t ich_misr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_misr_val, 0x80) }
	}

	namespace vgrp1e
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_misr, 6) }
		inline uint32_t is_enabled(uint32_t ich_misr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_misr_val, 6) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_misr, 6) }
		inline uint32_t is_disabled(uint32_t ich_misr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_misr_val, 6) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_misr, 0x40) }
		inline uint32_t enable(uint32_t ich_misr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_misr_val, 0x40) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_misr, 0x40) }
		inline uint32_t disable(uint32_t ich_misr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_misr_val, 0x40) }
	}

	namespace vgrp0d
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_misr, 5) }
		inline uint32_t is_enabled(uint32_t ich_misr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_misr_val, 5) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_misr, 5) }
		inline uint32_t is_disabled(uint32_t ich_misr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_misr_val, 5) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_misr, 0x20) }
		inline uint32_t enable(uint32_t ich_misr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_misr_val, 0x20) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_misr, 0x20) }
		inline uint32_t disable(uint32_t ich_misr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_misr_val, 0x20) }
	}

	namespace vgrp0e
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_misr, 4) }
		inline uint32_t is_enabled(uint32_t ich_misr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_misr_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_misr, 4) }
		inline uint32_t is_disabled(uint32_t ich_misr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_misr_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_misr, 0x10) }
		inline uint32_t enable(uint32_t ich_misr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_misr_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_misr, 0x10) }
		inline uint32_t disable(uint32_t ich_misr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_misr_val, 0x10) }
	}

	namespace np
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_misr, 3) }
		inline uint32_t is_enabled(uint32_t ich_misr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_misr_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_misr, 3) }
		inline uint32_t is_disabled(uint32_t ich_misr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_misr_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_misr, 0x8) }
		inline uint32_t enable(uint32_t ich_misr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_misr_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_misr, 0x8) }
		inline uint32_t disable(uint32_t ich_misr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_misr_val, 0x8) }
	}

	namespace lrenp
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_misr, 2) }
		inline uint32_t is_enabled(uint32_t ich_misr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_misr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_misr, 2) }
		inline uint32_t is_disabled(uint32_t ich_misr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_misr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_misr, 0x4) }
		inline uint32_t enable(uint32_t ich_misr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_misr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_misr, 0x4) }
		inline uint32_t disable(uint32_t ich_misr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_misr_val, 0x4) }
	}

	namespace u
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_misr, 1) }
		inline uint32_t is_enabled(uint32_t ich_misr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_misr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_misr, 1) }
		inline uint32_t is_disabled(uint32_t ich_misr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_misr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_misr, 0x2) }
		inline uint32_t enable(uint32_t ich_misr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_misr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_misr, 0x2) }
		inline uint32_t disable(uint32_t ich_misr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_misr_val, 0x2) }
	}

	namespace eoi
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_misr, 0) }
		inline uint32_t is_enabled(uint32_t ich_misr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_misr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_misr, 0) }
		inline uint32_t is_disabled(uint32_t ich_misr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_misr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_misr, 0x1) }
		inline uint32_t enable(uint32_t ich_misr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_misr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_misr, 0x1) }
		inline uint32_t disable(uint32_t ich_misr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_misr_val, 0x1) }
	}
}

// ICH_VMCR (Interrupt Controller Virtual Machine Control Register)
// Enables the hypervisor to save and restore the virtual machine view of the GIC state.
namespace ich_vmcr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ich_vmcr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ich_vmcr, val) }

	namespace vpmr
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_vmcr, 0xff000000, 24) }
		inline uint32_t get(uint32_t ich_vmcr_val) noexcept { GET_BITFIELD_FUNC(ich_vmcr_val, 0xff000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_vmcr, value, 0xff000000, 24) }
		inline uint32_t set(uint32_t ich_vmcr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_vmcr, value, 0xff000000, 24) }
	}

	namespace vbpr0
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_vmcr, 0xe00000, 21) }
		inline uint32_t get(uint32_t ich_vmcr_val) noexcept { GET_BITFIELD_FUNC(ich_vmcr_val, 0xe00000, 21) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_vmcr, value, 0xe00000, 21) }
		inline uint32_t set(uint32_t ich_vmcr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_vmcr, value, 0xe00000, 21) }
	}

	namespace vbpr1
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_vmcr, 0x1c0000, 18) }
		inline uint32_t get(uint32_t ich_vmcr_val) noexcept { GET_BITFIELD_FUNC(ich_vmcr_val, 0x1c0000, 18) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_vmcr, value, 0x1c0000, 18) }
		inline uint32_t set(uint32_t ich_vmcr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_vmcr, value, 0x1c0000, 18) }
	}

	namespace veoim
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_vmcr, 9) }
		inline uint32_t is_enabled(uint32_t ich_vmcr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_vmcr_val, 9) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_vmcr, 9) }
		inline uint32_t is_disabled(uint32_t ich_vmcr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_vmcr_val, 9) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_vmcr, 0x200) }
		inline uint32_t enable(uint32_t ich_vmcr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_vmcr_val, 0x200) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_vmcr, 0x200) }
		inline uint32_t disable(uint32_t ich_vmcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_vmcr_val, 0x200) }
	}

	namespace vcbpr
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_vmcr, 4) }
		inline uint32_t is_enabled(uint32_t ich_vmcr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_vmcr_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_vmcr, 4) }
		inline uint32_t is_disabled(uint32_t ich_vmcr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_vmcr_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_vmcr, 0x10) }
		inline uint32_t enable(uint32_t ich_vmcr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_vmcr_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_vmcr, 0x10) }
		inline uint32_t disable(uint32_t ich_vmcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_vmcr_val, 0x10) }
	}

	namespace vfiqen
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_vmcr, 3) }
		inline uint32_t is_enabled(uint32_t ich_vmcr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_vmcr_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_vmcr, 3) }
		inline uint32_t is_disabled(uint32_t ich_vmcr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_vmcr_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_vmcr, 0x8) }
		inline uint32_t enable(uint32_t ich_vmcr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_vmcr_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_vmcr, 0x8) }
		inline uint32_t disable(uint32_t ich_vmcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_vmcr_val, 0x8) }
	}

	namespace vackctl
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_vmcr, 2) }
		inline uint32_t is_enabled(uint32_t ich_vmcr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_vmcr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_vmcr, 2) }
		inline uint32_t is_disabled(uint32_t ich_vmcr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_vmcr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_vmcr, 0x4) }
		inline uint32_t enable(uint32_t ich_vmcr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_vmcr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_vmcr, 0x4) }
		inline uint32_t disable(uint32_t ich_vmcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_vmcr_val, 0x4) }
	}

	namespace veng1
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_vmcr, 1) }
		inline uint32_t is_enabled(uint32_t ich_vmcr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_vmcr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_vmcr, 1) }
		inline uint32_t is_disabled(uint32_t ich_vmcr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_vmcr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_vmcr, 0x2) }
		inline uint32_t enable(uint32_t ich_vmcr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_vmcr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_vmcr, 0x2) }
		inline uint32_t disable(uint32_t ich_vmcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_vmcr_val, 0x2) }
	}

	namespace veng0
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_vmcr, 0) }
		inline uint32_t is_enabled(uint32_t ich_vmcr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_vmcr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_vmcr, 0) }
		inline uint32_t is_disabled(uint32_t ich_vmcr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_vmcr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_vmcr, 0x1) }
		inline uint32_t enable(uint32_t ich_vmcr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_vmcr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_vmcr, 0x1) }
		inline uint32_t disable(uint32_t ich_vmcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_vmcr_val, 0x1) }
	}
}

// ICH_VTR (Interrupt Controller VGIC Type Register)
// Reports supported GIC virtualisartion features.
namespace ich_vtr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ich_vtr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ich_vtr, val) }

	namespace pribits
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_vtr, 0xe0000000, 29) }
		inline uint32_t get(uint32_t ich_vtr_val) noexcept { GET_BITFIELD_FUNC(ich_vtr_val, 0xe0000000, 29) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_vtr, value, 0xe0000000, 29) }
		inline uint32_t set(uint32_t ich_vtr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_vtr, value, 0xe0000000, 29) }
	}

	namespace prebits
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_vtr, 0x1c000000, 26) }
		inline uint32_t get(uint32_t ich_vtr_val) noexcept { GET_BITFIELD_FUNC(ich_vtr_val, 0x1c000000, 26) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_vtr, value, 0x1c000000, 26) }
		inline uint32_t set(uint32_t ich_vtr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_vtr, value, 0x1c000000, 26) }
	}

	namespace idbits
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_vtr, 0x3800000, 23) }
		inline uint32_t get(uint32_t ich_vtr_val) noexcept { GET_BITFIELD_FUNC(ich_vtr_val, 0x3800000, 23) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_vtr, value, 0x3800000, 23) }
		inline uint32_t set(uint32_t ich_vtr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_vtr, value, 0x3800000, 23) }
	}

	namespace seis
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_vtr, 22) }
		inline uint32_t is_enabled(uint32_t ich_vtr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_vtr_val, 22) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_vtr, 22) }
		inline uint32_t is_disabled(uint32_t ich_vtr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_vtr_val, 22) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_vtr, 0x400000) }
		inline uint32_t enable(uint32_t ich_vtr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_vtr_val, 0x400000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_vtr, 0x400000) }
		inline uint32_t disable(uint32_t ich_vtr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_vtr_val, 0x400000) }
	}

	namespace a3v
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_vtr, 21) }
		inline uint32_t is_enabled(uint32_t ich_vtr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_vtr_val, 21) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_vtr, 21) }
		inline uint32_t is_disabled(uint32_t ich_vtr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_vtr_val, 21) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_vtr, 0x200000) }
		inline uint32_t enable(uint32_t ich_vtr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_vtr_val, 0x200000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_vtr, 0x200000) }
		inline uint32_t disable(uint32_t ich_vtr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_vtr_val, 0x200000) }
	}

	namespace nv4
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_vtr, 20) }
		inline uint32_t is_enabled(uint32_t ich_vtr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_vtr_val, 20) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_vtr, 20) }
		inline uint32_t is_disabled(uint32_t ich_vtr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_vtr_val, 20) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_vtr, 0x100000) }
		inline uint32_t enable(uint32_t ich_vtr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_vtr_val, 0x100000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_vtr, 0x100000) }
		inline uint32_t disable(uint32_t ich_vtr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_vtr_val, 0x100000) }
	}

	namespace tds
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_vtr, 19) }
		inline uint32_t is_enabled(uint32_t ich_vtr_val) noexcept { IS_BIT_ENABLED_FUNC(ich_vtr_val, 19) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_vtr, 19) }
		inline uint32_t is_disabled(uint32_t ich_vtr_val) noexcept { IS_BIT_DISABLED_FUNC(ich_vtr_val, 19) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_vtr, 0x80000) }
		inline uint32_t enable(uint32_t ich_vtr_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_vtr_val, 0x80000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_vtr, 0x80000) }
		inline uint32_t disable(uint32_t ich_vtr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_vtr_val, 0x80000) }
	}

	namespace listregs
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_vtr, 0x1f, 0) }
		inline uint32_t get(uint32_t ich_vtr_val) noexcept { GET_BITFIELD_FUNC(ich_vtr_val, 0x1f, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_vtr, value, 0x1f, 0) }
		inline uint32_t set(uint32_t ich_vtr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_vtr, value, 0x1f, 0) }
	}
}

// ICIALLU (Instruction Cache Invalidate All to PoU)
// Invalidate all instruction caches to PoU. If branch predictors are architecturally visible, also flush branch predictors.
namespace iciallu
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(iciallu) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(iciallu, val) }
}

// ICIALLUIS (Instruction Cache Invalidate All to PoU, Inner Shareable)
// Invalidate all instruction caches Inner Shareable to PoU. If branch predictors are architecturally visible, also flush branch predictors.
namespace icialluis
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icialluis) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icialluis, val) }
}

// ICIMVAU (Instruction Cache line Invalidate by VA to PoU)
// Invalidate instruction cache line by virtual address to PoU.
namespace icimvau
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icimvau) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icimvau, val) }

	namespace virtual_address_to_use
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icimvau, 0xffffffff, 0) }
		inline uint32_t get(uint32_t icimvau_val) noexcept { GET_BITFIELD_FUNC(icimvau_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icimvau, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t icimvau, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icimvau, value, 0xffffffff, 0) }
	}
}

// ICV_AP0R<n> (Interrupt Controller Virtual Active Priorities Group 0 Registers)
// Provides information about virtual Group 0 active priorities.
namespace icv_ap0r<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_ap0r<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_ap0r<n>, val) }
}

// ICV_AP1R<n> (Interrupt Controller Virtual Active Priorities Group 1 Registers)
// Provides information about virtual Group 1 active priorities.
namespace icv_ap1r<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_ap1r<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_ap1r<n>, val) }
}

// ICV_BPR0 (Interrupt Controller Virtual Binary Point Register 0)
// Defines the point at which the priority value fields split into two parts, the group priority field and the subpriority field. The group priority field determines virtual Group 0 interrupt preemption.
namespace icv_bpr0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_bpr0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_bpr0, val) }

	namespace binarypoint
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_bpr0, 0x7, 0) }
		inline uint32_t get(uint32_t icv_bpr0_val) noexcept { GET_BITFIELD_FUNC(icv_bpr0_val, 0x7, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_bpr0, value, 0x7, 0) }
		inline uint32_t set(uint32_t icv_bpr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_bpr0, value, 0x7, 0) }
	}
}

// ICV_BPR1 (Interrupt Controller Virtual Binary Point Register 1)
// Defines the point at which the priority value fields split into two parts, the group priority field and the subpriority field. The group priority field determines virtual Group 1 interrupt preemption.
namespace icv_bpr1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_bpr1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_bpr1, val) }

	namespace binarypoint
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_bpr1, 0x7, 0) }
		inline uint32_t get(uint32_t icv_bpr1_val) noexcept { GET_BITFIELD_FUNC(icv_bpr1_val, 0x7, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_bpr1, value, 0x7, 0) }
		inline uint32_t set(uint32_t icv_bpr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_bpr1, value, 0x7, 0) }
	}
}

// ICV_CTLR (Interrupt Controller Virtual Control Register)
// Controls aspects of the behavior of the GIC virtual CPU interface and provides information about the features implemented.
namespace icv_ctlr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_ctlr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_ctlr, val) }

	namespace rss
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icv_ctlr, 18) }
		inline uint32_t is_enabled(uint32_t icv_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(icv_ctlr_val, 18) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icv_ctlr, 18) }
		inline uint32_t is_disabled(uint32_t icv_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(icv_ctlr_val, 18) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icv_ctlr, 0x40000) }
		inline uint32_t enable(uint32_t icv_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(icv_ctlr_val, 0x40000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icv_ctlr, 0x40000) }
		inline uint32_t disable(uint32_t icv_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icv_ctlr_val, 0x40000) }
	}

	namespace a3v
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icv_ctlr, 15) }
		inline uint32_t is_enabled(uint32_t icv_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(icv_ctlr_val, 15) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icv_ctlr, 15) }
		inline uint32_t is_disabled(uint32_t icv_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(icv_ctlr_val, 15) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icv_ctlr, 0x8000) }
		inline uint32_t enable(uint32_t icv_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(icv_ctlr_val, 0x8000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icv_ctlr, 0x8000) }
		inline uint32_t disable(uint32_t icv_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icv_ctlr_val, 0x8000) }
	}

	namespace seis
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icv_ctlr, 14) }
		inline uint32_t is_enabled(uint32_t icv_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(icv_ctlr_val, 14) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icv_ctlr, 14) }
		inline uint32_t is_disabled(uint32_t icv_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(icv_ctlr_val, 14) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icv_ctlr, 0x4000) }
		inline uint32_t enable(uint32_t icv_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(icv_ctlr_val, 0x4000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icv_ctlr, 0x4000) }
		inline uint32_t disable(uint32_t icv_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icv_ctlr_val, 0x4000) }
	}

	namespace idbits
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_ctlr, 0x3800, 11) }
		inline uint32_t get(uint32_t icv_ctlr_val) noexcept { GET_BITFIELD_FUNC(icv_ctlr_val, 0x3800, 11) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_ctlr, value, 0x3800, 11) }
		inline uint32_t set(uint32_t icv_ctlr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_ctlr, value, 0x3800, 11) }
	}

	namespace pribits
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_ctlr, 0x700, 8) }
		inline uint32_t get(uint32_t icv_ctlr_val) noexcept { GET_BITFIELD_FUNC(icv_ctlr_val, 0x700, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_ctlr, value, 0x700, 8) }
		inline uint32_t set(uint32_t icv_ctlr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_ctlr, value, 0x700, 8) }
	}

	namespace eoimode
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icv_ctlr, 1) }
		inline uint32_t is_enabled(uint32_t icv_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(icv_ctlr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icv_ctlr, 1) }
		inline uint32_t is_disabled(uint32_t icv_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(icv_ctlr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icv_ctlr, 0x2) }
		inline uint32_t enable(uint32_t icv_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(icv_ctlr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icv_ctlr, 0x2) }
		inline uint32_t disable(uint32_t icv_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icv_ctlr_val, 0x2) }
	}

	namespace cbpr
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icv_ctlr, 0) }
		inline uint32_t is_enabled(uint32_t icv_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(icv_ctlr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icv_ctlr, 0) }
		inline uint32_t is_disabled(uint32_t icv_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(icv_ctlr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icv_ctlr, 0x1) }
		inline uint32_t enable(uint32_t icv_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(icv_ctlr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icv_ctlr, 0x1) }
		inline uint32_t disable(uint32_t icv_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icv_ctlr_val, 0x1) }
	}
}

// ICV_DIR (Interrupt Controller Deactivate Virtual Interrupt Register)
// When interrupt priority drop is separated from interrupt deactivation, a write to this register deactivates the specified virtual interrupt.
namespace icv_dir
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_dir) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_dir, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_dir, 0xffffff, 0) }
		inline uint32_t get(uint32_t icv_dir_val) noexcept { GET_BITFIELD_FUNC(icv_dir_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_dir, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icv_dir, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_dir, value, 0xffffff, 0) }
	}
}

// ICV_EOIR0 (Interrupt Controller Virtual End Of Interrupt Register 0)
// A PE writes to this register to inform the CPU interface that it has completed the processing of the specified virtual Group 0 interrupt.
namespace icv_eoir0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_eoir0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_eoir0, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_eoir0, 0xffffff, 0) }
		inline uint32_t get(uint32_t icv_eoir0_val) noexcept { GET_BITFIELD_FUNC(icv_eoir0_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_eoir0, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icv_eoir0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_eoir0, value, 0xffffff, 0) }
	}
}

// ICV_EOIR1 (Interrupt Controller Virtual End Of Interrupt Register 1)
// A PE writes to this register to inform the CPU interface that it has completed the processing of the specified virtual Group 1 interrupt.
namespace icv_eoir1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_eoir1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_eoir1, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_eoir1, 0xffffff, 0) }
		inline uint32_t get(uint32_t icv_eoir1_val) noexcept { GET_BITFIELD_FUNC(icv_eoir1_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_eoir1, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icv_eoir1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_eoir1, value, 0xffffff, 0) }
	}
}

// ICV_HPPIR0 (Interrupt Controller Virtual Highest Priority Pending Interrupt Register 0)
// Indicates the highest priority pending virtual Group 0 interrupt on the virtual CPU interface.
namespace icv_hppir0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_hppir0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_hppir0, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_hppir0, 0xffffff, 0) }
		inline uint32_t get(uint32_t icv_hppir0_val) noexcept { GET_BITFIELD_FUNC(icv_hppir0_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_hppir0, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icv_hppir0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_hppir0, value, 0xffffff, 0) }
	}
}

// ICV_HPPIR1 (Interrupt Controller Virtual Highest Priority Pending Interrupt Register 1)
// Indicates the highest priority pending virtual Group 1 interrupt on the virtual CPU interface.
namespace icv_hppir1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_hppir1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_hppir1, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_hppir1, 0xffffff, 0) }
		inline uint32_t get(uint32_t icv_hppir1_val) noexcept { GET_BITFIELD_FUNC(icv_hppir1_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_hppir1, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icv_hppir1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_hppir1, value, 0xffffff, 0) }
	}
}

// ICV_IAR0 (Interrupt Controller Virtual Interrupt Acknowledge Register 0)
// The PE reads this register to obtain the INTID of the signaled virtual Group 0 interrupt. This read acts as an acknowledge for the interrupt.
namespace icv_iar0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_iar0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_iar0, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_iar0, 0xffffff, 0) }
		inline uint32_t get(uint32_t icv_iar0_val) noexcept { GET_BITFIELD_FUNC(icv_iar0_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_iar0, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icv_iar0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_iar0, value, 0xffffff, 0) }
	}
}

// ICV_IAR1 (Interrupt Controller Virtual Interrupt Acknowledge Register 1)
// The PE reads this register to obtain the INTID of the signaled virtual Group 1 interrupt. This read acts as an acknowledge for the interrupt.
namespace icv_iar1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_iar1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_iar1, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_iar1, 0xffffff, 0) }
		inline uint32_t get(uint32_t icv_iar1_val) noexcept { GET_BITFIELD_FUNC(icv_iar1_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_iar1, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icv_iar1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_iar1, value, 0xffffff, 0) }
	}
}

// ICV_IGRPEN0 (Interrupt Controller Virtual Interrupt Group 0 Enable register)
// Controls whether virtual Group 0 interrupts are enabled or not.
namespace icv_igrpen0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_igrpen0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_igrpen0, val) }

	namespace enable
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icv_igrpen0, 0) }
		inline uint32_t is_enabled(uint32_t icv_igrpen0_val) noexcept { IS_BIT_ENABLED_FUNC(icv_igrpen0_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icv_igrpen0, 0) }
		inline uint32_t is_disabled(uint32_t icv_igrpen0_val) noexcept { IS_BIT_DISABLED_FUNC(icv_igrpen0_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icv_igrpen0, 0x1) }
		inline uint32_t enable(uint32_t icv_igrpen0_val) noexcept { SET_BITS_BY_MASK_FUNC(icv_igrpen0_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icv_igrpen0, 0x1) }
		inline uint32_t disable(uint32_t icv_igrpen0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icv_igrpen0_val, 0x1) }
	}
}

// ICV_IGRPEN1 (Interrupt Controller Virtual Interrupt Group 1 Enable register)
// Controls whether virtual Group 1 interrupts are enabled for the current Security state.
namespace icv_igrpen1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_igrpen1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_igrpen1, val) }

	namespace enable
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icv_igrpen1, 0) }
		inline uint32_t is_enabled(uint32_t icv_igrpen1_val) noexcept { IS_BIT_ENABLED_FUNC(icv_igrpen1_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icv_igrpen1, 0) }
		inline uint32_t is_disabled(uint32_t icv_igrpen1_val) noexcept { IS_BIT_DISABLED_FUNC(icv_igrpen1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icv_igrpen1, 0x1) }
		inline uint32_t enable(uint32_t icv_igrpen1_val) noexcept { SET_BITS_BY_MASK_FUNC(icv_igrpen1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icv_igrpen1, 0x1) }
		inline uint32_t disable(uint32_t icv_igrpen1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icv_igrpen1_val, 0x1) }
	}
}

// ICV_PMR (Interrupt Controller Virtual Interrupt Priority Mask Register)
// Provides a virtual interrupt priority filter. Only virtual interrupts with a higher priority than the value in this register are signaled to the PE.
namespace icv_pmr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_pmr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_pmr, val) }

	namespace priority
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_pmr, 0xff, 0) }
		inline uint32_t get(uint32_t icv_pmr_val) noexcept { GET_BITFIELD_FUNC(icv_pmr_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_pmr, value, 0xff, 0) }
		inline uint32_t set(uint32_t icv_pmr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_pmr, value, 0xff, 0) }
	}
}

// ICV_RPR (Interrupt Controller Virtual Running Priority Register)
// Indicates the Running priority of the virtual CPU interface.
namespace icv_rpr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_rpr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_rpr, val) }

	namespace priority
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_rpr, 0xff, 0) }
		inline uint32_t get(uint32_t icv_rpr_val) noexcept { GET_BITFIELD_FUNC(icv_rpr_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_rpr, value, 0xff, 0) }
		inline uint32_t set(uint32_t icv_rpr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_rpr, value, 0xff, 0) }
	}
}

// ID_AFR0 (Auxiliary Feature Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_afr0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_afr0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_afr0, val) }
}

// ID_DFR0 (Debug Feature Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_dfr0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_dfr0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_dfr0, val) }

	namespace perfmon
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_dfr0, 0xf000000, 24) }
		inline uint32_t get(uint32_t id_dfr0_val) noexcept { GET_BITFIELD_FUNC(id_dfr0_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_dfr0, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t id_dfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_dfr0, value, 0xf000000, 24) }
	}

	namespace mprofdbg
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_dfr0, 0xf00000, 20) }
		inline uint32_t get(uint32_t id_dfr0_val) noexcept { GET_BITFIELD_FUNC(id_dfr0_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_dfr0, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t id_dfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_dfr0, value, 0xf00000, 20) }
	}

	namespace mmaptrc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_dfr0, 0xf0000, 16) }
		inline uint32_t get(uint32_t id_dfr0_val) noexcept { GET_BITFIELD_FUNC(id_dfr0_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_dfr0, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t id_dfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_dfr0, value, 0xf0000, 16) }
	}

	namespace coptrc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_dfr0, 0xf000, 12) }
		inline uint32_t get(uint32_t id_dfr0_val) noexcept { GET_BITFIELD_FUNC(id_dfr0_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_dfr0, value, 0xf000, 12) }
		inline uint32_t set(uint32_t id_dfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_dfr0, value, 0xf000, 12) }
	}

	namespace mmapdbg
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_dfr0, 0xf00, 8) }
		inline uint32_t get(uint32_t id_dfr0_val) noexcept { GET_BITFIELD_FUNC(id_dfr0_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_dfr0, value, 0xf00, 8) }
		inline uint32_t set(uint32_t id_dfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_dfr0, value, 0xf00, 8) }
	}

	namespace copsdbg
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_dfr0, 0xf0, 4) }
		inline uint32_t get(uint32_t id_dfr0_val) noexcept { GET_BITFIELD_FUNC(id_dfr0_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_dfr0, value, 0xf0, 4) }
		inline uint32_t set(uint32_t id_dfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_dfr0, value, 0xf0, 4) }
	}

	namespace copdbg
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_dfr0, 0xf, 0) }
		inline uint32_t get(uint32_t id_dfr0_val) noexcept { GET_BITFIELD_FUNC(id_dfr0_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_dfr0, value, 0xf, 0) }
		inline uint32_t set(uint32_t id_dfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_dfr0, value, 0xf, 0) }
	}
}

// ID_ISAR0 (Instruction Set Attribute Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_isar0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_isar0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_isar0, val) }

	namespace divide
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar0, 0xf000000, 24) }
		inline uint32_t get(uint32_t id_isar0_val) noexcept { GET_BITFIELD_FUNC(id_isar0_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar0, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t id_isar0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar0, value, 0xf000000, 24) }
	}

	namespace debug
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar0, 0xf00000, 20) }
		inline uint32_t get(uint32_t id_isar0_val) noexcept { GET_BITFIELD_FUNC(id_isar0_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar0, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t id_isar0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar0, value, 0xf00000, 20) }
	}

	namespace coproc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar0, 0xf0000, 16) }
		inline uint32_t get(uint32_t id_isar0_val) noexcept { GET_BITFIELD_FUNC(id_isar0_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar0, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t id_isar0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar0, value, 0xf0000, 16) }
	}

	namespace cmpbranch
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar0, 0xf000, 12) }
		inline uint32_t get(uint32_t id_isar0_val) noexcept { GET_BITFIELD_FUNC(id_isar0_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar0, value, 0xf000, 12) }
		inline uint32_t set(uint32_t id_isar0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar0, value, 0xf000, 12) }
	}

	namespace bitfield
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar0, 0xf00, 8) }
		inline uint32_t get(uint32_t id_isar0_val) noexcept { GET_BITFIELD_FUNC(id_isar0_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar0, value, 0xf00, 8) }
		inline uint32_t set(uint32_t id_isar0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar0, value, 0xf00, 8) }
	}

	namespace bitcount
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar0, 0xf0, 4) }
		inline uint32_t get(uint32_t id_isar0_val) noexcept { GET_BITFIELD_FUNC(id_isar0_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar0, value, 0xf0, 4) }
		inline uint32_t set(uint32_t id_isar0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar0, value, 0xf0, 4) }
	}

	namespace swap
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar0, 0xf, 0) }
		inline uint32_t get(uint32_t id_isar0_val) noexcept { GET_BITFIELD_FUNC(id_isar0_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar0, value, 0xf, 0) }
		inline uint32_t set(uint32_t id_isar0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar0, value, 0xf, 0) }
	}
}

// ID_ISAR1 (Instruction Set Attribute Register 1)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_isar1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_isar1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_isar1, val) }

	namespace jazelle
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar1, 0xf0000000, 28) }
		inline uint32_t get(uint32_t id_isar1_val) noexcept { GET_BITFIELD_FUNC(id_isar1_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar1, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t id_isar1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar1, value, 0xf0000000, 28) }
	}

	namespace interwork
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar1, 0xf000000, 24) }
		inline uint32_t get(uint32_t id_isar1_val) noexcept { GET_BITFIELD_FUNC(id_isar1_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar1, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t id_isar1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar1, value, 0xf000000, 24) }
	}

	namespace immediate
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar1, 0xf00000, 20) }
		inline uint32_t get(uint32_t id_isar1_val) noexcept { GET_BITFIELD_FUNC(id_isar1_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar1, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t id_isar1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar1, value, 0xf00000, 20) }
	}

	namespace ifthen
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar1, 0xf0000, 16) }
		inline uint32_t get(uint32_t id_isar1_val) noexcept { GET_BITFIELD_FUNC(id_isar1_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar1, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t id_isar1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar1, value, 0xf0000, 16) }
	}

	namespace extend
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar1, 0xf000, 12) }
		inline uint32_t get(uint32_t id_isar1_val) noexcept { GET_BITFIELD_FUNC(id_isar1_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar1, value, 0xf000, 12) }
		inline uint32_t set(uint32_t id_isar1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar1, value, 0xf000, 12) }
	}

	namespace except_ar
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar1, 0xf00, 8) }
		inline uint32_t get(uint32_t id_isar1_val) noexcept { GET_BITFIELD_FUNC(id_isar1_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar1, value, 0xf00, 8) }
		inline uint32_t set(uint32_t id_isar1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar1, value, 0xf00, 8) }
	}

	namespace except
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar1, 0xf0, 4) }
		inline uint32_t get(uint32_t id_isar1_val) noexcept { GET_BITFIELD_FUNC(id_isar1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t id_isar1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar1, value, 0xf0, 4) }
	}

	namespace endian
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar1, 0xf, 0) }
		inline uint32_t get(uint32_t id_isar1_val) noexcept { GET_BITFIELD_FUNC(id_isar1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar1, value, 0xf, 0) }
		inline uint32_t set(uint32_t id_isar1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar1, value, 0xf, 0) }
	}
}

// ID_ISAR2 (Instruction Set Attribute Register 2)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_isar2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_isar2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_isar2, val) }

	namespace reversal
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar2, 0xf0000000, 28) }
		inline uint32_t get(uint32_t id_isar2_val) noexcept { GET_BITFIELD_FUNC(id_isar2_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar2, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t id_isar2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar2, value, 0xf0000000, 28) }
	}

	namespace psr_ar
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar2, 0xf000000, 24) }
		inline uint32_t get(uint32_t id_isar2_val) noexcept { GET_BITFIELD_FUNC(id_isar2_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar2, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t id_isar2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar2, value, 0xf000000, 24) }
	}

	namespace multu
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar2, 0xf00000, 20) }
		inline uint32_t get(uint32_t id_isar2_val) noexcept { GET_BITFIELD_FUNC(id_isar2_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar2, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t id_isar2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar2, value, 0xf00000, 20) }
	}

	namespace mults
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar2, 0xf0000, 16) }
		inline uint32_t get(uint32_t id_isar2_val) noexcept { GET_BITFIELD_FUNC(id_isar2_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar2, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t id_isar2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar2, value, 0xf0000, 16) }
	}

	namespace mult
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar2, 0xf000, 12) }
		inline uint32_t get(uint32_t id_isar2_val) noexcept { GET_BITFIELD_FUNC(id_isar2_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar2, value, 0xf000, 12) }
		inline uint32_t set(uint32_t id_isar2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar2, value, 0xf000, 12) }
	}

	namespace multiaccessint
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar2, 0xf00, 8) }
		inline uint32_t get(uint32_t id_isar2_val) noexcept { GET_BITFIELD_FUNC(id_isar2_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar2, value, 0xf00, 8) }
		inline uint32_t set(uint32_t id_isar2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar2, value, 0xf00, 8) }
	}

	namespace memhint
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar2, 0xf0, 4) }
		inline uint32_t get(uint32_t id_isar2_val) noexcept { GET_BITFIELD_FUNC(id_isar2_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar2, value, 0xf0, 4) }
		inline uint32_t set(uint32_t id_isar2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar2, value, 0xf0, 4) }
	}

	namespace loadstore
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar2, 0xf, 0) }
		inline uint32_t get(uint32_t id_isar2_val) noexcept { GET_BITFIELD_FUNC(id_isar2_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar2, value, 0xf, 0) }
		inline uint32_t set(uint32_t id_isar2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar2, value, 0xf, 0) }
	}
}

// ID_ISAR3 (Instruction Set Attribute Register 3)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_isar3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_isar3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_isar3, val) }

	namespace t32ee
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar3, 0xf0000000, 28) }
		inline uint32_t get(uint32_t id_isar3_val) noexcept { GET_BITFIELD_FUNC(id_isar3_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar3, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t id_isar3, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar3, value, 0xf0000000, 28) }
	}

	namespace truenop
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar3, 0xf000000, 24) }
		inline uint32_t get(uint32_t id_isar3_val) noexcept { GET_BITFIELD_FUNC(id_isar3_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar3, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t id_isar3, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar3, value, 0xf000000, 24) }
	}

	namespace t32copy
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar3, 0xf00000, 20) }
		inline uint32_t get(uint32_t id_isar3_val) noexcept { GET_BITFIELD_FUNC(id_isar3_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar3, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t id_isar3, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar3, value, 0xf00000, 20) }
	}

	namespace tabbranch
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar3, 0xf0000, 16) }
		inline uint32_t get(uint32_t id_isar3_val) noexcept { GET_BITFIELD_FUNC(id_isar3_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar3, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t id_isar3, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar3, value, 0xf0000, 16) }
	}

	namespace synchprim
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar3, 0xf000, 12) }
		inline uint32_t get(uint32_t id_isar3_val) noexcept { GET_BITFIELD_FUNC(id_isar3_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar3, value, 0xf000, 12) }
		inline uint32_t set(uint32_t id_isar3, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar3, value, 0xf000, 12) }
	}

	namespace svc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar3, 0xf00, 8) }
		inline uint32_t get(uint32_t id_isar3_val) noexcept { GET_BITFIELD_FUNC(id_isar3_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar3, value, 0xf00, 8) }
		inline uint32_t set(uint32_t id_isar3, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar3, value, 0xf00, 8) }
	}

	namespace simd
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar3, 0xf0, 4) }
		inline uint32_t get(uint32_t id_isar3_val) noexcept { GET_BITFIELD_FUNC(id_isar3_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar3, value, 0xf0, 4) }
		inline uint32_t set(uint32_t id_isar3, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar3, value, 0xf0, 4) }
	}

	namespace saturate
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar3, 0xf, 0) }
		inline uint32_t get(uint32_t id_isar3_val) noexcept { GET_BITFIELD_FUNC(id_isar3_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar3, value, 0xf, 0) }
		inline uint32_t set(uint32_t id_isar3, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar3, value, 0xf, 0) }
	}
}

// ID_ISAR4 (Instruction Set Attribute Register 4)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_isar4
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_isar4) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_isar4, val) }

	namespace swp_frac
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar4, 0xf0000000, 28) }
		inline uint32_t get(uint32_t id_isar4_val) noexcept { GET_BITFIELD_FUNC(id_isar4_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar4, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t id_isar4, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar4, value, 0xf0000000, 28) }
	}

	namespace psr_m
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar4, 0xf000000, 24) }
		inline uint32_t get(uint32_t id_isar4_val) noexcept { GET_BITFIELD_FUNC(id_isar4_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar4, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t id_isar4, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar4, value, 0xf000000, 24) }
	}

	namespace synchprim_frac
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar4, 0xf00000, 20) }
		inline uint32_t get(uint32_t id_isar4_val) noexcept { GET_BITFIELD_FUNC(id_isar4_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar4, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t id_isar4, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar4, value, 0xf00000, 20) }
	}

	namespace barrier
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar4, 0xf0000, 16) }
		inline uint32_t get(uint32_t id_isar4_val) noexcept { GET_BITFIELD_FUNC(id_isar4_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar4, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t id_isar4, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar4, value, 0xf0000, 16) }
	}

	namespace smc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar4, 0xf000, 12) }
		inline uint32_t get(uint32_t id_isar4_val) noexcept { GET_BITFIELD_FUNC(id_isar4_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar4, value, 0xf000, 12) }
		inline uint32_t set(uint32_t id_isar4, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar4, value, 0xf000, 12) }
	}

	namespace writeback
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar4, 0xf00, 8) }
		inline uint32_t get(uint32_t id_isar4_val) noexcept { GET_BITFIELD_FUNC(id_isar4_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar4, value, 0xf00, 8) }
		inline uint32_t set(uint32_t id_isar4, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar4, value, 0xf00, 8) }
	}

	namespace withshifts
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar4, 0xf0, 4) }
		inline uint32_t get(uint32_t id_isar4_val) noexcept { GET_BITFIELD_FUNC(id_isar4_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar4, value, 0xf0, 4) }
		inline uint32_t set(uint32_t id_isar4, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar4, value, 0xf0, 4) }
	}

	namespace unpriv
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar4, 0xf, 0) }
		inline uint32_t get(uint32_t id_isar4_val) noexcept { GET_BITFIELD_FUNC(id_isar4_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar4, value, 0xf, 0) }
		inline uint32_t set(uint32_t id_isar4, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar4, value, 0xf, 0) }
	}
}

// ID_ISAR5 (Instruction Set Attribute Register 5)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_isar5
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_isar5) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_isar5, val) }
}

// ID_ISAR6 (Instruction Set Attribute Register 6)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_isar6
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_isar6) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_isar6, val) }
}

// ID_MMFR0 (Memory Model Feature Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_mmfr0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_mmfr0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_mmfr0, val) }

	namespace innershr
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr0, 0xf0000000, 28) }
		inline uint32_t get(uint32_t id_mmfr0_val) noexcept { GET_BITFIELD_FUNC(id_mmfr0_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr0, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t id_mmfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr0, value, 0xf0000000, 28) }
	}

	namespace fcse
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr0, 0xf000000, 24) }
		inline uint32_t get(uint32_t id_mmfr0_val) noexcept { GET_BITFIELD_FUNC(id_mmfr0_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr0, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t id_mmfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr0, value, 0xf000000, 24) }
	}

	namespace auxreg
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr0, 0xf00000, 20) }
		inline uint32_t get(uint32_t id_mmfr0_val) noexcept { GET_BITFIELD_FUNC(id_mmfr0_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr0, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t id_mmfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr0, value, 0xf00000, 20) }
	}

	namespace tcm
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr0, 0xf0000, 16) }
		inline uint32_t get(uint32_t id_mmfr0_val) noexcept { GET_BITFIELD_FUNC(id_mmfr0_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr0, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t id_mmfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr0, value, 0xf0000, 16) }
	}

	namespace sharelvl
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr0, 0xf000, 12) }
		inline uint32_t get(uint32_t id_mmfr0_val) noexcept { GET_BITFIELD_FUNC(id_mmfr0_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr0, value, 0xf000, 12) }
		inline uint32_t set(uint32_t id_mmfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr0, value, 0xf000, 12) }
	}

	namespace outershr
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr0, 0xf00, 8) }
		inline uint32_t get(uint32_t id_mmfr0_val) noexcept { GET_BITFIELD_FUNC(id_mmfr0_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr0, value, 0xf00, 8) }
		inline uint32_t set(uint32_t id_mmfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr0, value, 0xf00, 8) }
	}

	namespace pmsa
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr0, 0xf0, 4) }
		inline uint32_t get(uint32_t id_mmfr0_val) noexcept { GET_BITFIELD_FUNC(id_mmfr0_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr0, value, 0xf0, 4) }
		inline uint32_t set(uint32_t id_mmfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr0, value, 0xf0, 4) }
	}

	namespace vmsa
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr0, 0xf, 0) }
		inline uint32_t get(uint32_t id_mmfr0_val) noexcept { GET_BITFIELD_FUNC(id_mmfr0_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr0, value, 0xf, 0) }
		inline uint32_t set(uint32_t id_mmfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr0, value, 0xf, 0) }
	}
}

// ID_MMFR1 (Memory Model Feature Register 1)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_mmfr1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_mmfr1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_mmfr1, val) }

	namespace bpred
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr1, 0xf0000000, 28) }
		inline uint32_t get(uint32_t id_mmfr1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr1_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr1, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t id_mmfr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr1, value, 0xf0000000, 28) }
	}

	namespace l1tstcln
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr1, 0xf000000, 24) }
		inline uint32_t get(uint32_t id_mmfr1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr1_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr1, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t id_mmfr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr1, value, 0xf000000, 24) }
	}

	namespace l1uni
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr1, 0xf00000, 20) }
		inline uint32_t get(uint32_t id_mmfr1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr1_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr1, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t id_mmfr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr1, value, 0xf00000, 20) }
	}

	namespace l1hvd
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr1, 0xf0000, 16) }
		inline uint32_t get(uint32_t id_mmfr1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr1_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr1, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t id_mmfr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr1, value, 0xf0000, 16) }
	}

	namespace l1unisw
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr1, 0xf000, 12) }
		inline uint32_t get(uint32_t id_mmfr1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr1_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr1, value, 0xf000, 12) }
		inline uint32_t set(uint32_t id_mmfr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr1, value, 0xf000, 12) }
	}

	namespace l1hvdsw
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr1, 0xf00, 8) }
		inline uint32_t get(uint32_t id_mmfr1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr1_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr1, value, 0xf00, 8) }
		inline uint32_t set(uint32_t id_mmfr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr1, value, 0xf00, 8) }
	}

	namespace l1univa
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr1, 0xf0, 4) }
		inline uint32_t get(uint32_t id_mmfr1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t id_mmfr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr1, value, 0xf0, 4) }
	}

	namespace l1hvdva
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr1, 0xf, 0) }
		inline uint32_t get(uint32_t id_mmfr1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr1, value, 0xf, 0) }
		inline uint32_t set(uint32_t id_mmfr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr1, value, 0xf, 0) }
	}
}

// ID_MMFR2 (Memory Model Feature Register 2)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_mmfr2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_mmfr2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_mmfr2, val) }

	namespace hwaccflg
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr2, 0xf0000000, 28) }
		inline uint32_t get(uint32_t id_mmfr2_val) noexcept { GET_BITFIELD_FUNC(id_mmfr2_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr2, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t id_mmfr2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr2, value, 0xf0000000, 28) }
	}

	namespace wfistall
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr2, 0xf000000, 24) }
		inline uint32_t get(uint32_t id_mmfr2_val) noexcept { GET_BITFIELD_FUNC(id_mmfr2_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr2, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t id_mmfr2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr2, value, 0xf000000, 24) }
	}

	namespace membarr
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr2, 0xf00000, 20) }
		inline uint32_t get(uint32_t id_mmfr2_val) noexcept { GET_BITFIELD_FUNC(id_mmfr2_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr2, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t id_mmfr2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr2, value, 0xf00000, 20) }
	}

	namespace unitlb
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr2, 0xf0000, 16) }
		inline uint32_t get(uint32_t id_mmfr2_val) noexcept { GET_BITFIELD_FUNC(id_mmfr2_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr2, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t id_mmfr2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr2, value, 0xf0000, 16) }
	}

	namespace hvdtlb
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr2, 0xf000, 12) }
		inline uint32_t get(uint32_t id_mmfr2_val) noexcept { GET_BITFIELD_FUNC(id_mmfr2_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr2, value, 0xf000, 12) }
		inline uint32_t set(uint32_t id_mmfr2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr2, value, 0xf000, 12) }
	}

	namespace l1hvdrng
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr2, 0xf00, 8) }
		inline uint32_t get(uint32_t id_mmfr2_val) noexcept { GET_BITFIELD_FUNC(id_mmfr2_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr2, value, 0xf00, 8) }
		inline uint32_t set(uint32_t id_mmfr2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr2, value, 0xf00, 8) }
	}

	namespace l1hvdbg
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr2, 0xf0, 4) }
		inline uint32_t get(uint32_t id_mmfr2_val) noexcept { GET_BITFIELD_FUNC(id_mmfr2_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr2, value, 0xf0, 4) }
		inline uint32_t set(uint32_t id_mmfr2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr2, value, 0xf0, 4) }
	}

	namespace l1hvdfg
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr2, 0xf, 0) }
		inline uint32_t get(uint32_t id_mmfr2_val) noexcept { GET_BITFIELD_FUNC(id_mmfr2_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr2, value, 0xf, 0) }
		inline uint32_t set(uint32_t id_mmfr2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr2, value, 0xf, 0) }
	}
}

// ID_MMFR3 (Memory Model Feature Register 3)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_mmfr3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_mmfr3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_mmfr3, val) }
}

// ID_MMFR4 (Memory Model Feature Register 4)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_mmfr4
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_mmfr4) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_mmfr4, val) }
}

// ID_PFR0 (Processor Feature Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_pfr0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_pfr0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_pfr0, val) }

	namespace ras
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr0, 0xf0000000, 28) }
		inline uint32_t get(uint32_t id_pfr0_val) noexcept { GET_BITFIELD_FUNC(id_pfr0_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr0, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t id_pfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr0, value, 0xf0000000, 28) }
	}

	namespace state3
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr0, 0xf000, 12) }
		inline uint32_t get(uint32_t id_pfr0_val) noexcept { GET_BITFIELD_FUNC(id_pfr0_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr0, value, 0xf000, 12) }
		inline uint32_t set(uint32_t id_pfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr0, value, 0xf000, 12) }
	}

	namespace state2
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr0, 0xf00, 8) }
		inline uint32_t get(uint32_t id_pfr0_val) noexcept { GET_BITFIELD_FUNC(id_pfr0_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr0, value, 0xf00, 8) }
		inline uint32_t set(uint32_t id_pfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr0, value, 0xf00, 8) }
	}

	namespace state1
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr0, 0xf0, 4) }
		inline uint32_t get(uint32_t id_pfr0_val) noexcept { GET_BITFIELD_FUNC(id_pfr0_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr0, value, 0xf0, 4) }
		inline uint32_t set(uint32_t id_pfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr0, value, 0xf0, 4) }
	}

	namespace state0
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr0, 0xf, 0) }
		inline uint32_t get(uint32_t id_pfr0_val) noexcept { GET_BITFIELD_FUNC(id_pfr0_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr0, value, 0xf, 0) }
		inline uint32_t set(uint32_t id_pfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr0, value, 0xf, 0) }
	}
}

// ID_PFR1 (Processor Feature Register 1)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_pfr1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_pfr1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_pfr1, val) }

	namespace gic
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr1, 0xf0000000, 28) }
		inline uint32_t get(uint32_t id_pfr1_val) noexcept { GET_BITFIELD_FUNC(id_pfr1_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr1, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t id_pfr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr1, value, 0xf0000000, 28) }
	}

	namespace virt_frac
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr1, 0xf000000, 24) }
		inline uint32_t get(uint32_t id_pfr1_val) noexcept { GET_BITFIELD_FUNC(id_pfr1_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr1, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t id_pfr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr1, value, 0xf000000, 24) }
	}

	namespace sec_frac
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr1, 0xf00000, 20) }
		inline uint32_t get(uint32_t id_pfr1_val) noexcept { GET_BITFIELD_FUNC(id_pfr1_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr1, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t id_pfr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr1, value, 0xf00000, 20) }
	}

	namespace gentimer
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr1, 0xf0000, 16) }
		inline uint32_t get(uint32_t id_pfr1_val) noexcept { GET_BITFIELD_FUNC(id_pfr1_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr1, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t id_pfr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr1, value, 0xf0000, 16) }
	}

	namespace virtualization
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr1, 0xf000, 12) }
		inline uint32_t get(uint32_t id_pfr1_val) noexcept { GET_BITFIELD_FUNC(id_pfr1_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr1, value, 0xf000, 12) }
		inline uint32_t set(uint32_t id_pfr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr1, value, 0xf000, 12) }
	}

	namespace mprogmod
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr1, 0xf00, 8) }
		inline uint32_t get(uint32_t id_pfr1_val) noexcept { GET_BITFIELD_FUNC(id_pfr1_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr1, value, 0xf00, 8) }
		inline uint32_t set(uint32_t id_pfr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr1, value, 0xf00, 8) }
	}

	namespace security
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr1, 0xf0, 4) }
		inline uint32_t get(uint32_t id_pfr1_val) noexcept { GET_BITFIELD_FUNC(id_pfr1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t id_pfr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr1, value, 0xf0, 4) }
	}

	namespace progmod
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr1, 0xf, 0) }
		inline uint32_t get(uint32_t id_pfr1_val) noexcept { GET_BITFIELD_FUNC(id_pfr1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr1, value, 0xf, 0) }
		inline uint32_t set(uint32_t id_pfr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr1, value, 0xf, 0) }
	}
}

// IFAR (Instruction Fault Address Register)
// Holds the virtual address of the faulting address that caused a synchronous Prefetch Abort exception.
namespace ifar
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ifar) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ifar, val) }

	namespace va_of_faulting_address_of_synchronous_prefetch_abort_exception
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ifar, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ifar_val) noexcept { GET_BITFIELD_FUNC(ifar_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ifar, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ifar, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ifar, value, 0xffffffff, 0) }
	}
}

// IFSR (Instruction Fault Status Register)
// Holds status information about the last instruction fault.
namespace ifsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ifsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ifsr, val) }

	// Fieldset valid when: TTBCR.EAE==0
	namespace fieldset_1
	{
		namespace fnv
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ifsr, 16) }
			inline uint32_t is_enabled(uint32_t ifsr_val) noexcept { IS_BIT_ENABLED_FUNC(ifsr_val, 16) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ifsr, 16) }
			inline uint32_t is_disabled(uint32_t ifsr_val) noexcept { IS_BIT_DISABLED_FUNC(ifsr_val, 16) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ifsr, 0x10000) }
			inline uint32_t enable(uint32_t ifsr_val) noexcept { SET_BITS_BY_MASK_FUNC(ifsr_val, 0x10000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ifsr, 0x10000) }
			inline uint32_t disable(uint32_t ifsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ifsr_val, 0x10000) }
		}

		namespace ext
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ifsr, 12) }
			inline uint32_t is_enabled(uint32_t ifsr_val) noexcept { IS_BIT_ENABLED_FUNC(ifsr_val, 12) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ifsr, 12) }
			inline uint32_t is_disabled(uint32_t ifsr_val) noexcept { IS_BIT_DISABLED_FUNC(ifsr_val, 12) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ifsr, 0x1000) }
			inline uint32_t enable(uint32_t ifsr_val) noexcept { SET_BITS_BY_MASK_FUNC(ifsr_val, 0x1000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ifsr, 0x1000) }
			inline uint32_t disable(uint32_t ifsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ifsr_val, 0x1000) }
		}

		namespace fs_4_
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ifsr, 10) }
			inline uint32_t is_enabled(uint32_t ifsr_val) noexcept { IS_BIT_ENABLED_FUNC(ifsr_val, 10) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ifsr, 10) }
			inline uint32_t is_disabled(uint32_t ifsr_val) noexcept { IS_BIT_DISABLED_FUNC(ifsr_val, 10) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ifsr, 0x400) }
			inline uint32_t enable(uint32_t ifsr_val) noexcept { SET_BITS_BY_MASK_FUNC(ifsr_val, 0x400) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ifsr, 0x400) }
			inline uint32_t disable(uint32_t ifsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ifsr_val, 0x400) }
		}

		namespace lpae
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ifsr, 9) }
			inline uint32_t is_enabled(uint32_t ifsr_val) noexcept { IS_BIT_ENABLED_FUNC(ifsr_val, 9) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ifsr, 9) }
			inline uint32_t is_disabled(uint32_t ifsr_val) noexcept { IS_BIT_DISABLED_FUNC(ifsr_val, 9) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ifsr, 0x200) }
			inline uint32_t enable(uint32_t ifsr_val) noexcept { SET_BITS_BY_MASK_FUNC(ifsr_val, 0x200) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ifsr, 0x200) }
			inline uint32_t disable(uint32_t ifsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ifsr_val, 0x200) }
		}

		namespace fs_3:0_
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ifsr, 0xf, 0) }
			inline uint32_t get(uint32_t ifsr_val) noexcept { GET_BITFIELD_FUNC(ifsr_val, 0xf, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ifsr, value, 0xf, 0) }
			inline uint32_t set(uint32_t ifsr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ifsr, value, 0xf, 0) }
		}
	}

	// Fieldset valid when: TTBCR.EAE==1
	namespace fieldset_2
	{
		namespace fnv
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ifsr, 16) }
			inline uint32_t is_enabled(uint32_t ifsr_val) noexcept { IS_BIT_ENABLED_FUNC(ifsr_val, 16) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ifsr, 16) }
			inline uint32_t is_disabled(uint32_t ifsr_val) noexcept { IS_BIT_DISABLED_FUNC(ifsr_val, 16) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ifsr, 0x10000) }
			inline uint32_t enable(uint32_t ifsr_val) noexcept { SET_BITS_BY_MASK_FUNC(ifsr_val, 0x10000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ifsr, 0x10000) }
			inline uint32_t disable(uint32_t ifsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ifsr_val, 0x10000) }
		}

		namespace ext
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ifsr, 12) }
			inline uint32_t is_enabled(uint32_t ifsr_val) noexcept { IS_BIT_ENABLED_FUNC(ifsr_val, 12) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ifsr, 12) }
			inline uint32_t is_disabled(uint32_t ifsr_val) noexcept { IS_BIT_DISABLED_FUNC(ifsr_val, 12) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ifsr, 0x1000) }
			inline uint32_t enable(uint32_t ifsr_val) noexcept { SET_BITS_BY_MASK_FUNC(ifsr_val, 0x1000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ifsr, 0x1000) }
			inline uint32_t disable(uint32_t ifsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ifsr_val, 0x1000) }
		}

		namespace lpae
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ifsr, 9) }
			inline uint32_t is_enabled(uint32_t ifsr_val) noexcept { IS_BIT_ENABLED_FUNC(ifsr_val, 9) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ifsr, 9) }
			inline uint32_t is_disabled(uint32_t ifsr_val) noexcept { IS_BIT_DISABLED_FUNC(ifsr_val, 9) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ifsr, 0x200) }
			inline uint32_t enable(uint32_t ifsr_val) noexcept { SET_BITS_BY_MASK_FUNC(ifsr_val, 0x200) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ifsr, 0x200) }
			inline uint32_t disable(uint32_t ifsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ifsr_val, 0x200) }
		}

		namespace status
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ifsr, 0x3f, 0) }
			inline uint32_t get(uint32_t ifsr_val) noexcept { GET_BITFIELD_FUNC(ifsr_val, 0x3f, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ifsr, value, 0x3f, 0) }
			inline uint32_t set(uint32_t ifsr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ifsr, value, 0x3f, 0) }
		}
	}
}

// ISR (Interrupt Status Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace isr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(isr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(isr, val) }

	namespace a
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(isr, 8) }
		inline uint32_t is_enabled(uint32_t isr_val) noexcept { IS_BIT_ENABLED_FUNC(isr_val, 8) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(isr, 8) }
		inline uint32_t is_disabled(uint32_t isr_val) noexcept { IS_BIT_DISABLED_FUNC(isr_val, 8) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(isr, 0x100) }
		inline uint32_t enable(uint32_t isr_val) noexcept { SET_BITS_BY_MASK_FUNC(isr_val, 0x100) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(isr, 0x100) }
		inline uint32_t disable(uint32_t isr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(isr_val, 0x100) }
	}

	namespace i
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(isr, 7) }
		inline uint32_t is_enabled(uint32_t isr_val) noexcept { IS_BIT_ENABLED_FUNC(isr_val, 7) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(isr, 7) }
		inline uint32_t is_disabled(uint32_t isr_val) noexcept { IS_BIT_DISABLED_FUNC(isr_val, 7) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(isr, 0x80) }
		inline uint32_t enable(uint32_t isr_val) noexcept { SET_BITS_BY_MASK_FUNC(isr_val, 0x80) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(isr, 0x80) }
		inline uint32_t disable(uint32_t isr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(isr_val, 0x80) }
	}

	namespace f
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(isr, 6) }
		inline uint32_t is_enabled(uint32_t isr_val) noexcept { IS_BIT_ENABLED_FUNC(isr_val, 6) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(isr, 6) }
		inline uint32_t is_disabled(uint32_t isr_val) noexcept { IS_BIT_DISABLED_FUNC(isr_val, 6) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(isr, 0x40) }
		inline uint32_t enable(uint32_t isr_val) noexcept { SET_BITS_BY_MASK_FUNC(isr_val, 0x40) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(isr, 0x40) }
		inline uint32_t disable(uint32_t isr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(isr_val, 0x40) }
	}
}

// ITLBIALL (Instruction TLB Invalidate All)
// See the ARMv8 architecture reference manual for a description of this register
namespace itlbiall
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(itlbiall) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(itlbiall, val) }
}

// ITLBIASID (Instruction TLB Invalidate by ASID match)
// See the ARMv8 architecture reference manual for a description of this register
namespace itlbiasid
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(itlbiasid) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(itlbiasid, val) }

	namespace asid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(itlbiasid, 0xff, 0) }
		inline uint32_t get(uint32_t itlbiasid_val) noexcept { GET_BITFIELD_FUNC(itlbiasid_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(itlbiasid, value, 0xff, 0) }
		inline uint32_t set(uint32_t itlbiasid, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(itlbiasid, value, 0xff, 0) }
	}
}

// ITLBIMVA (Instruction TLB Invalidate by VA)
// See the ARMv8 architecture reference manual for a description of this register
namespace itlbimva
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(itlbimva) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(itlbimva, val) }

	namespace va
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(itlbimva, 0xfffff000, 12) }
		inline uint32_t get(uint32_t itlbimva_val) noexcept { GET_BITFIELD_FUNC(itlbimva_val, 0xfffff000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(itlbimva, value, 0xfffff000, 12) }
		inline uint32_t set(uint32_t itlbimva, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(itlbimva, value, 0xfffff000, 12) }
	}

	namespace asid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(itlbimva, 0xff, 0) }
		inline uint32_t get(uint32_t itlbimva_val) noexcept { GET_BITFIELD_FUNC(itlbimva_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(itlbimva, value, 0xff, 0) }
		inline uint32_t set(uint32_t itlbimva, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(itlbimva, value, 0xff, 0) }
	}
}

// JIDR (Jazelle ID Register)
// A Jazelle register, which identified the Jazelle architecture version.
namespace jidr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(jidr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(jidr, val) }
}

// JMCR (Jazelle Main Configuration Register)
// A Jazelle register, which provides control of the Jazelle extension.
namespace jmcr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(jmcr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(jmcr, val) }
}

// JOSCR (Jazelle OS Control Register)
// A Jazelle register, which provides operating system control of the Jazelle Extension.
namespace joscr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(joscr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(joscr, val) }
}

// MAIR0 (Memory Attribute Indirection Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace mair0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(mair0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(mair0, val) }

	namespace attr_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mair0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t mair0_val) noexcept { GET_BITFIELD_FUNC(mair0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mair0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t mair0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mair0, value, 0xffffffff, 0) }
	}
}

// MAIR1 (Memory Attribute Indirection Register 1)
// See the ARMv8 architecture reference manual for a description of this register
namespace mair1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(mair1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(mair1, val) }

	namespace attr_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mair1, 0xffffffff, 0) }
		inline uint32_t get(uint32_t mair1_val) noexcept { GET_BITFIELD_FUNC(mair1_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mair1, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t mair1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mair1, value, 0xffffffff, 0) }
	}
}

// MIDR (Main ID Register)
// Provides identification information for the PE, including an implementer code for the device and a device ID number.
namespace midr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(midr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(midr, val) }

	namespace implementer
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(midr, 0xff000000, 24) }
		inline uint32_t get(uint32_t midr_val) noexcept { GET_BITFIELD_FUNC(midr_val, 0xff000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(midr, value, 0xff000000, 24) }
		inline uint32_t set(uint32_t midr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(midr, value, 0xff000000, 24) }
	}

	namespace variant
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(midr, 0xf00000, 20) }
		inline uint32_t get(uint32_t midr_val) noexcept { GET_BITFIELD_FUNC(midr_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(midr, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t midr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(midr, value, 0xf00000, 20) }
	}

	namespace architecture
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(midr, 0xf0000, 16) }
		inline uint32_t get(uint32_t midr_val) noexcept { GET_BITFIELD_FUNC(midr_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(midr, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t midr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(midr, value, 0xf0000, 16) }
	}

	namespace partnum
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(midr, 0xfff0, 4) }
		inline uint32_t get(uint32_t midr_val) noexcept { GET_BITFIELD_FUNC(midr_val, 0xfff0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(midr, value, 0xfff0, 4) }
		inline uint32_t set(uint32_t midr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(midr, value, 0xfff0, 4) }
	}

	namespace revision
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(midr, 0xf, 0) }
		inline uint32_t get(uint32_t midr_val) noexcept { GET_BITFIELD_FUNC(midr_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(midr, value, 0xf, 0) }
		inline uint32_t set(uint32_t midr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(midr, value, 0xf, 0) }
	}
}

// MPIDR (Multiprocessor Affinity Register)
// In a multiprocessor system, provides an additional PE identification mechanism for scheduling purposes.
namespace mpidr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(mpidr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(mpidr, val) }

	namespace m
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(mpidr, 31) }
		inline uint32_t is_enabled(uint32_t mpidr_val) noexcept { IS_BIT_ENABLED_FUNC(mpidr_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(mpidr, 31) }
		inline uint32_t is_disabled(uint32_t mpidr_val) noexcept { IS_BIT_DISABLED_FUNC(mpidr_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(mpidr, 0x80000000) }
		inline uint32_t enable(uint32_t mpidr_val) noexcept { SET_BITS_BY_MASK_FUNC(mpidr_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(mpidr, 0x80000000) }
		inline uint32_t disable(uint32_t mpidr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(mpidr_val, 0x80000000) }
	}

	namespace u
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(mpidr, 30) }
		inline uint32_t is_enabled(uint32_t mpidr_val) noexcept { IS_BIT_ENABLED_FUNC(mpidr_val, 30) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(mpidr, 30) }
		inline uint32_t is_disabled(uint32_t mpidr_val) noexcept { IS_BIT_DISABLED_FUNC(mpidr_val, 30) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(mpidr, 0x40000000) }
		inline uint32_t enable(uint32_t mpidr_val) noexcept { SET_BITS_BY_MASK_FUNC(mpidr_val, 0x40000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(mpidr, 0x40000000) }
		inline uint32_t disable(uint32_t mpidr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(mpidr_val, 0x40000000) }
	}

	namespace mt
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(mpidr, 24) }
		inline uint32_t is_enabled(uint32_t mpidr_val) noexcept { IS_BIT_ENABLED_FUNC(mpidr_val, 24) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(mpidr, 24) }
		inline uint32_t is_disabled(uint32_t mpidr_val) noexcept { IS_BIT_DISABLED_FUNC(mpidr_val, 24) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(mpidr, 0x1000000) }
		inline uint32_t enable(uint32_t mpidr_val) noexcept { SET_BITS_BY_MASK_FUNC(mpidr_val, 0x1000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(mpidr, 0x1000000) }
		inline uint32_t disable(uint32_t mpidr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(mpidr_val, 0x1000000) }
	}

	namespace aff2
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mpidr, 0xff0000, 16) }
		inline uint32_t get(uint32_t mpidr_val) noexcept { GET_BITFIELD_FUNC(mpidr_val, 0xff0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mpidr, value, 0xff0000, 16) }
		inline uint32_t set(uint32_t mpidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mpidr, value, 0xff0000, 16) }
	}

	namespace aff1
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mpidr, 0xff00, 8) }
		inline uint32_t get(uint32_t mpidr_val) noexcept { GET_BITFIELD_FUNC(mpidr_val, 0xff00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mpidr, value, 0xff00, 8) }
		inline uint32_t set(uint32_t mpidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mpidr, value, 0xff00, 8) }
	}

	namespace aff0
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mpidr, 0xff, 0) }
		inline uint32_t get(uint32_t mpidr_val) noexcept { GET_BITFIELD_FUNC(mpidr_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mpidr, value, 0xff, 0) }
		inline uint32_t set(uint32_t mpidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mpidr, value, 0xff, 0) }
	}
}

// MVBAR (Monitor Vector Base Address Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace mvbar
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(mvbar) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(mvbar, val) }

	namespace vector_base_address
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvbar, 0xffffffe0, 5) }
		inline uint32_t get(uint32_t mvbar_val) noexcept { GET_BITFIELD_FUNC(mvbar_val, 0xffffffe0, 5) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvbar, value, 0xffffffe0, 5) }
		inline uint32_t set(uint32_t mvbar, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvbar, value, 0xffffffe0, 5) }
	}
}

// MVFR0 (Media and VFP Feature Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace mvfr0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(mvfr0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(mvfr0, val) }

	namespace fpround
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr0, 0xf0000000, 28) }
		inline uint32_t get(uint32_t mvfr0_val) noexcept { GET_BITFIELD_FUNC(mvfr0_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr0, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t mvfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr0, value, 0xf0000000, 28) }
	}

	namespace fpshvec
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr0, 0xf000000, 24) }
		inline uint32_t get(uint32_t mvfr0_val) noexcept { GET_BITFIELD_FUNC(mvfr0_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr0, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t mvfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr0, value, 0xf000000, 24) }
	}

	namespace fpsqrt
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr0, 0xf00000, 20) }
		inline uint32_t get(uint32_t mvfr0_val) noexcept { GET_BITFIELD_FUNC(mvfr0_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr0, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t mvfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr0, value, 0xf00000, 20) }
	}

	namespace fpdivide
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr0, 0xf0000, 16) }
		inline uint32_t get(uint32_t mvfr0_val) noexcept { GET_BITFIELD_FUNC(mvfr0_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr0, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t mvfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr0, value, 0xf0000, 16) }
	}

	namespace fptrap
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr0, 0xf000, 12) }
		inline uint32_t get(uint32_t mvfr0_val) noexcept { GET_BITFIELD_FUNC(mvfr0_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr0, value, 0xf000, 12) }
		inline uint32_t set(uint32_t mvfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr0, value, 0xf000, 12) }
	}

	namespace fpdp
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr0, 0xf00, 8) }
		inline uint32_t get(uint32_t mvfr0_val) noexcept { GET_BITFIELD_FUNC(mvfr0_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr0, value, 0xf00, 8) }
		inline uint32_t set(uint32_t mvfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr0, value, 0xf00, 8) }
	}

	namespace fpsp
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr0, 0xf0, 4) }
		inline uint32_t get(uint32_t mvfr0_val) noexcept { GET_BITFIELD_FUNC(mvfr0_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr0, value, 0xf0, 4) }
		inline uint32_t set(uint32_t mvfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr0, value, 0xf0, 4) }
	}

	namespace simdreg
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr0, 0xf, 0) }
		inline uint32_t get(uint32_t mvfr0_val) noexcept { GET_BITFIELD_FUNC(mvfr0_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr0, value, 0xf, 0) }
		inline uint32_t set(uint32_t mvfr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr0, value, 0xf, 0) }
	}
}

// MVFR1 (Media and VFP Feature Register 1)
// See the ARMv8 architecture reference manual for a description of this register
namespace mvfr1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(mvfr1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(mvfr1, val) }

	namespace simdfmac
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr1, 0xf0000000, 28) }
		inline uint32_t get(uint32_t mvfr1_val) noexcept { GET_BITFIELD_FUNC(mvfr1_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr1, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t mvfr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr1, value, 0xf0000000, 28) }
	}

	namespace fphp
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr1, 0xf000000, 24) }
		inline uint32_t get(uint32_t mvfr1_val) noexcept { GET_BITFIELD_FUNC(mvfr1_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr1, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t mvfr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr1, value, 0xf000000, 24) }
	}

	namespace simdhp
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr1, 0xf00000, 20) }
		inline uint32_t get(uint32_t mvfr1_val) noexcept { GET_BITFIELD_FUNC(mvfr1_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr1, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t mvfr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr1, value, 0xf00000, 20) }
	}

	namespace simdsp
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr1, 0xf0000, 16) }
		inline uint32_t get(uint32_t mvfr1_val) noexcept { GET_BITFIELD_FUNC(mvfr1_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr1, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t mvfr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr1, value, 0xf0000, 16) }
	}

	namespace simdint
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr1, 0xf000, 12) }
		inline uint32_t get(uint32_t mvfr1_val) noexcept { GET_BITFIELD_FUNC(mvfr1_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr1, value, 0xf000, 12) }
		inline uint32_t set(uint32_t mvfr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr1, value, 0xf000, 12) }
	}

	namespace simdls
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr1, 0xf00, 8) }
		inline uint32_t get(uint32_t mvfr1_val) noexcept { GET_BITFIELD_FUNC(mvfr1_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr1, value, 0xf00, 8) }
		inline uint32_t set(uint32_t mvfr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr1, value, 0xf00, 8) }
	}

	namespace fpdnan
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr1, 0xf0, 4) }
		inline uint32_t get(uint32_t mvfr1_val) noexcept { GET_BITFIELD_FUNC(mvfr1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t mvfr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr1, value, 0xf0, 4) }
	}

	namespace fpftz
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr1, 0xf, 0) }
		inline uint32_t get(uint32_t mvfr1_val) noexcept { GET_BITFIELD_FUNC(mvfr1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr1, value, 0xf, 0) }
		inline uint32_t set(uint32_t mvfr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr1, value, 0xf, 0) }
	}
}

// MVFR2 (Media and VFP Feature Register 2)
// See the ARMv8 architecture reference manual for a description of this register
namespace mvfr2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(mvfr2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(mvfr2, val) }

	namespace fpmisc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr2, 0xf0, 4) }
		inline uint32_t get(uint32_t mvfr2_val) noexcept { GET_BITFIELD_FUNC(mvfr2_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr2, value, 0xf0, 4) }
		inline uint32_t set(uint32_t mvfr2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr2, value, 0xf0, 4) }
	}

	namespace simdmisc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr2, 0xf, 0) }
		inline uint32_t get(uint32_t mvfr2_val) noexcept { GET_BITFIELD_FUNC(mvfr2_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr2, value, 0xf, 0) }
		inline uint32_t set(uint32_t mvfr2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr2, value, 0xf, 0) }
	}
}

// NMRR (Normal Memory Remap Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace nmrr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(nmrr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(nmrr, val) }

	namespace or_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(nmrr, 0xffff0000, 16) }
		inline uint32_t get(uint32_t nmrr_val) noexcept { GET_BITFIELD_FUNC(nmrr_val, 0xffff0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(nmrr, value, 0xffff0000, 16) }
		inline uint32_t set(uint32_t nmrr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(nmrr, value, 0xffff0000, 16) }
	}

	namespace ir_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(nmrr, 0xffff, 0) }
		inline uint32_t get(uint32_t nmrr_val) noexcept { GET_BITFIELD_FUNC(nmrr_val, 0xffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(nmrr, value, 0xffff, 0) }
		inline uint32_t set(uint32_t nmrr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(nmrr, value, 0xffff, 0) }
	}
}

// NSACR (Non-Secure Access Control Register)
// When EL3 is implemented and can use AArch32, defines the Non-secure access permissions to Trace, Advanced SIMD and floating-point functionality. Also includes IMPLEMENTATION DEFINED bits that can define Non-secure access permissions for IMPLEMENTATION DEFINED functionality.
namespace nsacr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(nsacr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(nsacr, val) }

	namespace nstrcdis
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(nsacr, 20) }
		inline uint32_t is_enabled(uint32_t nsacr_val) noexcept { IS_BIT_ENABLED_FUNC(nsacr_val, 20) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(nsacr, 20) }
		inline uint32_t is_disabled(uint32_t nsacr_val) noexcept { IS_BIT_DISABLED_FUNC(nsacr_val, 20) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(nsacr, 0x100000) }
		inline uint32_t enable(uint32_t nsacr_val) noexcept { SET_BITS_BY_MASK_FUNC(nsacr_val, 0x100000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(nsacr, 0x100000) }
		inline uint32_t disable(uint32_t nsacr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(nsacr_val, 0x100000) }
	}

	namespace nsasedis
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(nsacr, 15) }
		inline uint32_t is_enabled(uint32_t nsacr_val) noexcept { IS_BIT_ENABLED_FUNC(nsacr_val, 15) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(nsacr, 15) }
		inline uint32_t is_disabled(uint32_t nsacr_val) noexcept { IS_BIT_DISABLED_FUNC(nsacr_val, 15) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(nsacr, 0x8000) }
		inline uint32_t enable(uint32_t nsacr_val) noexcept { SET_BITS_BY_MASK_FUNC(nsacr_val, 0x8000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(nsacr, 0x8000) }
		inline uint32_t disable(uint32_t nsacr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(nsacr_val, 0x8000) }
	}

	namespace cp11
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(nsacr, 11) }
		inline uint32_t is_enabled(uint32_t nsacr_val) noexcept { IS_BIT_ENABLED_FUNC(nsacr_val, 11) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(nsacr, 11) }
		inline uint32_t is_disabled(uint32_t nsacr_val) noexcept { IS_BIT_DISABLED_FUNC(nsacr_val, 11) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(nsacr, 0x800) }
		inline uint32_t enable(uint32_t nsacr_val) noexcept { SET_BITS_BY_MASK_FUNC(nsacr_val, 0x800) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(nsacr, 0x800) }
		inline uint32_t disable(uint32_t nsacr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(nsacr_val, 0x800) }
	}

	namespace cp10
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(nsacr, 10) }
		inline uint32_t is_enabled(uint32_t nsacr_val) noexcept { IS_BIT_ENABLED_FUNC(nsacr_val, 10) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(nsacr, 10) }
		inline uint32_t is_disabled(uint32_t nsacr_val) noexcept { IS_BIT_DISABLED_FUNC(nsacr_val, 10) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(nsacr, 0x400) }
		inline uint32_t enable(uint32_t nsacr_val) noexcept { SET_BITS_BY_MASK_FUNC(nsacr_val, 0x400) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(nsacr, 0x400) }
		inline uint32_t disable(uint32_t nsacr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(nsacr_val, 0x400) }
	}
}

// PAR (Physical Address Register)
// Returns the output address (OA) from an Address translation instruction that executed successfully, or fault information if the instruction did not execute successfully.
namespace par
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(par) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(par, val) }

	// Fieldset valid when: the instruction returned a 32-bit value to the PAR, PAR.F==0
	namespace fieldset_1
	{
		namespace pa
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(par, 0xfffff000, 12) }
			inline uint32_t get(uint32_t par_val) noexcept { GET_BITFIELD_FUNC(par_val, 0xfffff000, 12) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(par, value, 0xfffff000, 12) }
			inline uint32_t set(uint32_t par, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(par, value, 0xfffff000, 12) }
		}

		namespace lpae
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(par, 11) }
			inline uint32_t is_enabled(uint32_t par_val) noexcept { IS_BIT_ENABLED_FUNC(par_val, 11) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(par, 11) }
			inline uint32_t is_disabled(uint32_t par_val) noexcept { IS_BIT_DISABLED_FUNC(par_val, 11) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(par, 0x800) }
			inline uint32_t enable(uint32_t par_val) noexcept { SET_BITS_BY_MASK_FUNC(par_val, 0x800) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(par, 0x800) }
			inline uint32_t disable(uint32_t par_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(par_val, 0x800) }
		}

		namespace nos
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(par, 10) }
			inline uint32_t is_enabled(uint32_t par_val) noexcept { IS_BIT_ENABLED_FUNC(par_val, 10) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(par, 10) }
			inline uint32_t is_disabled(uint32_t par_val) noexcept { IS_BIT_DISABLED_FUNC(par_val, 10) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(par, 0x400) }
			inline uint32_t enable(uint32_t par_val) noexcept { SET_BITS_BY_MASK_FUNC(par_val, 0x400) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(par, 0x400) }
			inline uint32_t disable(uint32_t par_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(par_val, 0x400) }
		}

		namespace ns
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(par, 9) }
			inline uint32_t is_enabled(uint32_t par_val) noexcept { IS_BIT_ENABLED_FUNC(par_val, 9) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(par, 9) }
			inline uint32_t is_disabled(uint32_t par_val) noexcept { IS_BIT_DISABLED_FUNC(par_val, 9) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(par, 0x200) }
			inline uint32_t enable(uint32_t par_val) noexcept { SET_BITS_BY_MASK_FUNC(par_val, 0x200) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(par, 0x200) }
			inline uint32_t disable(uint32_t par_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(par_val, 0x200) }
		}

		namespace imp_def
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(par, 8) }
			inline uint32_t is_enabled(uint32_t par_val) noexcept { IS_BIT_ENABLED_FUNC(par_val, 8) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(par, 8) }
			inline uint32_t is_disabled(uint32_t par_val) noexcept { IS_BIT_DISABLED_FUNC(par_val, 8) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(par, 0x100) }
			inline uint32_t enable(uint32_t par_val) noexcept { SET_BITS_BY_MASK_FUNC(par_val, 0x100) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(par, 0x100) }
			inline uint32_t disable(uint32_t par_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(par_val, 0x100) }
		}

		namespace sh
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(par, 7) }
			inline uint32_t is_enabled(uint32_t par_val) noexcept { IS_BIT_ENABLED_FUNC(par_val, 7) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(par, 7) }
			inline uint32_t is_disabled(uint32_t par_val) noexcept { IS_BIT_DISABLED_FUNC(par_val, 7) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(par, 0x80) }
			inline uint32_t enable(uint32_t par_val) noexcept { SET_BITS_BY_MASK_FUNC(par_val, 0x80) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(par, 0x80) }
			inline uint32_t disable(uint32_t par_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(par_val, 0x80) }
		}

		namespace inner_2:0_
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(par, 0x70, 4) }
			inline uint32_t get(uint32_t par_val) noexcept { GET_BITFIELD_FUNC(par_val, 0x70, 4) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(par, value, 0x70, 4) }
			inline uint32_t set(uint32_t par, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(par, value, 0x70, 4) }
		}

		namespace outer_1:0_
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(par, 0xc, 2) }
			inline uint32_t get(uint32_t par_val) noexcept { GET_BITFIELD_FUNC(par_val, 0xc, 2) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(par, value, 0xc, 2) }
			inline uint32_t set(uint32_t par, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(par, value, 0xc, 2) }
		}

		namespace ss
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(par, 1) }
			inline uint32_t is_enabled(uint32_t par_val) noexcept { IS_BIT_ENABLED_FUNC(par_val, 1) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(par, 1) }
			inline uint32_t is_disabled(uint32_t par_val) noexcept { IS_BIT_DISABLED_FUNC(par_val, 1) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(par, 0x2) }
			inline uint32_t enable(uint32_t par_val) noexcept { SET_BITS_BY_MASK_FUNC(par_val, 0x2) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(par, 0x2) }
			inline uint32_t disable(uint32_t par_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(par_val, 0x2) }
		}

		namespace f
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(par, 0) }
			inline uint32_t is_enabled(uint32_t par_val) noexcept { IS_BIT_ENABLED_FUNC(par_val, 0) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(par, 0) }
			inline uint32_t is_disabled(uint32_t par_val) noexcept { IS_BIT_DISABLED_FUNC(par_val, 0) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(par, 0x1) }
			inline uint32_t enable(uint32_t par_val) noexcept { SET_BITS_BY_MASK_FUNC(par_val, 0x1) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(par, 0x1) }
			inline uint32_t disable(uint32_t par_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(par_val, 0x1) }
		}
	}

	// Fieldset valid when: the instruction returned a 32-bit value to the PAR, PAR.F==1
	namespace fieldset_2
	{
		namespace imp_def
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(par, 0xffff0000, 16) }
			inline uint32_t get(uint32_t par_val) noexcept { GET_BITFIELD_FUNC(par_val, 0xffff0000, 16) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(par, value, 0xffff0000, 16) }
			inline uint32_t set(uint32_t par, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(par, value, 0xffff0000, 16) }
		}

		namespace lpae
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(par, 11) }
			inline uint32_t is_enabled(uint32_t par_val) noexcept { IS_BIT_ENABLED_FUNC(par_val, 11) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(par, 11) }
			inline uint32_t is_disabled(uint32_t par_val) noexcept { IS_BIT_DISABLED_FUNC(par_val, 11) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(par, 0x800) }
			inline uint32_t enable(uint32_t par_val) noexcept { SET_BITS_BY_MASK_FUNC(par_val, 0x800) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(par, 0x800) }
			inline uint32_t disable(uint32_t par_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(par_val, 0x800) }
		}

		namespace fs
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(par, 0x7e, 1) }
			inline uint32_t get(uint32_t par_val) noexcept { GET_BITFIELD_FUNC(par_val, 0x7e, 1) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(par, value, 0x7e, 1) }
			inline uint32_t set(uint32_t par, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(par, value, 0x7e, 1) }
		}

		namespace f
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(par, 0) }
			inline uint32_t is_enabled(uint32_t par_val) noexcept { IS_BIT_ENABLED_FUNC(par_val, 0) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(par, 0) }
			inline uint32_t is_disabled(uint32_t par_val) noexcept { IS_BIT_DISABLED_FUNC(par_val, 0) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(par, 0x1) }
			inline uint32_t enable(uint32_t par_val) noexcept { SET_BITS_BY_MASK_FUNC(par_val, 0x1) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(par, 0x1) }
			inline uint32_t disable(uint32_t par_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(par_val, 0x1) }
		}
	}

	// Fieldset valid when: the instruction returned a 64-bit value to the PAR, PAR.F==0
	namespace fieldset_3
	{	}

	// Fieldset valid when: the instruction returned a 64-bit value to the PAR, PAR.F==1
	namespace fieldset_4
	{	}
}

// PMCCFILTR (Performance Monitors Cycle Count Filter Register)
// Determines the modes in which the Cycle Counter, PMCCNTR, increments.
namespace pmccfiltr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmccfiltr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmccfiltr, val) }

	namespace p
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmccfiltr, 31) }
		inline uint32_t is_enabled(uint32_t pmccfiltr_val) noexcept { IS_BIT_ENABLED_FUNC(pmccfiltr_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmccfiltr, 31) }
		inline uint32_t is_disabled(uint32_t pmccfiltr_val) noexcept { IS_BIT_DISABLED_FUNC(pmccfiltr_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr, 0x80000000) }
		inline uint32_t enable(uint32_t pmccfiltr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmccfiltr_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr, 0x80000000) }
		inline uint32_t disable(uint32_t pmccfiltr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmccfiltr_val, 0x80000000) }
	}

	namespace u
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmccfiltr, 30) }
		inline uint32_t is_enabled(uint32_t pmccfiltr_val) noexcept { IS_BIT_ENABLED_FUNC(pmccfiltr_val, 30) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmccfiltr, 30) }
		inline uint32_t is_disabled(uint32_t pmccfiltr_val) noexcept { IS_BIT_DISABLED_FUNC(pmccfiltr_val, 30) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr, 0x40000000) }
		inline uint32_t enable(uint32_t pmccfiltr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmccfiltr_val, 0x40000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr, 0x40000000) }
		inline uint32_t disable(uint32_t pmccfiltr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmccfiltr_val, 0x40000000) }
	}

	namespace nsk
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmccfiltr, 29) }
		inline uint32_t is_enabled(uint32_t pmccfiltr_val) noexcept { IS_BIT_ENABLED_FUNC(pmccfiltr_val, 29) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmccfiltr, 29) }
		inline uint32_t is_disabled(uint32_t pmccfiltr_val) noexcept { IS_BIT_DISABLED_FUNC(pmccfiltr_val, 29) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr, 0x20000000) }
		inline uint32_t enable(uint32_t pmccfiltr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmccfiltr_val, 0x20000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr, 0x20000000) }
		inline uint32_t disable(uint32_t pmccfiltr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmccfiltr_val, 0x20000000) }
	}

	namespace nsu
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmccfiltr, 28) }
		inline uint32_t is_enabled(uint32_t pmccfiltr_val) noexcept { IS_BIT_ENABLED_FUNC(pmccfiltr_val, 28) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmccfiltr, 28) }
		inline uint32_t is_disabled(uint32_t pmccfiltr_val) noexcept { IS_BIT_DISABLED_FUNC(pmccfiltr_val, 28) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr, 0x10000000) }
		inline uint32_t enable(uint32_t pmccfiltr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmccfiltr_val, 0x10000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr, 0x10000000) }
		inline uint32_t disable(uint32_t pmccfiltr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmccfiltr_val, 0x10000000) }
	}

	namespace nsh
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmccfiltr, 27) }
		inline uint32_t is_enabled(uint32_t pmccfiltr_val) noexcept { IS_BIT_ENABLED_FUNC(pmccfiltr_val, 27) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmccfiltr, 27) }
		inline uint32_t is_disabled(uint32_t pmccfiltr_val) noexcept { IS_BIT_DISABLED_FUNC(pmccfiltr_val, 27) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr, 0x8000000) }
		inline uint32_t enable(uint32_t pmccfiltr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmccfiltr_val, 0x8000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr, 0x8000000) }
		inline uint32_t disable(uint32_t pmccfiltr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmccfiltr_val, 0x8000000) }
	}
}

// PMCCNTR (Performance Monitors Cycle Count Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmccntr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmccntr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmccntr, val) }

	// Fieldset valid when: accessing as a 32-bit register
	namespace fieldset_1
	{
		namespace ccnt
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmccntr, 0xffffffff, 0) }
			inline uint32_t get(uint32_t pmccntr_val) noexcept { GET_BITFIELD_FUNC(pmccntr_val, 0xffffffff, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmccntr, value, 0xffffffff, 0) }
			inline uint32_t set(uint32_t pmccntr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmccntr, value, 0xffffffff, 0) }
		}
	}

	// Fieldset valid when: accessing as a 64-bit register
	namespace fieldset_2
	{	}
}

// PMCEID0 (Performance Monitors Common Event Identification register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmceid0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmceid0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmceid0, val) }

	namespace id_31:0_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmceid0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t pmceid0_val) noexcept { GET_BITFIELD_FUNC(pmceid0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmceid0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t pmceid0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmceid0, value, 0xffffffff, 0) }
	}
}

// PMCEID1 (Performance Monitors Common Event Identification register 1)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmceid1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmceid1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmceid1, val) }

	namespace id_63:32_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmceid1, 0xffffffff, 0) }
		inline uint32_t get(uint32_t pmceid1_val) noexcept { GET_BITFIELD_FUNC(pmceid1_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmceid1, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t pmceid1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmceid1, value, 0xffffffff, 0) }
	}
}

// PMCEID2 (Performance Monitors Common Event Identification register 2)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmceid2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmceid2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmceid2, val) }

	namespace idhi_31:0_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmceid2, 0xffffffff, 0) }
		inline uint32_t get(uint32_t pmceid2_val) noexcept { GET_BITFIELD_FUNC(pmceid2_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmceid2, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t pmceid2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmceid2, value, 0xffffffff, 0) }
	}
}

// PMCEID3 (Performance Monitors Common Event Identification register 3)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmceid3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmceid3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmceid3, val) }

	namespace idhi_63:32_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmceid3, 0xffffffff, 0) }
		inline uint32_t get(uint32_t pmceid3_val) noexcept { GET_BITFIELD_FUNC(pmceid3_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmceid3, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t pmceid3, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmceid3, value, 0xffffffff, 0) }
	}
}

// PMCNTENCLR (Performance Monitors Count Enable Clear register)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmcntenclr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmcntenclr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmcntenclr, val) }

	namespace c
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcntenclr, 31) }
		inline uint32_t is_enabled(uint32_t pmcntenclr_val) noexcept { IS_BIT_ENABLED_FUNC(pmcntenclr_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcntenclr, 31) }
		inline uint32_t is_disabled(uint32_t pmcntenclr_val) noexcept { IS_BIT_DISABLED_FUNC(pmcntenclr_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcntenclr, 0x80000000) }
		inline uint32_t enable(uint32_t pmcntenclr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcntenclr_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcntenclr, 0x80000000) }
		inline uint32_t disable(uint32_t pmcntenclr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcntenclr_val, 0x80000000) }
	}

	namespace p_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmcntenclr, 0x7fffffff, 0) }
		inline uint32_t get(uint32_t pmcntenclr_val) noexcept { GET_BITFIELD_FUNC(pmcntenclr_val, 0x7fffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmcntenclr, value, 0x7fffffff, 0) }
		inline uint32_t set(uint32_t pmcntenclr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmcntenclr, value, 0x7fffffff, 0) }
	}
}

// PMCNTENSET (Performance Monitors Count Enable Set register)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmcntenset
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmcntenset) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmcntenset, val) }

	namespace c
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcntenset, 31) }
		inline uint32_t is_enabled(uint32_t pmcntenset_val) noexcept { IS_BIT_ENABLED_FUNC(pmcntenset_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcntenset, 31) }
		inline uint32_t is_disabled(uint32_t pmcntenset_val) noexcept { IS_BIT_DISABLED_FUNC(pmcntenset_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcntenset, 0x80000000) }
		inline uint32_t enable(uint32_t pmcntenset_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcntenset_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcntenset, 0x80000000) }
		inline uint32_t disable(uint32_t pmcntenset_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcntenset_val, 0x80000000) }
	}

	namespace p_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmcntenset, 0x7fffffff, 0) }
		inline uint32_t get(uint32_t pmcntenset_val) noexcept { GET_BITFIELD_FUNC(pmcntenset_val, 0x7fffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmcntenset, value, 0x7fffffff, 0) }
		inline uint32_t set(uint32_t pmcntenset, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmcntenset, value, 0x7fffffff, 0) }
	}
}

// PMCR (Performance Monitors Control Register)
// Provides details of the Performance Monitors implementation, including the number of counters implemented, and configures and controls the counters.
namespace pmcr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmcr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmcr, val) }

	namespace imp
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmcr, 0xff000000, 24) }
		inline uint32_t get(uint32_t pmcr_val) noexcept { GET_BITFIELD_FUNC(pmcr_val, 0xff000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmcr, value, 0xff000000, 24) }
		inline uint32_t set(uint32_t pmcr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmcr, value, 0xff000000, 24) }
	}

	namespace idcode
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmcr, 0xff0000, 16) }
		inline uint32_t get(uint32_t pmcr_val) noexcept { GET_BITFIELD_FUNC(pmcr_val, 0xff0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmcr, value, 0xff0000, 16) }
		inline uint32_t set(uint32_t pmcr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmcr, value, 0xff0000, 16) }
	}

	namespace n
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmcr, 0xf800, 11) }
		inline uint32_t get(uint32_t pmcr_val) noexcept { GET_BITFIELD_FUNC(pmcr_val, 0xf800, 11) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmcr, value, 0xf800, 11) }
		inline uint32_t set(uint32_t pmcr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmcr, value, 0xf800, 11) }
	}

	namespace lc
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcr, 6) }
		inline uint32_t is_enabled(uint32_t pmcr_val) noexcept { IS_BIT_ENABLED_FUNC(pmcr_val, 6) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcr, 6) }
		inline uint32_t is_disabled(uint32_t pmcr_val) noexcept { IS_BIT_DISABLED_FUNC(pmcr_val, 6) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcr, 0x40) }
		inline uint32_t enable(uint32_t pmcr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcr_val, 0x40) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcr, 0x40) }
		inline uint32_t disable(uint32_t pmcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcr_val, 0x40) }
	}

	namespace dp
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcr, 5) }
		inline uint32_t is_enabled(uint32_t pmcr_val) noexcept { IS_BIT_ENABLED_FUNC(pmcr_val, 5) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcr, 5) }
		inline uint32_t is_disabled(uint32_t pmcr_val) noexcept { IS_BIT_DISABLED_FUNC(pmcr_val, 5) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcr, 0x20) }
		inline uint32_t enable(uint32_t pmcr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcr_val, 0x20) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcr, 0x20) }
		inline uint32_t disable(uint32_t pmcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcr_val, 0x20) }
	}

	namespace x
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcr, 4) }
		inline uint32_t is_enabled(uint32_t pmcr_val) noexcept { IS_BIT_ENABLED_FUNC(pmcr_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcr, 4) }
		inline uint32_t is_disabled(uint32_t pmcr_val) noexcept { IS_BIT_DISABLED_FUNC(pmcr_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcr, 0x10) }
		inline uint32_t enable(uint32_t pmcr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcr_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcr, 0x10) }
		inline uint32_t disable(uint32_t pmcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcr_val, 0x10) }
	}

	namespace d
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcr, 3) }
		inline uint32_t is_enabled(uint32_t pmcr_val) noexcept { IS_BIT_ENABLED_FUNC(pmcr_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcr, 3) }
		inline uint32_t is_disabled(uint32_t pmcr_val) noexcept { IS_BIT_DISABLED_FUNC(pmcr_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcr, 0x8) }
		inline uint32_t enable(uint32_t pmcr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcr_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcr, 0x8) }
		inline uint32_t disable(uint32_t pmcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcr_val, 0x8) }
	}

	namespace c
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcr, 2) }
		inline uint32_t is_enabled(uint32_t pmcr_val) noexcept { IS_BIT_ENABLED_FUNC(pmcr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcr, 2) }
		inline uint32_t is_disabled(uint32_t pmcr_val) noexcept { IS_BIT_DISABLED_FUNC(pmcr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcr, 0x4) }
		inline uint32_t enable(uint32_t pmcr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcr, 0x4) }
		inline uint32_t disable(uint32_t pmcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcr_val, 0x4) }
	}

	namespace p
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcr, 1) }
		inline uint32_t is_enabled(uint32_t pmcr_val) noexcept { IS_BIT_ENABLED_FUNC(pmcr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcr, 1) }
		inline uint32_t is_disabled(uint32_t pmcr_val) noexcept { IS_BIT_DISABLED_FUNC(pmcr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcr, 0x2) }
		inline uint32_t enable(uint32_t pmcr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcr, 0x2) }
		inline uint32_t disable(uint32_t pmcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcr_val, 0x2) }
	}

	namespace e
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcr, 0) }
		inline uint32_t is_enabled(uint32_t pmcr_val) noexcept { IS_BIT_ENABLED_FUNC(pmcr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcr, 0) }
		inline uint32_t is_disabled(uint32_t pmcr_val) noexcept { IS_BIT_DISABLED_FUNC(pmcr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcr, 0x1) }
		inline uint32_t enable(uint32_t pmcr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcr, 0x1) }
		inline uint32_t disable(uint32_t pmcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcr_val, 0x1) }
	}
}

// PMEVCNTR<n> (Performance Monitors Event Count Registers)
// Holds event counter n, which counts events, where n is 0 to 30.
namespace pmevcntr<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmevcntr<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmevcntr<n>, val) }

	namespace event_counter_n
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmevcntr<n>, 0xffffffff, 0) }
		inline uint32_t get(uint32_t pmevcntr<n>_val) noexcept { GET_BITFIELD_FUNC(pmevcntr<n>_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmevcntr<n>, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t pmevcntr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmevcntr<n>, value, 0xffffffff, 0) }
	}
}

// PMEVTYPER<n> (Performance Monitors Event Type Registers)
// Configures event counter n, where n is 0 to 30.
namespace pmevtyper<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmevtyper<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmevtyper<n>, val) }
}

// PMINTENCLR (Performance Monitors Interrupt Enable Clear register)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmintenclr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmintenclr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmintenclr, val) }

	namespace c
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmintenclr, 31) }
		inline uint32_t is_enabled(uint32_t pmintenclr_val) noexcept { IS_BIT_ENABLED_FUNC(pmintenclr_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmintenclr, 31) }
		inline uint32_t is_disabled(uint32_t pmintenclr_val) noexcept { IS_BIT_DISABLED_FUNC(pmintenclr_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmintenclr, 0x80000000) }
		inline uint32_t enable(uint32_t pmintenclr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmintenclr_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmintenclr, 0x80000000) }
		inline uint32_t disable(uint32_t pmintenclr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmintenclr_val, 0x80000000) }
	}

	namespace p_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmintenclr, 0x7fffffff, 0) }
		inline uint32_t get(uint32_t pmintenclr_val) noexcept { GET_BITFIELD_FUNC(pmintenclr_val, 0x7fffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmintenclr, value, 0x7fffffff, 0) }
		inline uint32_t set(uint32_t pmintenclr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmintenclr, value, 0x7fffffff, 0) }
	}
}

// PMINTENSET (Performance Monitors Interrupt Enable Set register)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmintenset
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmintenset) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmintenset, val) }

	namespace c
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmintenset, 31) }
		inline uint32_t is_enabled(uint32_t pmintenset_val) noexcept { IS_BIT_ENABLED_FUNC(pmintenset_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmintenset, 31) }
		inline uint32_t is_disabled(uint32_t pmintenset_val) noexcept { IS_BIT_DISABLED_FUNC(pmintenset_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmintenset, 0x80000000) }
		inline uint32_t enable(uint32_t pmintenset_val) noexcept { SET_BITS_BY_MASK_FUNC(pmintenset_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmintenset, 0x80000000) }
		inline uint32_t disable(uint32_t pmintenset_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmintenset_val, 0x80000000) }
	}

	namespace p_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmintenset, 0x7fffffff, 0) }
		inline uint32_t get(uint32_t pmintenset_val) noexcept { GET_BITFIELD_FUNC(pmintenset_val, 0x7fffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmintenset, value, 0x7fffffff, 0) }
		inline uint32_t set(uint32_t pmintenset, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmintenset, value, 0x7fffffff, 0) }
	}
}

// PMOVSR (Performance Monitors Overflow Flag Status Register)
// Contains the state of the overflow bit for the Cycle Count Register, PMCCNTR, and each of the implemented event counters PMEVCNTR<n>. Writing to this register clears these bits.
namespace pmovsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmovsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmovsr, val) }

	namespace c
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmovsr, 31) }
		inline uint32_t is_enabled(uint32_t pmovsr_val) noexcept { IS_BIT_ENABLED_FUNC(pmovsr_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmovsr, 31) }
		inline uint32_t is_disabled(uint32_t pmovsr_val) noexcept { IS_BIT_DISABLED_FUNC(pmovsr_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmovsr, 0x80000000) }
		inline uint32_t enable(uint32_t pmovsr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmovsr_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmovsr, 0x80000000) }
		inline uint32_t disable(uint32_t pmovsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmovsr_val, 0x80000000) }
	}

	namespace p_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmovsr, 0x7fffffff, 0) }
		inline uint32_t get(uint32_t pmovsr_val) noexcept { GET_BITFIELD_FUNC(pmovsr_val, 0x7fffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmovsr, value, 0x7fffffff, 0) }
		inline uint32_t set(uint32_t pmovsr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmovsr, value, 0x7fffffff, 0) }
	}
}

// PMOVSSET (Performance Monitors Overflow Flag Status Set register)
// Sets the state of the overflow bit for the Cycle Count Register, PMCCNTR, and each of the implemented event counters PMEVCNTR<n>.
namespace pmovsset
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmovsset) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmovsset, val) }

	namespace c
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmovsset, 31) }
		inline uint32_t is_enabled(uint32_t pmovsset_val) noexcept { IS_BIT_ENABLED_FUNC(pmovsset_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmovsset, 31) }
		inline uint32_t is_disabled(uint32_t pmovsset_val) noexcept { IS_BIT_DISABLED_FUNC(pmovsset_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmovsset, 0x80000000) }
		inline uint32_t enable(uint32_t pmovsset_val) noexcept { SET_BITS_BY_MASK_FUNC(pmovsset_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmovsset, 0x80000000) }
		inline uint32_t disable(uint32_t pmovsset_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmovsset_val, 0x80000000) }
	}

	namespace p_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmovsset, 0x7fffffff, 0) }
		inline uint32_t get(uint32_t pmovsset_val) noexcept { GET_BITFIELD_FUNC(pmovsset_val, 0x7fffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmovsset, value, 0x7fffffff, 0) }
		inline uint32_t set(uint32_t pmovsset, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmovsset, value, 0x7fffffff, 0) }
	}
}

// PMSELR (Performance Monitors Event Counter Selection Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmselr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmselr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmselr, val) }

	namespace sel
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmselr, 0x1f, 0) }
		inline uint32_t get(uint32_t pmselr_val) noexcept { GET_BITFIELD_FUNC(pmselr_val, 0x1f, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmselr, value, 0x1f, 0) }
		inline uint32_t set(uint32_t pmselr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmselr, value, 0x1f, 0) }
	}
}

// PMSWINC (Performance Monitors Software Increment register)
// Increments a counter that is configured to count the Software increment event, event 
namespace pmswinc
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmswinc) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmswinc, val) }

	namespace p_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmswinc, 0x7fffffff, 0) }
		inline uint32_t get(uint32_t pmswinc_val) noexcept { GET_BITFIELD_FUNC(pmswinc_val, 0x7fffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmswinc, value, 0x7fffffff, 0) }
		inline uint32_t set(uint32_t pmswinc, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmswinc, value, 0x7fffffff, 0) }
	}
}

// PMUSERENR (Performance Monitors User Enable Register)
// Enables or disables User mode access to the Performance Monitors.
namespace pmuserenr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmuserenr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmuserenr, val) }

	namespace er
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmuserenr, 3) }
		inline uint32_t is_enabled(uint32_t pmuserenr_val) noexcept { IS_BIT_ENABLED_FUNC(pmuserenr_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmuserenr, 3) }
		inline uint32_t is_disabled(uint32_t pmuserenr_val) noexcept { IS_BIT_DISABLED_FUNC(pmuserenr_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmuserenr, 0x8) }
		inline uint32_t enable(uint32_t pmuserenr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmuserenr_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmuserenr, 0x8) }
		inline uint32_t disable(uint32_t pmuserenr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmuserenr_val, 0x8) }
	}

	namespace cr
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmuserenr, 2) }
		inline uint32_t is_enabled(uint32_t pmuserenr_val) noexcept { IS_BIT_ENABLED_FUNC(pmuserenr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmuserenr, 2) }
		inline uint32_t is_disabled(uint32_t pmuserenr_val) noexcept { IS_BIT_DISABLED_FUNC(pmuserenr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmuserenr, 0x4) }
		inline uint32_t enable(uint32_t pmuserenr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmuserenr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmuserenr, 0x4) }
		inline uint32_t disable(uint32_t pmuserenr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmuserenr_val, 0x4) }
	}

	namespace sw
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmuserenr, 1) }
		inline uint32_t is_enabled(uint32_t pmuserenr_val) noexcept { IS_BIT_ENABLED_FUNC(pmuserenr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmuserenr, 1) }
		inline uint32_t is_disabled(uint32_t pmuserenr_val) noexcept { IS_BIT_DISABLED_FUNC(pmuserenr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmuserenr, 0x2) }
		inline uint32_t enable(uint32_t pmuserenr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmuserenr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmuserenr, 0x2) }
		inline uint32_t disable(uint32_t pmuserenr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmuserenr_val, 0x2) }
	}

	namespace en
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmuserenr, 0) }
		inline uint32_t is_enabled(uint32_t pmuserenr_val) noexcept { IS_BIT_ENABLED_FUNC(pmuserenr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmuserenr, 0) }
		inline uint32_t is_disabled(uint32_t pmuserenr_val) noexcept { IS_BIT_DISABLED_FUNC(pmuserenr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmuserenr, 0x1) }
		inline uint32_t enable(uint32_t pmuserenr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmuserenr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmuserenr, 0x1) }
		inline uint32_t disable(uint32_t pmuserenr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmuserenr_val, 0x1) }
	}
}

// PMXEVCNTR (Performance Monitors Selected Event Count Register)
// Reads or writes the value of the selected event counter, PMEVCNTR<n>. PMSELR.SEL determines which event counter is selected.
namespace pmxevcntr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmxevcntr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmxevcntr, val) }

	namespace pmevcntr_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmxevcntr, 0xffffffff, 0) }
		inline uint32_t get(uint32_t pmxevcntr_val) noexcept { GET_BITFIELD_FUNC(pmxevcntr_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmxevcntr, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t pmxevcntr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmxevcntr, value, 0xffffffff, 0) }
	}
}

// PMXEVTYPER (Performance Monitors Selected Event Type Register)
// When PMSELR.SEL selects an event counter, this accesses a PMEVTYPER<n> register. When PMSELR.SEL selects the cycle counter, this accesses PMCCFILTR.
namespace pmxevtyper
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmxevtyper) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmxevtyper, val) }

	namespace event_type_register_or_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmxevtyper, 0xffffffff, 0) }
		inline uint32_t get(uint32_t pmxevtyper_val) noexcept { GET_BITFIELD_FUNC(pmxevtyper_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmxevtyper, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t pmxevtyper, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmxevtyper, value, 0xffffffff, 0) }
	}
}

// PRRR (Primary Region Remap Register)
// Controls the top level mapping of the TEX[0], C, and B memory region attributes.
namespace prrr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(prrr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(prrr, val) }

	namespace nos_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(prrr, 0xff000000, 24) }
		inline uint32_t get(uint32_t prrr_val) noexcept { GET_BITFIELD_FUNC(prrr_val, 0xff000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(prrr, value, 0xff000000, 24) }
		inline uint32_t set(uint32_t prrr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(prrr, value, 0xff000000, 24) }
	}

	namespace ns1
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(prrr, 19) }
		inline uint32_t is_enabled(uint32_t prrr_val) noexcept { IS_BIT_ENABLED_FUNC(prrr_val, 19) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(prrr, 19) }
		inline uint32_t is_disabled(uint32_t prrr_val) noexcept { IS_BIT_DISABLED_FUNC(prrr_val, 19) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(prrr, 0x80000) }
		inline uint32_t enable(uint32_t prrr_val) noexcept { SET_BITS_BY_MASK_FUNC(prrr_val, 0x80000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(prrr, 0x80000) }
		inline uint32_t disable(uint32_t prrr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(prrr_val, 0x80000) }
	}

	namespace ns0
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(prrr, 18) }
		inline uint32_t is_enabled(uint32_t prrr_val) noexcept { IS_BIT_ENABLED_FUNC(prrr_val, 18) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(prrr, 18) }
		inline uint32_t is_disabled(uint32_t prrr_val) noexcept { IS_BIT_DISABLED_FUNC(prrr_val, 18) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(prrr, 0x40000) }
		inline uint32_t enable(uint32_t prrr_val) noexcept { SET_BITS_BY_MASK_FUNC(prrr_val, 0x40000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(prrr, 0x40000) }
		inline uint32_t disable(uint32_t prrr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(prrr_val, 0x40000) }
	}

	namespace ds1
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(prrr, 17) }
		inline uint32_t is_enabled(uint32_t prrr_val) noexcept { IS_BIT_ENABLED_FUNC(prrr_val, 17) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(prrr, 17) }
		inline uint32_t is_disabled(uint32_t prrr_val) noexcept { IS_BIT_DISABLED_FUNC(prrr_val, 17) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(prrr, 0x20000) }
		inline uint32_t enable(uint32_t prrr_val) noexcept { SET_BITS_BY_MASK_FUNC(prrr_val, 0x20000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(prrr, 0x20000) }
		inline uint32_t disable(uint32_t prrr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(prrr_val, 0x20000) }
	}

	namespace ds0
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(prrr, 16) }
		inline uint32_t is_enabled(uint32_t prrr_val) noexcept { IS_BIT_ENABLED_FUNC(prrr_val, 16) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(prrr, 16) }
		inline uint32_t is_disabled(uint32_t prrr_val) noexcept { IS_BIT_DISABLED_FUNC(prrr_val, 16) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(prrr, 0x10000) }
		inline uint32_t enable(uint32_t prrr_val) noexcept { SET_BITS_BY_MASK_FUNC(prrr_val, 0x10000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(prrr, 0x10000) }
		inline uint32_t disable(uint32_t prrr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(prrr_val, 0x10000) }
	}

	namespace tr_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(prrr, 0xffff, 0) }
		inline uint32_t get(uint32_t prrr_val) noexcept { GET_BITFIELD_FUNC(prrr_val, 0xffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(prrr, value, 0xffff, 0) }
		inline uint32_t set(uint32_t prrr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(prrr, value, 0xffff, 0) }
	}
}

// REVIDR (Revision ID Register)
// Provides implementation-specific minor revision information.
namespace revidr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(revidr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(revidr, val) }
}

// RMR (Reset Management Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace rmr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(rmr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(rmr, val) }

	namespace rr
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(rmr, 1) }
		inline uint32_t is_enabled(uint32_t rmr_val) noexcept { IS_BIT_ENABLED_FUNC(rmr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(rmr, 1) }
		inline uint32_t is_disabled(uint32_t rmr_val) noexcept { IS_BIT_DISABLED_FUNC(rmr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(rmr, 0x2) }
		inline uint32_t enable(uint32_t rmr_val) noexcept { SET_BITS_BY_MASK_FUNC(rmr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(rmr, 0x2) }
		inline uint32_t disable(uint32_t rmr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(rmr_val, 0x2) }
	}

	namespace aa64
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(rmr, 0) }
		inline uint32_t is_enabled(uint32_t rmr_val) noexcept { IS_BIT_ENABLED_FUNC(rmr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(rmr, 0) }
		inline uint32_t is_disabled(uint32_t rmr_val) noexcept { IS_BIT_DISABLED_FUNC(rmr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(rmr, 0x1) }
		inline uint32_t enable(uint32_t rmr_val) noexcept { SET_BITS_BY_MASK_FUNC(rmr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(rmr, 0x1) }
		inline uint32_t disable(uint32_t rmr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(rmr_val, 0x1) }
	}
}

// RVBAR (Reset Vector Base Address Register)
// If EL3 is not implemented, contains the IMPLEMENTATION DEFINED address that execution starts from after reset when executing in AArch32 state.
namespace rvbar
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(rvbar) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(rvbar, val) }

	namespace reset_address_31:1_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(rvbar, 0xfffffffe, 1) }
		inline uint32_t get(uint32_t rvbar_val) noexcept { GET_BITFIELD_FUNC(rvbar_val, 0xfffffffe, 1) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(rvbar, value, 0xfffffffe, 1) }
		inline uint32_t set(uint32_t rvbar, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(rvbar, value, 0xfffffffe, 1) }
	}
}

// SCR (Secure Configuration Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace scr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(scr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(scr, val) }

	namespace terr
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(scr, 15) }
		inline uint32_t is_enabled(uint32_t scr_val) noexcept { IS_BIT_ENABLED_FUNC(scr_val, 15) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(scr, 15) }
		inline uint32_t is_disabled(uint32_t scr_val) noexcept { IS_BIT_DISABLED_FUNC(scr_val, 15) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(scr, 0x8000) }
		inline uint32_t enable(uint32_t scr_val) noexcept { SET_BITS_BY_MASK_FUNC(scr_val, 0x8000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(scr, 0x8000) }
		inline uint32_t disable(uint32_t scr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(scr_val, 0x8000) }
	}

	namespace twe
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(scr, 13) }
		inline uint32_t is_enabled(uint32_t scr_val) noexcept { IS_BIT_ENABLED_FUNC(scr_val, 13) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(scr, 13) }
		inline uint32_t is_disabled(uint32_t scr_val) noexcept { IS_BIT_DISABLED_FUNC(scr_val, 13) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(scr, 0x2000) }
		inline uint32_t enable(uint32_t scr_val) noexcept { SET_BITS_BY_MASK_FUNC(scr_val, 0x2000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(scr, 0x2000) }
		inline uint32_t disable(uint32_t scr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(scr_val, 0x2000) }
	}

	namespace twi
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(scr, 12) }
		inline uint32_t is_enabled(uint32_t scr_val) noexcept { IS_BIT_ENABLED_FUNC(scr_val, 12) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(scr, 12) }
		inline uint32_t is_disabled(uint32_t scr_val) noexcept { IS_BIT_DISABLED_FUNC(scr_val, 12) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(scr, 0x1000) }
		inline uint32_t enable(uint32_t scr_val) noexcept { SET_BITS_BY_MASK_FUNC(scr_val, 0x1000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(scr, 0x1000) }
		inline uint32_t disable(uint32_t scr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(scr_val, 0x1000) }
	}

	namespace sif
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(scr, 9) }
		inline uint32_t is_enabled(uint32_t scr_val) noexcept { IS_BIT_ENABLED_FUNC(scr_val, 9) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(scr, 9) }
		inline uint32_t is_disabled(uint32_t scr_val) noexcept { IS_BIT_DISABLED_FUNC(scr_val, 9) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(scr, 0x200) }
		inline uint32_t enable(uint32_t scr_val) noexcept { SET_BITS_BY_MASK_FUNC(scr_val, 0x200) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(scr, 0x200) }
		inline uint32_t disable(uint32_t scr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(scr_val, 0x200) }
	}

	namespace hce
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(scr, 8) }
		inline uint32_t is_enabled(uint32_t scr_val) noexcept { IS_BIT_ENABLED_FUNC(scr_val, 8) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(scr, 8) }
		inline uint32_t is_disabled(uint32_t scr_val) noexcept { IS_BIT_DISABLED_FUNC(scr_val, 8) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(scr, 0x100) }
		inline uint32_t enable(uint32_t scr_val) noexcept { SET_BITS_BY_MASK_FUNC(scr_val, 0x100) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(scr, 0x100) }
		inline uint32_t disable(uint32_t scr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(scr_val, 0x100) }
	}

	namespace scd
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(scr, 7) }
		inline uint32_t is_enabled(uint32_t scr_val) noexcept { IS_BIT_ENABLED_FUNC(scr_val, 7) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(scr, 7) }
		inline uint32_t is_disabled(uint32_t scr_val) noexcept { IS_BIT_DISABLED_FUNC(scr_val, 7) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(scr, 0x80) }
		inline uint32_t enable(uint32_t scr_val) noexcept { SET_BITS_BY_MASK_FUNC(scr_val, 0x80) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(scr, 0x80) }
		inline uint32_t disable(uint32_t scr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(scr_val, 0x80) }
	}

	namespace net
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(scr, 6) }
		inline uint32_t is_enabled(uint32_t scr_val) noexcept { IS_BIT_ENABLED_FUNC(scr_val, 6) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(scr, 6) }
		inline uint32_t is_disabled(uint32_t scr_val) noexcept { IS_BIT_DISABLED_FUNC(scr_val, 6) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(scr, 0x40) }
		inline uint32_t enable(uint32_t scr_val) noexcept { SET_BITS_BY_MASK_FUNC(scr_val, 0x40) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(scr, 0x40) }
		inline uint32_t disable(uint32_t scr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(scr_val, 0x40) }
	}

	namespace aw
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(scr, 5) }
		inline uint32_t is_enabled(uint32_t scr_val) noexcept { IS_BIT_ENABLED_FUNC(scr_val, 5) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(scr, 5) }
		inline uint32_t is_disabled(uint32_t scr_val) noexcept { IS_BIT_DISABLED_FUNC(scr_val, 5) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(scr, 0x20) }
		inline uint32_t enable(uint32_t scr_val) noexcept { SET_BITS_BY_MASK_FUNC(scr_val, 0x20) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(scr, 0x20) }
		inline uint32_t disable(uint32_t scr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(scr_val, 0x20) }
	}

	namespace fw
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(scr, 4) }
		inline uint32_t is_enabled(uint32_t scr_val) noexcept { IS_BIT_ENABLED_FUNC(scr_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(scr, 4) }
		inline uint32_t is_disabled(uint32_t scr_val) noexcept { IS_BIT_DISABLED_FUNC(scr_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(scr, 0x10) }
		inline uint32_t enable(uint32_t scr_val) noexcept { SET_BITS_BY_MASK_FUNC(scr_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(scr, 0x10) }
		inline uint32_t disable(uint32_t scr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(scr_val, 0x10) }
	}

	namespace ea
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(scr, 3) }
		inline uint32_t is_enabled(uint32_t scr_val) noexcept { IS_BIT_ENABLED_FUNC(scr_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(scr, 3) }
		inline uint32_t is_disabled(uint32_t scr_val) noexcept { IS_BIT_DISABLED_FUNC(scr_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(scr, 0x8) }
		inline uint32_t enable(uint32_t scr_val) noexcept { SET_BITS_BY_MASK_FUNC(scr_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(scr, 0x8) }
		inline uint32_t disable(uint32_t scr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(scr_val, 0x8) }
	}

	namespace fiq
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(scr, 2) }
		inline uint32_t is_enabled(uint32_t scr_val) noexcept { IS_BIT_ENABLED_FUNC(scr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(scr, 2) }
		inline uint32_t is_disabled(uint32_t scr_val) noexcept { IS_BIT_DISABLED_FUNC(scr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(scr, 0x4) }
		inline uint32_t enable(uint32_t scr_val) noexcept { SET_BITS_BY_MASK_FUNC(scr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(scr, 0x4) }
		inline uint32_t disable(uint32_t scr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(scr_val, 0x4) }
	}

	namespace irq
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(scr, 1) }
		inline uint32_t is_enabled(uint32_t scr_val) noexcept { IS_BIT_ENABLED_FUNC(scr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(scr, 1) }
		inline uint32_t is_disabled(uint32_t scr_val) noexcept { IS_BIT_DISABLED_FUNC(scr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(scr, 0x2) }
		inline uint32_t enable(uint32_t scr_val) noexcept { SET_BITS_BY_MASK_FUNC(scr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(scr, 0x2) }
		inline uint32_t disable(uint32_t scr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(scr_val, 0x2) }
	}

	namespace ns
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(scr, 0) }
		inline uint32_t is_enabled(uint32_t scr_val) noexcept { IS_BIT_ENABLED_FUNC(scr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(scr, 0) }
		inline uint32_t is_disabled(uint32_t scr_val) noexcept { IS_BIT_DISABLED_FUNC(scr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(scr, 0x1) }
		inline uint32_t enable(uint32_t scr_val) noexcept { SET_BITS_BY_MASK_FUNC(scr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(scr, 0x1) }
		inline uint32_t disable(uint32_t scr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(scr_val, 0x1) }
	}
}

// SCTLR (System Control Register)
// Provides the top level control of the system, including its memory system.
namespace sctlr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(sctlr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(sctlr, val) }
}

// SDCR (Secure Debug Control Register)
// When EL3 is implemented and can use AArch32, controls debug and performance monitors functionality in Secure state.
namespace sdcr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(sdcr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(sdcr, val) }

	namespace epmad
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(sdcr, 21) }
		inline uint32_t is_enabled(uint32_t sdcr_val) noexcept { IS_BIT_ENABLED_FUNC(sdcr_val, 21) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(sdcr, 21) }
		inline uint32_t is_disabled(uint32_t sdcr_val) noexcept { IS_BIT_DISABLED_FUNC(sdcr_val, 21) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(sdcr, 0x200000) }
		inline uint32_t enable(uint32_t sdcr_val) noexcept { SET_BITS_BY_MASK_FUNC(sdcr_val, 0x200000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(sdcr, 0x200000) }
		inline uint32_t disable(uint32_t sdcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(sdcr_val, 0x200000) }
	}

	namespace edad
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(sdcr, 20) }
		inline uint32_t is_enabled(uint32_t sdcr_val) noexcept { IS_BIT_ENABLED_FUNC(sdcr_val, 20) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(sdcr, 20) }
		inline uint32_t is_disabled(uint32_t sdcr_val) noexcept { IS_BIT_DISABLED_FUNC(sdcr_val, 20) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(sdcr, 0x100000) }
		inline uint32_t enable(uint32_t sdcr_val) noexcept { SET_BITS_BY_MASK_FUNC(sdcr_val, 0x100000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(sdcr, 0x100000) }
		inline uint32_t disable(uint32_t sdcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(sdcr_val, 0x100000) }
	}

	namespace spme
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(sdcr, 17) }
		inline uint32_t is_enabled(uint32_t sdcr_val) noexcept { IS_BIT_ENABLED_FUNC(sdcr_val, 17) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(sdcr, 17) }
		inline uint32_t is_disabled(uint32_t sdcr_val) noexcept { IS_BIT_DISABLED_FUNC(sdcr_val, 17) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(sdcr, 0x20000) }
		inline uint32_t enable(uint32_t sdcr_val) noexcept { SET_BITS_BY_MASK_FUNC(sdcr_val, 0x20000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(sdcr, 0x20000) }
		inline uint32_t disable(uint32_t sdcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(sdcr_val, 0x20000) }
	}

	namespace spd
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(sdcr, 0xc000, 14) }
		inline uint32_t get(uint32_t sdcr_val) noexcept { GET_BITFIELD_FUNC(sdcr_val, 0xc000, 14) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(sdcr, value, 0xc000, 14) }
		inline uint32_t set(uint32_t sdcr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(sdcr, value, 0xc000, 14) }
	}
}

// SDER (Secure Debug Enable Register)
// Controls invasive and non-invasive debug in the Secure EL0 mode.
namespace sder
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(sder) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(sder, val) }

	namespace suniden
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(sder, 1) }
		inline uint32_t is_enabled(uint32_t sder_val) noexcept { IS_BIT_ENABLED_FUNC(sder_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(sder, 1) }
		inline uint32_t is_disabled(uint32_t sder_val) noexcept { IS_BIT_DISABLED_FUNC(sder_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(sder, 0x2) }
		inline uint32_t enable(uint32_t sder_val) noexcept { SET_BITS_BY_MASK_FUNC(sder_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(sder, 0x2) }
		inline uint32_t disable(uint32_t sder_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(sder_val, 0x2) }
	}

	namespace suiden
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(sder, 0) }
		inline uint32_t is_enabled(uint32_t sder_val) noexcept { IS_BIT_ENABLED_FUNC(sder_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(sder, 0) }
		inline uint32_t is_disabled(uint32_t sder_val) noexcept { IS_BIT_DISABLED_FUNC(sder_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(sder, 0x1) }
		inline uint32_t enable(uint32_t sder_val) noexcept { SET_BITS_BY_MASK_FUNC(sder_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(sder, 0x1) }
		inline uint32_t disable(uint32_t sder_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(sder_val, 0x1) }
	}
}

// SPSR (Saved Program Status Register)
// Holds the saved process state for the current mode.
namespace spsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(spsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(spsr, val) }
}

// SPSR_abt (Saved Program Status Register (Abort mode))
// Holds the saved process state when an exception is taken to Abort mode.
namespace spsr_abt
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(spsr_abt) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(spsr_abt, val) }
}

// SPSR_fiq (Saved Program Status Register (FIQ mode))
// Holds the saved process state when an exception is taken to FIQ mode.
namespace spsr_fiq
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(spsr_fiq) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(spsr_fiq, val) }
}

// SPSR_hyp (Saved Program Status Register (Hyp mode))
// Holds the saved process state when an exception is taken to Hyp mode.
namespace spsr_hyp
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(spsr_hyp) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(spsr_hyp, val) }
}

// SPSR_irq (Saved Program Status Register (IRQ mode))
// Holds the saved process state when an exception is taken to IRQ mode.
namespace spsr_irq
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(spsr_irq) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(spsr_irq, val) }
}

// SPSR_mon (Saved Program Status Register (Monitor mode))
// Holds the saved process state when an exception is taken to Monitor mode.
namespace spsr_mon
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(spsr_mon) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(spsr_mon, val) }
}

// SPSR_svc (Saved Program Status Register (Supervisor mode))
// Holds the saved process state when an exception is taken to Supervisor mode.
namespace spsr_svc
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(spsr_svc) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(spsr_svc, val) }
}

// SPSR_und (Saved Program Status Register (Undefined mode))
// Holds the saved process state when an exception is taken to Undefined mode.
namespace spsr_und
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(spsr_und) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(spsr_und, val) }
}

// TCMTR (TCM Type Register)
// Provides information about the implementation of the TCM.
namespace tcmtr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tcmtr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tcmtr, val) }
}

// TLBIALL (TLB Invalidate All)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbiall
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbiall) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbiall, val) }
}

// TLBIALLH (TLB Invalidate All, Hyp mode)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbiallh
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbiallh) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbiallh, val) }
}

// TLBIALLHIS (TLB Invalidate All, Hyp mode, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbiallhis
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbiallhis) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbiallhis, val) }
}

// TLBIALLIS (TLB Invalidate All, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbiallis
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbiallis) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbiallis, val) }
}

// TLBIALLNSNH (TLB Invalidate All, Non-Secure Non-Hyp)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbiallnsnh
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbiallnsnh) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbiallnsnh, val) }
}

// TLBIALLNSNHIS (TLB Invalidate All, Non-Secure Non-Hyp, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbiallnsnhis
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbiallnsnhis) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbiallnsnhis, val) }
}

// TLBIASID (TLB Invalidate by ASID match)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbiasid
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbiasid) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbiasid, val) }

	namespace asid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbiasid, 0xff, 0) }
		inline uint32_t get(uint32_t tlbiasid_val) noexcept { GET_BITFIELD_FUNC(tlbiasid_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbiasid, value, 0xff, 0) }
		inline uint32_t set(uint32_t tlbiasid, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbiasid, value, 0xff, 0) }
	}
}

// TLBIASIDIS (TLB Invalidate by ASID match, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbiasidis
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbiasidis) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbiasidis, val) }

	namespace asid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbiasidis, 0xff, 0) }
		inline uint32_t get(uint32_t tlbiasidis_val) noexcept { GET_BITFIELD_FUNC(tlbiasidis_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbiasidis, value, 0xff, 0) }
		inline uint32_t set(uint32_t tlbiasidis, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbiasidis, value, 0xff, 0) }
	}
}

// TLBIIPAS2 (TLB Invalidate by Intermediate Physical Address, Stage 2)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbiipas2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbiipas2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbiipas2, val) }

	namespace ipa_39:12_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbiipas2, 0xfffffff, 0) }
		inline uint32_t get(uint32_t tlbiipas2_val) noexcept { GET_BITFIELD_FUNC(tlbiipas2_val, 0xfffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbiipas2, value, 0xfffffff, 0) }
		inline uint32_t set(uint32_t tlbiipas2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbiipas2, value, 0xfffffff, 0) }
	}
}

// TLBIIPAS2IS (TLB Invalidate by Intermediate Physical Address, Stage 2, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbiipas2is
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbiipas2is) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbiipas2is, val) }

	namespace ipa_39:12_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbiipas2is, 0xfffffff, 0) }
		inline uint32_t get(uint32_t tlbiipas2is_val) noexcept { GET_BITFIELD_FUNC(tlbiipas2is_val, 0xfffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbiipas2is, value, 0xfffffff, 0) }
		inline uint32_t set(uint32_t tlbiipas2is, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbiipas2is, value, 0xfffffff, 0) }
	}
}

// TLBIIPAS2L (TLB Invalidate by Intermediate Physical Address, Stage 2, Last level)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbiipas2l
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbiipas2l) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbiipas2l, val) }

	namespace ipa_39:12_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbiipas2l, 0xfffffff, 0) }
		inline uint32_t get(uint32_t tlbiipas2l_val) noexcept { GET_BITFIELD_FUNC(tlbiipas2l_val, 0xfffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbiipas2l, value, 0xfffffff, 0) }
		inline uint32_t set(uint32_t tlbiipas2l, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbiipas2l, value, 0xfffffff, 0) }
	}
}

// TLBIIPAS2LIS (TLB Invalidate by Intermediate Physical Address, Stage 2, Last level, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbiipas2lis
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbiipas2lis) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbiipas2lis, val) }

	namespace ipa_39:12_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbiipas2lis, 0xfffffff, 0) }
		inline uint32_t get(uint32_t tlbiipas2lis_val) noexcept { GET_BITFIELD_FUNC(tlbiipas2lis_val, 0xfffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbiipas2lis, value, 0xfffffff, 0) }
		inline uint32_t set(uint32_t tlbiipas2lis, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbiipas2lis, value, 0xfffffff, 0) }
	}
}

// TLBIMVA (TLB Invalidate by VA)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbimva
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbimva) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbimva, val) }

	namespace va
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbimva, 0xfffff000, 12) }
		inline uint32_t get(uint32_t tlbimva_val) noexcept { GET_BITFIELD_FUNC(tlbimva_val, 0xfffff000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbimva, value, 0xfffff000, 12) }
		inline uint32_t set(uint32_t tlbimva, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbimva, value, 0xfffff000, 12) }
	}

	namespace asid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbimva, 0xff, 0) }
		inline uint32_t get(uint32_t tlbimva_val) noexcept { GET_BITFIELD_FUNC(tlbimva_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbimva, value, 0xff, 0) }
		inline uint32_t set(uint32_t tlbimva, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbimva, value, 0xff, 0) }
	}
}

// TLBIMVAA (TLB Invalidate by VA, All ASID)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbimvaa
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbimvaa) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbimvaa, val) }

	namespace va
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbimvaa, 0xfffff000, 12) }
		inline uint32_t get(uint32_t tlbimvaa_val) noexcept { GET_BITFIELD_FUNC(tlbimvaa_val, 0xfffff000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbimvaa, value, 0xfffff000, 12) }
		inline uint32_t set(uint32_t tlbimvaa, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbimvaa, value, 0xfffff000, 12) }
	}
}

// TLBIMVAAIS (TLB Invalidate by VA, All ASID, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbimvaais
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbimvaais) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbimvaais, val) }

	namespace va
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbimvaais, 0xfffff000, 12) }
		inline uint32_t get(uint32_t tlbimvaais_val) noexcept { GET_BITFIELD_FUNC(tlbimvaais_val, 0xfffff000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbimvaais, value, 0xfffff000, 12) }
		inline uint32_t set(uint32_t tlbimvaais, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbimvaais, value, 0xfffff000, 12) }
	}
}

// TLBIMVAAL (TLB Invalidate by VA, All ASID, Last level)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbimvaal
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbimvaal) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbimvaal, val) }

	namespace va
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbimvaal, 0xfffff000, 12) }
		inline uint32_t get(uint32_t tlbimvaal_val) noexcept { GET_BITFIELD_FUNC(tlbimvaal_val, 0xfffff000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbimvaal, value, 0xfffff000, 12) }
		inline uint32_t set(uint32_t tlbimvaal, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbimvaal, value, 0xfffff000, 12) }
	}
}

// TLBIMVAALIS (TLB Invalidate by VA, All ASID, Last level, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbimvaalis
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbimvaalis) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbimvaalis, val) }

	namespace va
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbimvaalis, 0xfffff000, 12) }
		inline uint32_t get(uint32_t tlbimvaalis_val) noexcept { GET_BITFIELD_FUNC(tlbimvaalis_val, 0xfffff000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbimvaalis, value, 0xfffff000, 12) }
		inline uint32_t set(uint32_t tlbimvaalis, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbimvaalis, value, 0xfffff000, 12) }
	}
}

// TLBIMVAH (TLB Invalidate by VA, Hyp mode)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbimvah
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbimvah) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbimvah, val) }

	namespace va
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbimvah, 0xfffff000, 12) }
		inline uint32_t get(uint32_t tlbimvah_val) noexcept { GET_BITFIELD_FUNC(tlbimvah_val, 0xfffff000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbimvah, value, 0xfffff000, 12) }
		inline uint32_t set(uint32_t tlbimvah, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbimvah, value, 0xfffff000, 12) }
	}
}

// TLBIMVAHIS (TLB Invalidate by VA, Hyp mode, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbimvahis
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbimvahis) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbimvahis, val) }

	namespace va
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbimvahis, 0xfffff000, 12) }
		inline uint32_t get(uint32_t tlbimvahis_val) noexcept { GET_BITFIELD_FUNC(tlbimvahis_val, 0xfffff000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbimvahis, value, 0xfffff000, 12) }
		inline uint32_t set(uint32_t tlbimvahis, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbimvahis, value, 0xfffff000, 12) }
	}
}

// TLBIMVAIS (TLB Invalidate by VA, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbimvais
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbimvais) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbimvais, val) }

	namespace va
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbimvais, 0xfffff000, 12) }
		inline uint32_t get(uint32_t tlbimvais_val) noexcept { GET_BITFIELD_FUNC(tlbimvais_val, 0xfffff000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbimvais, value, 0xfffff000, 12) }
		inline uint32_t set(uint32_t tlbimvais, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbimvais, value, 0xfffff000, 12) }
	}

	namespace asid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbimvais, 0xff, 0) }
		inline uint32_t get(uint32_t tlbimvais_val) noexcept { GET_BITFIELD_FUNC(tlbimvais_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbimvais, value, 0xff, 0) }
		inline uint32_t set(uint32_t tlbimvais, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbimvais, value, 0xff, 0) }
	}
}

// TLBIMVAL (TLB Invalidate by VA, Last level)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbimval
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbimval) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbimval, val) }

	namespace va
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbimval, 0xfffff000, 12) }
		inline uint32_t get(uint32_t tlbimval_val) noexcept { GET_BITFIELD_FUNC(tlbimval_val, 0xfffff000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbimval, value, 0xfffff000, 12) }
		inline uint32_t set(uint32_t tlbimval, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbimval, value, 0xfffff000, 12) }
	}

	namespace asid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbimval, 0xff, 0) }
		inline uint32_t get(uint32_t tlbimval_val) noexcept { GET_BITFIELD_FUNC(tlbimval_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbimval, value, 0xff, 0) }
		inline uint32_t set(uint32_t tlbimval, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbimval, value, 0xff, 0) }
	}
}

// TLBIMVALH (TLB Invalidate by VA, Last level, Hyp mode)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbimvalh
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbimvalh) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbimvalh, val) }

	namespace va
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbimvalh, 0xfffff000, 12) }
		inline uint32_t get(uint32_t tlbimvalh_val) noexcept { GET_BITFIELD_FUNC(tlbimvalh_val, 0xfffff000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbimvalh, value, 0xfffff000, 12) }
		inline uint32_t set(uint32_t tlbimvalh, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbimvalh, value, 0xfffff000, 12) }
	}
}

// TLBIMVALHIS (TLB Invalidate by VA, Last level, Hyp mode, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbimvalhis
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbimvalhis) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbimvalhis, val) }

	namespace va
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbimvalhis, 0xfffff000, 12) }
		inline uint32_t get(uint32_t tlbimvalhis_val) noexcept { GET_BITFIELD_FUNC(tlbimvalhis_val, 0xfffff000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbimvalhis, value, 0xfffff000, 12) }
		inline uint32_t set(uint32_t tlbimvalhis, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbimvalhis, value, 0xfffff000, 12) }
	}
}

// TLBIMVALIS (TLB Invalidate by VA, Last level, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbimvalis
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbimvalis) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbimvalis, val) }

	namespace va
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbimvalis, 0xfffff000, 12) }
		inline uint32_t get(uint32_t tlbimvalis_val) noexcept { GET_BITFIELD_FUNC(tlbimvalis_val, 0xfffff000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbimvalis, value, 0xfffff000, 12) }
		inline uint32_t set(uint32_t tlbimvalis, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbimvalis, value, 0xfffff000, 12) }
	}

	namespace asid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbimvalis, 0xff, 0) }
		inline uint32_t get(uint32_t tlbimvalis_val) noexcept { GET_BITFIELD_FUNC(tlbimvalis_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbimvalis, value, 0xff, 0) }
		inline uint32_t set(uint32_t tlbimvalis, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbimvalis, value, 0xff, 0) }
	}
}

// TLBTR (TLB Type Register)
// Provides information about the TLB implementation. The register must define whether the implementation provides separate instruction and data TLBs, or a unified TLB. Normally, the IMPLEMENTATION DEFINED information in this register includes the number of lockable entries in the TLB.
namespace tlbtr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbtr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbtr, val) }

	namespace nu
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(tlbtr, 0) }
		inline uint32_t is_enabled(uint32_t tlbtr_val) noexcept { IS_BIT_ENABLED_FUNC(tlbtr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(tlbtr, 0) }
		inline uint32_t is_disabled(uint32_t tlbtr_val) noexcept { IS_BIT_DISABLED_FUNC(tlbtr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(tlbtr, 0x1) }
		inline uint32_t enable(uint32_t tlbtr_val) noexcept { SET_BITS_BY_MASK_FUNC(tlbtr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(tlbtr, 0x1) }
		inline uint32_t disable(uint32_t tlbtr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(tlbtr_val, 0x1) }
	}
}

// TPIDRPRW (PL1 Software Thread ID Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace tpidrprw
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tpidrprw) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tpidrprw, val) }

	namespace thread_id
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tpidrprw, 0xffffffff, 0) }
		inline uint32_t get(uint32_t tpidrprw_val) noexcept { GET_BITFIELD_FUNC(tpidrprw_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tpidrprw, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t tpidrprw, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tpidrprw, value, 0xffffffff, 0) }
	}
}

// TPIDRURO (PL0 Read-Only Software Thread ID Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace tpidruro
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tpidruro) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tpidruro, val) }

	namespace thread_id
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tpidruro, 0xffffffff, 0) }
		inline uint32_t get(uint32_t tpidruro_val) noexcept { GET_BITFIELD_FUNC(tpidruro_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tpidruro, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t tpidruro, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tpidruro, value, 0xffffffff, 0) }
	}
}

// TPIDRURW (PL0 Read/Write Software Thread ID Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace tpidrurw
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tpidrurw) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tpidrurw, val) }

	namespace thread_id
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(tpidrurw, 0xffffffff, 0) }
		inline uint32_t get(uint32_t tpidrurw_val) noexcept { GET_BITFIELD_FUNC(tpidrurw_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tpidrurw, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t tpidrurw, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tpidrurw, value, 0xffffffff, 0) }
	}
}

// TTBCR (Translation Table Base Control Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace ttbcr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ttbcr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ttbcr, val) }

	// Fieldset valid when: TTBCR.EAE==0
	namespace fieldset_1
	{
		namespace eae
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ttbcr, 31) }
			inline uint32_t is_enabled(uint32_t ttbcr_val) noexcept { IS_BIT_ENABLED_FUNC(ttbcr_val, 31) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ttbcr, 31) }
			inline uint32_t is_disabled(uint32_t ttbcr_val) noexcept { IS_BIT_DISABLED_FUNC(ttbcr_val, 31) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ttbcr, 0x80000000) }
			inline uint32_t enable(uint32_t ttbcr_val) noexcept { SET_BITS_BY_MASK_FUNC(ttbcr_val, 0x80000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ttbcr, 0x80000000) }
			inline uint32_t disable(uint32_t ttbcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ttbcr_val, 0x80000000) }
		}

		namespace pd1
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ttbcr, 5) }
			inline uint32_t is_enabled(uint32_t ttbcr_val) noexcept { IS_BIT_ENABLED_FUNC(ttbcr_val, 5) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ttbcr, 5) }
			inline uint32_t is_disabled(uint32_t ttbcr_val) noexcept { IS_BIT_DISABLED_FUNC(ttbcr_val, 5) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ttbcr, 0x20) }
			inline uint32_t enable(uint32_t ttbcr_val) noexcept { SET_BITS_BY_MASK_FUNC(ttbcr_val, 0x20) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ttbcr, 0x20) }
			inline uint32_t disable(uint32_t ttbcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ttbcr_val, 0x20) }
		}

		namespace pd0
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ttbcr, 4) }
			inline uint32_t is_enabled(uint32_t ttbcr_val) noexcept { IS_BIT_ENABLED_FUNC(ttbcr_val, 4) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ttbcr, 4) }
			inline uint32_t is_disabled(uint32_t ttbcr_val) noexcept { IS_BIT_DISABLED_FUNC(ttbcr_val, 4) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ttbcr, 0x10) }
			inline uint32_t enable(uint32_t ttbcr_val) noexcept { SET_BITS_BY_MASK_FUNC(ttbcr_val, 0x10) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ttbcr, 0x10) }
			inline uint32_t disable(uint32_t ttbcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ttbcr_val, 0x10) }
		}

		namespace n
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ttbcr, 0x7, 0) }
			inline uint32_t get(uint32_t ttbcr_val) noexcept { GET_BITFIELD_FUNC(ttbcr_val, 0x7, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ttbcr, value, 0x7, 0) }
			inline uint32_t set(uint32_t ttbcr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ttbcr, value, 0x7, 0) }
		}
	}

	// Fieldset valid when: TTBCR.EAE==1
	namespace fieldset_2
	{	}
}

// TTBCR2 (Translation Table Base Control Register 2)
// See the ARMv8 architecture reference manual for a description of this register
namespace ttbcr2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ttbcr2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ttbcr2, val) }

	namespace hwu162
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ttbcr2, 18) }
		inline uint32_t is_enabled(uint32_t ttbcr2_val) noexcept { IS_BIT_ENABLED_FUNC(ttbcr2_val, 18) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ttbcr2, 18) }
		inline uint32_t is_disabled(uint32_t ttbcr2_val) noexcept { IS_BIT_DISABLED_FUNC(ttbcr2_val, 18) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ttbcr2, 0x40000) }
		inline uint32_t enable(uint32_t ttbcr2_val) noexcept { SET_BITS_BY_MASK_FUNC(ttbcr2_val, 0x40000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ttbcr2, 0x40000) }
		inline uint32_t disable(uint32_t ttbcr2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ttbcr2_val, 0x40000) }
	}

	namespace hwu161
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ttbcr2, 17) }
		inline uint32_t is_enabled(uint32_t ttbcr2_val) noexcept { IS_BIT_ENABLED_FUNC(ttbcr2_val, 17) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ttbcr2, 17) }
		inline uint32_t is_disabled(uint32_t ttbcr2_val) noexcept { IS_BIT_DISABLED_FUNC(ttbcr2_val, 17) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ttbcr2, 0x20000) }
		inline uint32_t enable(uint32_t ttbcr2_val) noexcept { SET_BITS_BY_MASK_FUNC(ttbcr2_val, 0x20000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ttbcr2, 0x20000) }
		inline uint32_t disable(uint32_t ttbcr2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ttbcr2_val, 0x20000) }
	}

	namespace hwu160
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ttbcr2, 16) }
		inline uint32_t is_enabled(uint32_t ttbcr2_val) noexcept { IS_BIT_ENABLED_FUNC(ttbcr2_val, 16) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ttbcr2, 16) }
		inline uint32_t is_disabled(uint32_t ttbcr2_val) noexcept { IS_BIT_DISABLED_FUNC(ttbcr2_val, 16) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ttbcr2, 0x10000) }
		inline uint32_t enable(uint32_t ttbcr2_val) noexcept { SET_BITS_BY_MASK_FUNC(ttbcr2_val, 0x10000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ttbcr2, 0x10000) }
		inline uint32_t disable(uint32_t ttbcr2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ttbcr2_val, 0x10000) }
	}

	namespace hwu159
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ttbcr2, 15) }
		inline uint32_t is_enabled(uint32_t ttbcr2_val) noexcept { IS_BIT_ENABLED_FUNC(ttbcr2_val, 15) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ttbcr2, 15) }
		inline uint32_t is_disabled(uint32_t ttbcr2_val) noexcept { IS_BIT_DISABLED_FUNC(ttbcr2_val, 15) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ttbcr2, 0x8000) }
		inline uint32_t enable(uint32_t ttbcr2_val) noexcept { SET_BITS_BY_MASK_FUNC(ttbcr2_val, 0x8000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ttbcr2, 0x8000) }
		inline uint32_t disable(uint32_t ttbcr2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ttbcr2_val, 0x8000) }
	}

	namespace hwu062
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ttbcr2, 14) }
		inline uint32_t is_enabled(uint32_t ttbcr2_val) noexcept { IS_BIT_ENABLED_FUNC(ttbcr2_val, 14) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ttbcr2, 14) }
		inline uint32_t is_disabled(uint32_t ttbcr2_val) noexcept { IS_BIT_DISABLED_FUNC(ttbcr2_val, 14) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ttbcr2, 0x4000) }
		inline uint32_t enable(uint32_t ttbcr2_val) noexcept { SET_BITS_BY_MASK_FUNC(ttbcr2_val, 0x4000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ttbcr2, 0x4000) }
		inline uint32_t disable(uint32_t ttbcr2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ttbcr2_val, 0x4000) }
	}

	namespace hwu061
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ttbcr2, 13) }
		inline uint32_t is_enabled(uint32_t ttbcr2_val) noexcept { IS_BIT_ENABLED_FUNC(ttbcr2_val, 13) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ttbcr2, 13) }
		inline uint32_t is_disabled(uint32_t ttbcr2_val) noexcept { IS_BIT_DISABLED_FUNC(ttbcr2_val, 13) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ttbcr2, 0x2000) }
		inline uint32_t enable(uint32_t ttbcr2_val) noexcept { SET_BITS_BY_MASK_FUNC(ttbcr2_val, 0x2000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ttbcr2, 0x2000) }
		inline uint32_t disable(uint32_t ttbcr2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ttbcr2_val, 0x2000) }
	}

	namespace hwu060
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ttbcr2, 12) }
		inline uint32_t is_enabled(uint32_t ttbcr2_val) noexcept { IS_BIT_ENABLED_FUNC(ttbcr2_val, 12) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ttbcr2, 12) }
		inline uint32_t is_disabled(uint32_t ttbcr2_val) noexcept { IS_BIT_DISABLED_FUNC(ttbcr2_val, 12) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ttbcr2, 0x1000) }
		inline uint32_t enable(uint32_t ttbcr2_val) noexcept { SET_BITS_BY_MASK_FUNC(ttbcr2_val, 0x1000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ttbcr2, 0x1000) }
		inline uint32_t disable(uint32_t ttbcr2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ttbcr2_val, 0x1000) }
	}

	namespace hwu059
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ttbcr2, 11) }
		inline uint32_t is_enabled(uint32_t ttbcr2_val) noexcept { IS_BIT_ENABLED_FUNC(ttbcr2_val, 11) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ttbcr2, 11) }
		inline uint32_t is_disabled(uint32_t ttbcr2_val) noexcept { IS_BIT_DISABLED_FUNC(ttbcr2_val, 11) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ttbcr2, 0x800) }
		inline uint32_t enable(uint32_t ttbcr2_val) noexcept { SET_BITS_BY_MASK_FUNC(ttbcr2_val, 0x800) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ttbcr2, 0x800) }
		inline uint32_t disable(uint32_t ttbcr2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ttbcr2_val, 0x800) }
	}

	namespace hpd1
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ttbcr2, 10) }
		inline uint32_t is_enabled(uint32_t ttbcr2_val) noexcept { IS_BIT_ENABLED_FUNC(ttbcr2_val, 10) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ttbcr2, 10) }
		inline uint32_t is_disabled(uint32_t ttbcr2_val) noexcept { IS_BIT_DISABLED_FUNC(ttbcr2_val, 10) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ttbcr2, 0x400) }
		inline uint32_t enable(uint32_t ttbcr2_val) noexcept { SET_BITS_BY_MASK_FUNC(ttbcr2_val, 0x400) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ttbcr2, 0x400) }
		inline uint32_t disable(uint32_t ttbcr2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ttbcr2_val, 0x400) }
	}

	namespace hpd0
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ttbcr2, 9) }
		inline uint32_t is_enabled(uint32_t ttbcr2_val) noexcept { IS_BIT_ENABLED_FUNC(ttbcr2_val, 9) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ttbcr2, 9) }
		inline uint32_t is_disabled(uint32_t ttbcr2_val) noexcept { IS_BIT_DISABLED_FUNC(ttbcr2_val, 9) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ttbcr2, 0x200) }
		inline uint32_t enable(uint32_t ttbcr2_val) noexcept { SET_BITS_BY_MASK_FUNC(ttbcr2_val, 0x200) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ttbcr2, 0x200) }
		inline uint32_t disable(uint32_t ttbcr2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ttbcr2_val, 0x200) }
	}
}

// TTBR0 (Translation Table Base Register 0)
// Holds the base address of the translation table for the initial lookup for stage 1 of the translation of an address from the lower VA range in the PL1&0 translation regime, and other information for this translation regime.
namespace ttbr0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ttbr0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ttbr0, val) }

	// Fieldset valid when: TTBCR.EAE==0
	namespace fieldset_1
	{
		namespace ttb0
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ttbr0, 0xffffff80, 7) }
			inline uint32_t get(uint32_t ttbr0_val) noexcept { GET_BITFIELD_FUNC(ttbr0_val, 0xffffff80, 7) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ttbr0, value, 0xffffff80, 7) }
			inline uint32_t set(uint32_t ttbr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ttbr0, value, 0xffffff80, 7) }
		}

		namespace irgn_0_
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ttbr0, 6) }
			inline uint32_t is_enabled(uint32_t ttbr0_val) noexcept { IS_BIT_ENABLED_FUNC(ttbr0_val, 6) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ttbr0, 6) }
			inline uint32_t is_disabled(uint32_t ttbr0_val) noexcept { IS_BIT_DISABLED_FUNC(ttbr0_val, 6) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ttbr0, 0x40) }
			inline uint32_t enable(uint32_t ttbr0_val) noexcept { SET_BITS_BY_MASK_FUNC(ttbr0_val, 0x40) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ttbr0, 0x40) }
			inline uint32_t disable(uint32_t ttbr0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ttbr0_val, 0x40) }
		}

		namespace nos
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ttbr0, 5) }
			inline uint32_t is_enabled(uint32_t ttbr0_val) noexcept { IS_BIT_ENABLED_FUNC(ttbr0_val, 5) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ttbr0, 5) }
			inline uint32_t is_disabled(uint32_t ttbr0_val) noexcept { IS_BIT_DISABLED_FUNC(ttbr0_val, 5) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ttbr0, 0x20) }
			inline uint32_t enable(uint32_t ttbr0_val) noexcept { SET_BITS_BY_MASK_FUNC(ttbr0_val, 0x20) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ttbr0, 0x20) }
			inline uint32_t disable(uint32_t ttbr0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ttbr0_val, 0x20) }
		}

		namespace rgn
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ttbr0, 0x18, 3) }
			inline uint32_t get(uint32_t ttbr0_val) noexcept { GET_BITFIELD_FUNC(ttbr0_val, 0x18, 3) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ttbr0, value, 0x18, 3) }
			inline uint32_t set(uint32_t ttbr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ttbr0, value, 0x18, 3) }
		}

		namespace imp
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ttbr0, 2) }
			inline uint32_t is_enabled(uint32_t ttbr0_val) noexcept { IS_BIT_ENABLED_FUNC(ttbr0_val, 2) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ttbr0, 2) }
			inline uint32_t is_disabled(uint32_t ttbr0_val) noexcept { IS_BIT_DISABLED_FUNC(ttbr0_val, 2) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ttbr0, 0x4) }
			inline uint32_t enable(uint32_t ttbr0_val) noexcept { SET_BITS_BY_MASK_FUNC(ttbr0_val, 0x4) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ttbr0, 0x4) }
			inline uint32_t disable(uint32_t ttbr0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ttbr0_val, 0x4) }
		}

		namespace s
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ttbr0, 1) }
			inline uint32_t is_enabled(uint32_t ttbr0_val) noexcept { IS_BIT_ENABLED_FUNC(ttbr0_val, 1) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ttbr0, 1) }
			inline uint32_t is_disabled(uint32_t ttbr0_val) noexcept { IS_BIT_DISABLED_FUNC(ttbr0_val, 1) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ttbr0, 0x2) }
			inline uint32_t enable(uint32_t ttbr0_val) noexcept { SET_BITS_BY_MASK_FUNC(ttbr0_val, 0x2) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ttbr0, 0x2) }
			inline uint32_t disable(uint32_t ttbr0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ttbr0_val, 0x2) }
		}

		namespace irgn_1_
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ttbr0, 0) }
			inline uint32_t is_enabled(uint32_t ttbr0_val) noexcept { IS_BIT_ENABLED_FUNC(ttbr0_val, 0) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ttbr0, 0) }
			inline uint32_t is_disabled(uint32_t ttbr0_val) noexcept { IS_BIT_DISABLED_FUNC(ttbr0_val, 0) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ttbr0, 0x1) }
			inline uint32_t enable(uint32_t ttbr0_val) noexcept { SET_BITS_BY_MASK_FUNC(ttbr0_val, 0x1) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ttbr0, 0x1) }
			inline uint32_t disable(uint32_t ttbr0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ttbr0_val, 0x1) }
		}
	}

	// Fieldset valid when: TTBCR.EAE==1
	namespace fieldset_2
	{	}
}

// TTBR1 (Translation Table Base Register 1)
// Holds the base address of the translation table for the initial lookup for stage 1 of the translation of an address from the higher VA range in the PL1&0 translation regime, and other information for this translation regime.
namespace ttbr1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ttbr1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ttbr1, val) }

	// Fieldset valid when: TTBCR.EAE==0
	namespace fieldset_1
	{
		namespace ttb1
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ttbr1, 0xffffff80, 7) }
			inline uint32_t get(uint32_t ttbr1_val) noexcept { GET_BITFIELD_FUNC(ttbr1_val, 0xffffff80, 7) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ttbr1, value, 0xffffff80, 7) }
			inline uint32_t set(uint32_t ttbr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ttbr1, value, 0xffffff80, 7) }
		}

		namespace irgn_0_
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ttbr1, 6) }
			inline uint32_t is_enabled(uint32_t ttbr1_val) noexcept { IS_BIT_ENABLED_FUNC(ttbr1_val, 6) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ttbr1, 6) }
			inline uint32_t is_disabled(uint32_t ttbr1_val) noexcept { IS_BIT_DISABLED_FUNC(ttbr1_val, 6) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ttbr1, 0x40) }
			inline uint32_t enable(uint32_t ttbr1_val) noexcept { SET_BITS_BY_MASK_FUNC(ttbr1_val, 0x40) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ttbr1, 0x40) }
			inline uint32_t disable(uint32_t ttbr1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ttbr1_val, 0x40) }
		}

		namespace nos
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ttbr1, 5) }
			inline uint32_t is_enabled(uint32_t ttbr1_val) noexcept { IS_BIT_ENABLED_FUNC(ttbr1_val, 5) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ttbr1, 5) }
			inline uint32_t is_disabled(uint32_t ttbr1_val) noexcept { IS_BIT_DISABLED_FUNC(ttbr1_val, 5) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ttbr1, 0x20) }
			inline uint32_t enable(uint32_t ttbr1_val) noexcept { SET_BITS_BY_MASK_FUNC(ttbr1_val, 0x20) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ttbr1, 0x20) }
			inline uint32_t disable(uint32_t ttbr1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ttbr1_val, 0x20) }
		}

		namespace rgn
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ttbr1, 0x18, 3) }
			inline uint32_t get(uint32_t ttbr1_val) noexcept { GET_BITFIELD_FUNC(ttbr1_val, 0x18, 3) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ttbr1, value, 0x18, 3) }
			inline uint32_t set(uint32_t ttbr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ttbr1, value, 0x18, 3) }
		}

		namespace imp
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ttbr1, 2) }
			inline uint32_t is_enabled(uint32_t ttbr1_val) noexcept { IS_BIT_ENABLED_FUNC(ttbr1_val, 2) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ttbr1, 2) }
			inline uint32_t is_disabled(uint32_t ttbr1_val) noexcept { IS_BIT_DISABLED_FUNC(ttbr1_val, 2) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ttbr1, 0x4) }
			inline uint32_t enable(uint32_t ttbr1_val) noexcept { SET_BITS_BY_MASK_FUNC(ttbr1_val, 0x4) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ttbr1, 0x4) }
			inline uint32_t disable(uint32_t ttbr1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ttbr1_val, 0x4) }
		}

		namespace s
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ttbr1, 1) }
			inline uint32_t is_enabled(uint32_t ttbr1_val) noexcept { IS_BIT_ENABLED_FUNC(ttbr1_val, 1) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ttbr1, 1) }
			inline uint32_t is_disabled(uint32_t ttbr1_val) noexcept { IS_BIT_DISABLED_FUNC(ttbr1_val, 1) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ttbr1, 0x2) }
			inline uint32_t enable(uint32_t ttbr1_val) noexcept { SET_BITS_BY_MASK_FUNC(ttbr1_val, 0x2) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ttbr1, 0x2) }
			inline uint32_t disable(uint32_t ttbr1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ttbr1_val, 0x2) }
		}

		namespace irgn_1_
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ttbr1, 0) }
			inline uint32_t is_enabled(uint32_t ttbr1_val) noexcept { IS_BIT_ENABLED_FUNC(ttbr1_val, 0) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ttbr1, 0) }
			inline uint32_t is_disabled(uint32_t ttbr1_val) noexcept { IS_BIT_DISABLED_FUNC(ttbr1_val, 0) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ttbr1, 0x1) }
			inline uint32_t enable(uint32_t ttbr1_val) noexcept { SET_BITS_BY_MASK_FUNC(ttbr1_val, 0x1) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ttbr1, 0x1) }
			inline uint32_t disable(uint32_t ttbr1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ttbr1_val, 0x1) }
		}
	}

	// Fieldset valid when: TTBCR.EAE==1
	namespace fieldset_2
	{	}
}

// VBAR (Vector Base Address Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace vbar
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(vbar) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(vbar, val) }

	namespace vector_base_address
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(vbar, 0xffffffe0, 5) }
		inline uint32_t get(uint32_t vbar_val) noexcept { GET_BITFIELD_FUNC(vbar_val, 0xffffffe0, 5) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(vbar, value, 0xffffffe0, 5) }
		inline uint32_t set(uint32_t vbar, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(vbar, value, 0xffffffe0, 5) }
	}
}

// VMPIDR (Virtualization Multiprocessor ID Register)
// Holds the value of the Virtualization Multiprocessor ID. This is the value returned by Non-secure EL1 reads of MPIDR.
namespace vmpidr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(vmpidr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(vmpidr, val) }

	namespace m
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(vmpidr, 31) }
		inline uint32_t is_enabled(uint32_t vmpidr_val) noexcept { IS_BIT_ENABLED_FUNC(vmpidr_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(vmpidr, 31) }
		inline uint32_t is_disabled(uint32_t vmpidr_val) noexcept { IS_BIT_DISABLED_FUNC(vmpidr_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(vmpidr, 0x80000000) }
		inline uint32_t enable(uint32_t vmpidr_val) noexcept { SET_BITS_BY_MASK_FUNC(vmpidr_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(vmpidr, 0x80000000) }
		inline uint32_t disable(uint32_t vmpidr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(vmpidr_val, 0x80000000) }
	}

	namespace u
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(vmpidr, 30) }
		inline uint32_t is_enabled(uint32_t vmpidr_val) noexcept { IS_BIT_ENABLED_FUNC(vmpidr_val, 30) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(vmpidr, 30) }
		inline uint32_t is_disabled(uint32_t vmpidr_val) noexcept { IS_BIT_DISABLED_FUNC(vmpidr_val, 30) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(vmpidr, 0x40000000) }
		inline uint32_t enable(uint32_t vmpidr_val) noexcept { SET_BITS_BY_MASK_FUNC(vmpidr_val, 0x40000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(vmpidr, 0x40000000) }
		inline uint32_t disable(uint32_t vmpidr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(vmpidr_val, 0x40000000) }
	}

	namespace mt
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(vmpidr, 24) }
		inline uint32_t is_enabled(uint32_t vmpidr_val) noexcept { IS_BIT_ENABLED_FUNC(vmpidr_val, 24) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(vmpidr, 24) }
		inline uint32_t is_disabled(uint32_t vmpidr_val) noexcept { IS_BIT_DISABLED_FUNC(vmpidr_val, 24) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(vmpidr, 0x1000000) }
		inline uint32_t enable(uint32_t vmpidr_val) noexcept { SET_BITS_BY_MASK_FUNC(vmpidr_val, 0x1000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(vmpidr, 0x1000000) }
		inline uint32_t disable(uint32_t vmpidr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(vmpidr_val, 0x1000000) }
	}

	namespace aff2
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(vmpidr, 0xff0000, 16) }
		inline uint32_t get(uint32_t vmpidr_val) noexcept { GET_BITFIELD_FUNC(vmpidr_val, 0xff0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(vmpidr, value, 0xff0000, 16) }
		inline uint32_t set(uint32_t vmpidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(vmpidr, value, 0xff0000, 16) }
	}

	namespace aff1
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(vmpidr, 0xff00, 8) }
		inline uint32_t get(uint32_t vmpidr_val) noexcept { GET_BITFIELD_FUNC(vmpidr_val, 0xff00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(vmpidr, value, 0xff00, 8) }
		inline uint32_t set(uint32_t vmpidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(vmpidr, value, 0xff00, 8) }
	}

	namespace aff0
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(vmpidr, 0xff, 0) }
		inline uint32_t get(uint32_t vmpidr_val) noexcept { GET_BITFIELD_FUNC(vmpidr_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(vmpidr, value, 0xff, 0) }
		inline uint32_t set(uint32_t vmpidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(vmpidr, value, 0xff, 0) }
	}
}

// VPIDR (Virtualization Processor ID Register)
// Holds the value of the Virtualization Processor ID. This is the value returned by Non-secure EL1 reads of MIDR.
namespace vpidr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(vpidr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(vpidr, val) }

	namespace implementer
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(vpidr, 0xff000000, 24) }
		inline uint32_t get(uint32_t vpidr_val) noexcept { GET_BITFIELD_FUNC(vpidr_val, 0xff000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(vpidr, value, 0xff000000, 24) }
		inline uint32_t set(uint32_t vpidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(vpidr, value, 0xff000000, 24) }
	}

	namespace variant
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(vpidr, 0xf00000, 20) }
		inline uint32_t get(uint32_t vpidr_val) noexcept { GET_BITFIELD_FUNC(vpidr_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(vpidr, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t vpidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(vpidr, value, 0xf00000, 20) }
	}

	namespace architecture
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(vpidr, 0xf0000, 16) }
		inline uint32_t get(uint32_t vpidr_val) noexcept { GET_BITFIELD_FUNC(vpidr_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(vpidr, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t vpidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(vpidr, value, 0xf0000, 16) }
	}

	namespace partnum
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(vpidr, 0xfff0, 4) }
		inline uint32_t get(uint32_t vpidr_val) noexcept { GET_BITFIELD_FUNC(vpidr_val, 0xfff0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(vpidr, value, 0xfff0, 4) }
		inline uint32_t set(uint32_t vpidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(vpidr, value, 0xfff0, 4) }
	}

	namespace revision
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(vpidr, 0xf, 0) }
		inline uint32_t get(uint32_t vpidr_val) noexcept { GET_BITFIELD_FUNC(vpidr_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(vpidr, value, 0xf, 0) }
		inline uint32_t set(uint32_t vpidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(vpidr, value, 0xf, 0) }
	}
}

// VTCR (Virtualization Translation Control Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace vtcr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(vtcr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(vtcr, val) }
}

// VTTBR (Virtualization Translation Table Base Register)
// Holds the base address of the translation table for the initial lookup for stage 2 of an address translation in the Non-secure PL1&0 translation regime, and other information for this translation regime.
namespace vttbr
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(vttbr) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(vttbr, val) }
}

// ACTLR_EL1 (Auxiliary Control Register (EL1))
// See the ARMv8 architecture reference manual for a description of this register
namespace actlr_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(actlr_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(actlr_el1, val) }
}

// ACTLR_EL2 (Auxiliary Control Register (EL2))
// See the ARMv8 architecture reference manual for a description of this register
namespace actlr_el2
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(actlr_el2) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(actlr_el2, val) }
}

// ACTLR_EL3 (Auxiliary Control Register (EL3))
// Provides IMPLEMENTATION DEFINED configuration and control options for EL3.
namespace actlr_el3
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(actlr_el3) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(actlr_el3, val) }
}

// AFSR0_EL1 (Auxiliary Fault Status Register 0 (EL1))
// Provides additional IMPLEMENTATION DEFINED fault status information for exceptions taken to EL1.
namespace afsr0_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(afsr0_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(afsr0_el1, val) }
}

// AFSR0_EL2 (Auxiliary Fault Status Register 0 (EL2))
// Provides additional IMPLEMENTATION DEFINED fault status information for exceptions taken to EL2.
namespace afsr0_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(afsr0_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(afsr0_el2, val) }
}

// AFSR0_EL3 (Auxiliary Fault Status Register 0 (EL3))
// Provides additional IMPLEMENTATION DEFINED fault status information for exceptions taken to EL3.
namespace afsr0_el3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(afsr0_el3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(afsr0_el3, val) }
}

// AFSR1_EL1 (Auxiliary Fault Status Register 1 (EL1))
// Provides additional IMPLEMENTATION DEFINED fault status information for exceptions taken to EL1.
namespace afsr1_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(afsr1_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(afsr1_el1, val) }
}

// AFSR1_EL2 (Auxiliary Fault Status Register 1 (EL2))
// Provides additional IMPLEMENTATION DEFINED fault status information for exceptions taken to EL2.
namespace afsr1_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(afsr1_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(afsr1_el2, val) }
}

// AFSR1_EL3 (Auxiliary Fault Status Register 1 (EL3))
// Provides additional IMPLEMENTATION DEFINED fault status information for exceptions taken to EL3.
namespace afsr1_el3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(afsr1_el3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(afsr1_el3, val) }
}

// AIDR_EL1 (Auxiliary ID Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace aidr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(aidr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(aidr_el1, val) }
}

// AMAIR_EL1 (Auxiliary Memory Attribute Indirection Register (EL1))
// Provides IMPLEMENTATION DEFINED memory attributes for the memory regions specified by MAIR_EL1.
namespace amair_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(amair_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(amair_el1, val) }
}

// AMAIR_EL2 (Auxiliary Memory Attribute Indirection Register (EL2))
// Provides IMPLEMENTATION DEFINED memory attributes for the memory regions specified by MAIR_EL2.
namespace amair_el2
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(amair_el2) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(amair_el2, val) }
}

// AMAIR_EL3 (Auxiliary Memory Attribute Indirection Register (EL3))
// Provides IMPLEMENTATION DEFINED memory attributes for the memory regions specified by MAIR_EL3.
namespace amair_el3
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(amair_el3) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(amair_el3, val) }
}

// APDAKeyHi_EL1 (Pointer Authentication Key A for Data (bits[127:64]) )
// See the ARMv8 architecture reference manual for a description of this register
namespace apdakeyhi_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(apdakeyhi_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(apdakeyhi_el1, val) }

	namespace 64_bit_value,_bits_127:64__of_the_128_bit_pointer_authentication_key_value
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(apdakeyhi_el1, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t apdakeyhi_el1_val) noexcept { GET_BITFIELD_FUNC(apdakeyhi_el1_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(apdakeyhi_el1, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t apdakeyhi_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(apdakeyhi_el1, value, 0xffffffffffffffff, 0) }
	}
}

// APDAKeyLo_EL1 (Pointer Authentication Key A for Data (bits[63:0]) )
// See the ARMv8 architecture reference manual for a description of this register
namespace apdakeylo_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(apdakeylo_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(apdakeylo_el1, val) }

	namespace 64_bit_value,_bits_63:0__of_the_128_bit_pointer_authentication_key_value
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(apdakeylo_el1, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t apdakeylo_el1_val) noexcept { GET_BITFIELD_FUNC(apdakeylo_el1_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(apdakeylo_el1, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t apdakeylo_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(apdakeylo_el1, value, 0xffffffffffffffff, 0) }
	}
}

// APDBKeyHi_EL1 (Pointer Authentication Key B for Data (bits[127:64]) )
// See the ARMv8 architecture reference manual for a description of this register
namespace apdbkeyhi_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(apdbkeyhi_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(apdbkeyhi_el1, val) }

	namespace 64_bit_value,_bits_127:64__of_the_128_bit_pointer_authentication_key_value
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(apdbkeyhi_el1, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t apdbkeyhi_el1_val) noexcept { GET_BITFIELD_FUNC(apdbkeyhi_el1_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(apdbkeyhi_el1, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t apdbkeyhi_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(apdbkeyhi_el1, value, 0xffffffffffffffff, 0) }
	}
}

// APDBKeyLo_EL1 (Pointer Authentication Key B for Data (bits[63:0]) )
// See the ARMv8 architecture reference manual for a description of this register
namespace apdbkeylo_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(apdbkeylo_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(apdbkeylo_el1, val) }

	namespace 64_bit_value,_bits_63:0__of_the_128_bit_pointer_authentication_key_value
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(apdbkeylo_el1, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t apdbkeylo_el1_val) noexcept { GET_BITFIELD_FUNC(apdbkeylo_el1_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(apdbkeylo_el1, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t apdbkeylo_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(apdbkeylo_el1, value, 0xffffffffffffffff, 0) }
	}
}

// APGAKeyHi_EL1 (Pointer Authentication Key A for Code (bits[127:64]) )
// See the ARMv8 architecture reference manual for a description of this register
namespace apgakeyhi_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(apgakeyhi_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(apgakeyhi_el1, val) }

	namespace 64_bit_value,_bits_127:64__of_the_128_bit_pointer_authentication_key_value
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(apgakeyhi_el1, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t apgakeyhi_el1_val) noexcept { GET_BITFIELD_FUNC(apgakeyhi_el1_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(apgakeyhi_el1, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t apgakeyhi_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(apgakeyhi_el1, value, 0xffffffffffffffff, 0) }
	}
}

// APGAKeyLo_EL1 (Pointer Authentication Key A for Code  (bits[63:0]) )
// See the ARMv8 architecture reference manual for a description of this register
namespace apgakeylo_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(apgakeylo_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(apgakeylo_el1, val) }

	namespace 64_bit_value,_bits_63:0__of_the_128_bit_pointer_authentication_key_value
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(apgakeylo_el1, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t apgakeylo_el1_val) noexcept { GET_BITFIELD_FUNC(apgakeylo_el1_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(apgakeylo_el1, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t apgakeylo_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(apgakeylo_el1, value, 0xffffffffffffffff, 0) }
	}
}

// APIAKeyHi_EL1 (Pointer Authentication Key A for Instruction (bits[127:64]) )
// See the ARMv8 architecture reference manual for a description of this register
namespace apiakeyhi_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(apiakeyhi_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(apiakeyhi_el1, val) }

	namespace 64_bit_value,_bits_127:64__of_the_128_bit_pointer_authentication_key_value
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(apiakeyhi_el1, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t apiakeyhi_el1_val) noexcept { GET_BITFIELD_FUNC(apiakeyhi_el1_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(apiakeyhi_el1, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t apiakeyhi_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(apiakeyhi_el1, value, 0xffffffffffffffff, 0) }
	}
}

// APIAKeyLo_EL1 (Pointer Authentication Key A for Instruction (bits[63:0]) )
// See the ARMv8 architecture reference manual for a description of this register
namespace apiakeylo_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(apiakeylo_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(apiakeylo_el1, val) }

	namespace 64_bit_value,_bits_63:0__of_the_128_bit_pointer_authentication_key_value
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(apiakeylo_el1, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t apiakeylo_el1_val) noexcept { GET_BITFIELD_FUNC(apiakeylo_el1_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(apiakeylo_el1, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t apiakeylo_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(apiakeylo_el1, value, 0xffffffffffffffff, 0) }
	}
}

// APIBKeyHi_EL1 (Pointer Authentication Key B for Instruction (bits[127:64]) )
// See the ARMv8 architecture reference manual for a description of this register
namespace apibkeyhi_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(apibkeyhi_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(apibkeyhi_el1, val) }

	namespace 64_bit_value,_bits_127:64__of_the_128_bit_pointer_authentication_key_value
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(apibkeyhi_el1, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t apibkeyhi_el1_val) noexcept { GET_BITFIELD_FUNC(apibkeyhi_el1_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(apibkeyhi_el1, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t apibkeyhi_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(apibkeyhi_el1, value, 0xffffffffffffffff, 0) }
	}
}

// APIBKeyLo_EL1 (Pointer Authentication Key B for Instruction (bits[63:0]) )
// See the ARMv8 architecture reference manual for a description of this register
namespace apibkeylo_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(apibkeylo_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(apibkeylo_el1, val) }

	namespace 64_bit_value,_bits_63:0__of_the_128_bit_pointer_authentication_key_value
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(apibkeylo_el1, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t apibkeylo_el1_val) noexcept { GET_BITFIELD_FUNC(apibkeylo_el1_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(apibkeylo_el1, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t apibkeylo_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(apibkeylo_el1, value, 0xffffffffffffffff, 0) }
	}
}

// AT S12E0R (Address Translate Stages 1 and 2 EL0 Read)
// See the ARMv8 architecture reference manual for a description of this register
namespace at s12e0r
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(at s12e0r) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(at s12e0r, val) }

	namespace input_address_for_translation
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(at s12e0r, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t at s12e0r_val) noexcept { GET_BITFIELD_FUNC(at s12e0r_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(at s12e0r, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t at s12e0r, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(at s12e0r, value, 0xffffffffffffffff, 0) }
	}
}

// AT S12E0W (Address Translate Stages 1 and 2 EL0 Write)
// See the ARMv8 architecture reference manual for a description of this register
namespace at s12e0w
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(at s12e0w) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(at s12e0w, val) }

	namespace input_address_for_translation
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(at s12e0w, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t at s12e0w_val) noexcept { GET_BITFIELD_FUNC(at s12e0w_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(at s12e0w, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t at s12e0w, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(at s12e0w, value, 0xffffffffffffffff, 0) }
	}
}

// AT S12E1R (Address Translate Stages 1 and 2 EL1 Read)
// See the ARMv8 architecture reference manual for a description of this register
namespace at s12e1r
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(at s12e1r) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(at s12e1r, val) }

	namespace input_address_for_translation
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(at s12e1r, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t at s12e1r_val) noexcept { GET_BITFIELD_FUNC(at s12e1r_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(at s12e1r, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t at s12e1r, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(at s12e1r, value, 0xffffffffffffffff, 0) }
	}
}

// AT S12E1W (Address Translate Stages 1 and 2 EL1 Write)
// See the ARMv8 architecture reference manual for a description of this register
namespace at s12e1w
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(at s12e1w) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(at s12e1w, val) }

	namespace input_address_for_translation
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(at s12e1w, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t at s12e1w_val) noexcept { GET_BITFIELD_FUNC(at s12e1w_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(at s12e1w, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t at s12e1w, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(at s12e1w, value, 0xffffffffffffffff, 0) }
	}
}

// AT S1E0R (Address Translate Stage 1 EL0 Read)
// See the ARMv8 architecture reference manual for a description of this register
namespace at s1e0r
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(at s1e0r) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(at s1e0r, val) }

	namespace input_address_for_translation
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(at s1e0r, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t at s1e0r_val) noexcept { GET_BITFIELD_FUNC(at s1e0r_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(at s1e0r, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t at s1e0r, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(at s1e0r, value, 0xffffffffffffffff, 0) }
	}
}

// AT S1E0W (Address Translate Stage 1 EL0 Write)
// See the ARMv8 architecture reference manual for a description of this register
namespace at s1e0w
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(at s1e0w) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(at s1e0w, val) }

	namespace input_address_for_translation
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(at s1e0w, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t at s1e0w_val) noexcept { GET_BITFIELD_FUNC(at s1e0w_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(at s1e0w, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t at s1e0w, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(at s1e0w, value, 0xffffffffffffffff, 0) }
	}
}

// AT S1E1R (Address Translate Stage 1 EL1 Read)
// See the ARMv8 architecture reference manual for a description of this register
namespace at s1e1r
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(at s1e1r) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(at s1e1r, val) }

	namespace input_address_for_translation
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(at s1e1r, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t at s1e1r_val) noexcept { GET_BITFIELD_FUNC(at s1e1r_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(at s1e1r, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t at s1e1r, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(at s1e1r, value, 0xffffffffffffffff, 0) }
	}
}

// AT S1E1RP (Address Translate Stage 1 EL1 Read PAN)
// See the ARMv8 architecture reference manual for a description of this register
namespace at s1e1rp
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(at s1e1rp) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(at s1e1rp, val) }

	namespace input_address_for_translation
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(at s1e1rp, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t at s1e1rp_val) noexcept { GET_BITFIELD_FUNC(at s1e1rp_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(at s1e1rp, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t at s1e1rp, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(at s1e1rp, value, 0xffffffffffffffff, 0) }
	}
}

// AT S1E1W (Address Translate Stage 1 EL1 Write)
// See the ARMv8 architecture reference manual for a description of this register
namespace at s1e1w
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(at s1e1w) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(at s1e1w, val) }

	namespace input_address_for_translation
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(at s1e1w, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t at s1e1w_val) noexcept { GET_BITFIELD_FUNC(at s1e1w_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(at s1e1w, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t at s1e1w, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(at s1e1w, value, 0xffffffffffffffff, 0) }
	}
}

// AT S1E1WP (Address Translate Stage 1 EL1 Write PAN)
// See the ARMv8 architecture reference manual for a description of this register
namespace at s1e1wp
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(at s1e1wp) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(at s1e1wp, val) }

	namespace input_address_for_translation
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(at s1e1wp, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t at s1e1wp_val) noexcept { GET_BITFIELD_FUNC(at s1e1wp_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(at s1e1wp, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t at s1e1wp, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(at s1e1wp, value, 0xffffffffffffffff, 0) }
	}
}

// AT S1E2R (Address Translate Stage 1 EL2 Read)
// Performs stage 1 address translation as defined for EL2, with permissions as if reading from the given virtual address.
namespace at s1e2r
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(at s1e2r) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(at s1e2r, val) }

	namespace input_address_for_translation
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(at s1e2r, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t at s1e2r_val) noexcept { GET_BITFIELD_FUNC(at s1e2r_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(at s1e2r, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t at s1e2r, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(at s1e2r, value, 0xffffffffffffffff, 0) }
	}
}

// AT S1E2W (Address Translate Stage 1 EL2 Write)
// Performs stage 1 address translation as defined for EL2, with permissions as if writing to the given virtual address.
namespace at s1e2w
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(at s1e2w) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(at s1e2w, val) }

	namespace input_address_for_translation
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(at s1e2w, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t at s1e2w_val) noexcept { GET_BITFIELD_FUNC(at s1e2w_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(at s1e2w, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t at s1e2w, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(at s1e2w, value, 0xffffffffffffffff, 0) }
	}
}

// AT S1E3R (Address Translate Stage 1 EL3 Read)
// Performs stage 1 address translation as defined for EL3, with permissions as if reading from the given virtual address.
namespace at s1e3r
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(at s1e3r) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(at s1e3r, val) }

	namespace input_address_for_translation
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(at s1e3r, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t at s1e3r_val) noexcept { GET_BITFIELD_FUNC(at s1e3r_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(at s1e3r, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t at s1e3r, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(at s1e3r, value, 0xffffffffffffffff, 0) }
	}
}

// AT S1E3W (Address Translate Stage 1 EL3 Write)
// Performs stage 1 address translation as defined for EL3, with permissions as if writing to the given virtual address.
namespace at s1e3w
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(at s1e3w) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(at s1e3w, val) }

	namespace input_address_for_translation
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(at s1e3w, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t at s1e3w_val) noexcept { GET_BITFIELD_FUNC(at s1e3w_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(at s1e3w, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t at s1e3w, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(at s1e3w, value, 0xffffffffffffffff, 0) }
	}
}

// CCSIDR2_EL1 (Current Cache Size ID Register 2)
// See the ARMv8 architecture reference manual for a description of this register
namespace ccsidr2_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ccsidr2_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ccsidr2_el1, val) }

	namespace numsets
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ccsidr2_el1, 0xffffff, 0) }
		inline uint32_t get(uint32_t ccsidr2_el1_val) noexcept { GET_BITFIELD_FUNC(ccsidr2_el1_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ccsidr2_el1, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t ccsidr2_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ccsidr2_el1, value, 0xffffff, 0) }
	}
}

// CCSIDR_EL1 (Current Cache Size ID Register)
// Provides information about the architecture of the currently selected cache.
namespace ccsidr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ccsidr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ccsidr_el1, val) }

	// Fieldset valid when: ID_AA64MMFR2_EL1.CCIDX==0000
	namespace fieldset_1
	{
		namespace unknown
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ccsidr_el1, 0xf0000000, 28) }
			inline uint32_t get(uint32_t ccsidr_el1_val) noexcept { GET_BITFIELD_FUNC(ccsidr_el1_val, 0xf0000000, 28) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ccsidr_el1, value, 0xf0000000, 28) }
			inline uint32_t set(uint32_t ccsidr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ccsidr_el1, value, 0xf0000000, 28) }
		}

		namespace numsets
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ccsidr_el1, 0xfffe000, 13) }
			inline uint32_t get(uint32_t ccsidr_el1_val) noexcept { GET_BITFIELD_FUNC(ccsidr_el1_val, 0xfffe000, 13) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ccsidr_el1, value, 0xfffe000, 13) }
			inline uint32_t set(uint32_t ccsidr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ccsidr_el1, value, 0xfffe000, 13) }
		}

		namespace associativity
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ccsidr_el1, 0x1ff8, 3) }
			inline uint32_t get(uint32_t ccsidr_el1_val) noexcept { GET_BITFIELD_FUNC(ccsidr_el1_val, 0x1ff8, 3) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ccsidr_el1, value, 0x1ff8, 3) }
			inline uint32_t set(uint32_t ccsidr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ccsidr_el1, value, 0x1ff8, 3) }
		}

		namespace linesize
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ccsidr_el1, 0x7, 0) }
			inline uint32_t get(uint32_t ccsidr_el1_val) noexcept { GET_BITFIELD_FUNC(ccsidr_el1_val, 0x7, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ccsidr_el1, value, 0x7, 0) }
			inline uint32_t set(uint32_t ccsidr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ccsidr_el1, value, 0x7, 0) }
		}
	}

	// Fieldset valid when: ID_AA64MMFR2_EL1.CCIDX==0001
	namespace fieldset_2
	{	}
}

// CLIDR_EL1 (Cache Level ID Register)
// Identifies the type of cache, or caches, that are implemented at each level and can be managed using the architected cache maintenance instructions that operate by set/way, up to a maximum of seven levels. Also identifies the Level of Coherence (LoC) and Level of Unification (LoU) for the cache hierarchy.
namespace clidr_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(clidr_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(clidr_el1, val) }

	namespace icb
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(clidr_el1, 0x1c0000000, 30) }
		inline uint64_t get(uint64_t clidr_el1_val) noexcept { GET_BITFIELD_FUNC(clidr_el1_val, 0x1c0000000, 30) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(clidr_el1, value, 0x1c0000000, 30) }
		inline uint64_t set(uint64_t clidr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(clidr_el1, value, 0x1c0000000, 30) }
	}

	namespace louu
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(clidr_el1, 0x38000000, 27) }
		inline uint64_t get(uint64_t clidr_el1_val) noexcept { GET_BITFIELD_FUNC(clidr_el1_val, 0x38000000, 27) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(clidr_el1, value, 0x38000000, 27) }
		inline uint64_t set(uint64_t clidr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(clidr_el1, value, 0x38000000, 27) }
	}

	namespace loc
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(clidr_el1, 0x7000000, 24) }
		inline uint64_t get(uint64_t clidr_el1_val) noexcept { GET_BITFIELD_FUNC(clidr_el1_val, 0x7000000, 24) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(clidr_el1, value, 0x7000000, 24) }
		inline uint64_t set(uint64_t clidr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(clidr_el1, value, 0x7000000, 24) }
	}

	namespace louis
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(clidr_el1, 0xe00000, 21) }
		inline uint64_t get(uint64_t clidr_el1_val) noexcept { GET_BITFIELD_FUNC(clidr_el1_val, 0xe00000, 21) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(clidr_el1, value, 0xe00000, 21) }
		inline uint64_t set(uint64_t clidr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(clidr_el1, value, 0xe00000, 21) }
	}

	namespace ctype_n_
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(clidr_el1, 0x1fffff, 0) }
		inline uint64_t get(uint64_t clidr_el1_val) noexcept { GET_BITFIELD_FUNC(clidr_el1_val, 0x1fffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(clidr_el1, value, 0x1fffff, 0) }
		inline uint64_t set(uint64_t clidr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(clidr_el1, value, 0x1fffff, 0) }
	}
}

// CNTFRQ_EL0 (Counter-timer Frequency register)
// This register is provided so that software can discover the frequency of the system counter. It must be programmed with this value as part of system initialization. The value of the register is not interpreted by hardware.
namespace cntfrq_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntfrq_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntfrq_el0, val) }

	namespace clock_frequency
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntfrq_el0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t cntfrq_el0_val) noexcept { GET_BITFIELD_FUNC(cntfrq_el0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntfrq_el0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t cntfrq_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntfrq_el0, value, 0xffffffff, 0) }
	}
}

// CNTHCTL_EL2 (Counter-timer Hypervisor Control register)
// Controls the generation of an event stream from the physical counter, and access from Non-secure EL1 to the physical counter and the Non-secure EL1 physical timer.
namespace cnthctl_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cnthctl_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cnthctl_el2, val) }

	// Fieldset valid when: HCR_EL2.E2H == 0
	namespace fieldset_1
	{
		namespace evnti
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cnthctl_el2, 0xf0, 4) }
			inline uint32_t get(uint32_t cnthctl_el2_val) noexcept { GET_BITFIELD_FUNC(cnthctl_el2_val, 0xf0, 4) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cnthctl_el2, value, 0xf0, 4) }
			inline uint32_t set(uint32_t cnthctl_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cnthctl_el2, value, 0xf0, 4) }
		}

		namespace evntdir
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthctl_el2, 3) }
			inline uint32_t is_enabled(uint32_t cnthctl_el2_val) noexcept { IS_BIT_ENABLED_FUNC(cnthctl_el2_val, 3) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthctl_el2, 3) }
			inline uint32_t is_disabled(uint32_t cnthctl_el2_val) noexcept { IS_BIT_DISABLED_FUNC(cnthctl_el2_val, 3) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthctl_el2, 0x8) }
			inline uint32_t enable(uint32_t cnthctl_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthctl_el2_val, 0x8) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthctl_el2, 0x8) }
			inline uint32_t disable(uint32_t cnthctl_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthctl_el2_val, 0x8) }
		}

		namespace evnten
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthctl_el2, 2) }
			inline uint32_t is_enabled(uint32_t cnthctl_el2_val) noexcept { IS_BIT_ENABLED_FUNC(cnthctl_el2_val, 2) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthctl_el2, 2) }
			inline uint32_t is_disabled(uint32_t cnthctl_el2_val) noexcept { IS_BIT_DISABLED_FUNC(cnthctl_el2_val, 2) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthctl_el2, 0x4) }
			inline uint32_t enable(uint32_t cnthctl_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthctl_el2_val, 0x4) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthctl_el2, 0x4) }
			inline uint32_t disable(uint32_t cnthctl_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthctl_el2_val, 0x4) }
		}

		namespace el1pcen
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthctl_el2, 1) }
			inline uint32_t is_enabled(uint32_t cnthctl_el2_val) noexcept { IS_BIT_ENABLED_FUNC(cnthctl_el2_val, 1) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthctl_el2, 1) }
			inline uint32_t is_disabled(uint32_t cnthctl_el2_val) noexcept { IS_BIT_DISABLED_FUNC(cnthctl_el2_val, 1) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthctl_el2, 0x2) }
			inline uint32_t enable(uint32_t cnthctl_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthctl_el2_val, 0x2) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthctl_el2, 0x2) }
			inline uint32_t disable(uint32_t cnthctl_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthctl_el2_val, 0x2) }
		}

		namespace el1pcten
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthctl_el2, 0) }
			inline uint32_t is_enabled(uint32_t cnthctl_el2_val) noexcept { IS_BIT_ENABLED_FUNC(cnthctl_el2_val, 0) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthctl_el2, 0) }
			inline uint32_t is_disabled(uint32_t cnthctl_el2_val) noexcept { IS_BIT_DISABLED_FUNC(cnthctl_el2_val, 0) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthctl_el2, 0x1) }
			inline uint32_t enable(uint32_t cnthctl_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthctl_el2_val, 0x1) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthctl_el2, 0x1) }
			inline uint32_t disable(uint32_t cnthctl_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthctl_el2_val, 0x1) }
		}
	}

	// Fieldset valid when: HCR_EL2.E2H == 1
	namespace fieldset_2
	{
		namespace el1pten
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthctl_el2, 11) }
			inline uint32_t is_enabled(uint32_t cnthctl_el2_val) noexcept { IS_BIT_ENABLED_FUNC(cnthctl_el2_val, 11) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthctl_el2, 11) }
			inline uint32_t is_disabled(uint32_t cnthctl_el2_val) noexcept { IS_BIT_DISABLED_FUNC(cnthctl_el2_val, 11) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthctl_el2, 0x800) }
			inline uint32_t enable(uint32_t cnthctl_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthctl_el2_val, 0x800) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthctl_el2, 0x800) }
			inline uint32_t disable(uint32_t cnthctl_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthctl_el2_val, 0x800) }
		}

		namespace el1pcten
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthctl_el2, 10) }
			inline uint32_t is_enabled(uint32_t cnthctl_el2_val) noexcept { IS_BIT_ENABLED_FUNC(cnthctl_el2_val, 10) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthctl_el2, 10) }
			inline uint32_t is_disabled(uint32_t cnthctl_el2_val) noexcept { IS_BIT_DISABLED_FUNC(cnthctl_el2_val, 10) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthctl_el2, 0x400) }
			inline uint32_t enable(uint32_t cnthctl_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthctl_el2_val, 0x400) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthctl_el2, 0x400) }
			inline uint32_t disable(uint32_t cnthctl_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthctl_el2_val, 0x400) }
		}

		namespace el0pten
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthctl_el2, 9) }
			inline uint32_t is_enabled(uint32_t cnthctl_el2_val) noexcept { IS_BIT_ENABLED_FUNC(cnthctl_el2_val, 9) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthctl_el2, 9) }
			inline uint32_t is_disabled(uint32_t cnthctl_el2_val) noexcept { IS_BIT_DISABLED_FUNC(cnthctl_el2_val, 9) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthctl_el2, 0x200) }
			inline uint32_t enable(uint32_t cnthctl_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthctl_el2_val, 0x200) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthctl_el2, 0x200) }
			inline uint32_t disable(uint32_t cnthctl_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthctl_el2_val, 0x200) }
		}

		namespace el0vten
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthctl_el2, 8) }
			inline uint32_t is_enabled(uint32_t cnthctl_el2_val) noexcept { IS_BIT_ENABLED_FUNC(cnthctl_el2_val, 8) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthctl_el2, 8) }
			inline uint32_t is_disabled(uint32_t cnthctl_el2_val) noexcept { IS_BIT_DISABLED_FUNC(cnthctl_el2_val, 8) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthctl_el2, 0x100) }
			inline uint32_t enable(uint32_t cnthctl_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthctl_el2_val, 0x100) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthctl_el2, 0x100) }
			inline uint32_t disable(uint32_t cnthctl_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthctl_el2_val, 0x100) }
		}

		namespace evnti
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cnthctl_el2, 0xf0, 4) }
			inline uint32_t get(uint32_t cnthctl_el2_val) noexcept { GET_BITFIELD_FUNC(cnthctl_el2_val, 0xf0, 4) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cnthctl_el2, value, 0xf0, 4) }
			inline uint32_t set(uint32_t cnthctl_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cnthctl_el2, value, 0xf0, 4) }
		}

		namespace evntdir
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthctl_el2, 3) }
			inline uint32_t is_enabled(uint32_t cnthctl_el2_val) noexcept { IS_BIT_ENABLED_FUNC(cnthctl_el2_val, 3) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthctl_el2, 3) }
			inline uint32_t is_disabled(uint32_t cnthctl_el2_val) noexcept { IS_BIT_DISABLED_FUNC(cnthctl_el2_val, 3) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthctl_el2, 0x8) }
			inline uint32_t enable(uint32_t cnthctl_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthctl_el2_val, 0x8) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthctl_el2, 0x8) }
			inline uint32_t disable(uint32_t cnthctl_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthctl_el2_val, 0x8) }
		}

		namespace evnten
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthctl_el2, 2) }
			inline uint32_t is_enabled(uint32_t cnthctl_el2_val) noexcept { IS_BIT_ENABLED_FUNC(cnthctl_el2_val, 2) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthctl_el2, 2) }
			inline uint32_t is_disabled(uint32_t cnthctl_el2_val) noexcept { IS_BIT_DISABLED_FUNC(cnthctl_el2_val, 2) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthctl_el2, 0x4) }
			inline uint32_t enable(uint32_t cnthctl_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthctl_el2_val, 0x4) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthctl_el2, 0x4) }
			inline uint32_t disable(uint32_t cnthctl_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthctl_el2_val, 0x4) }
		}

		namespace el0vcten
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthctl_el2, 1) }
			inline uint32_t is_enabled(uint32_t cnthctl_el2_val) noexcept { IS_BIT_ENABLED_FUNC(cnthctl_el2_val, 1) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthctl_el2, 1) }
			inline uint32_t is_disabled(uint32_t cnthctl_el2_val) noexcept { IS_BIT_DISABLED_FUNC(cnthctl_el2_val, 1) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthctl_el2, 0x2) }
			inline uint32_t enable(uint32_t cnthctl_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthctl_el2_val, 0x2) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthctl_el2, 0x2) }
			inline uint32_t disable(uint32_t cnthctl_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthctl_el2_val, 0x2) }
		}

		namespace el0pcten
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthctl_el2, 0) }
			inline uint32_t is_enabled(uint32_t cnthctl_el2_val) noexcept { IS_BIT_ENABLED_FUNC(cnthctl_el2_val, 0) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthctl_el2, 0) }
			inline uint32_t is_disabled(uint32_t cnthctl_el2_val) noexcept { IS_BIT_DISABLED_FUNC(cnthctl_el2_val, 0) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthctl_el2, 0x1) }
			inline uint32_t enable(uint32_t cnthctl_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthctl_el2_val, 0x1) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthctl_el2, 0x1) }
			inline uint32_t disable(uint32_t cnthctl_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthctl_el2_val, 0x1) }
		}
	}
}

// CNTHP_CTL_EL2 (Counter-timer Hypervisor Physical Timer Control register)
// Control register for the EL2 physical timer.
namespace cnthp_ctl_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cnthp_ctl_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cnthp_ctl_el2, val) }

	namespace istatus
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthp_ctl_el2, 2) }
		inline uint32_t is_enabled(uint32_t cnthp_ctl_el2_val) noexcept { IS_BIT_ENABLED_FUNC(cnthp_ctl_el2_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthp_ctl_el2, 2) }
		inline uint32_t is_disabled(uint32_t cnthp_ctl_el2_val) noexcept { IS_BIT_DISABLED_FUNC(cnthp_ctl_el2_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthp_ctl_el2, 0x4) }
		inline uint32_t enable(uint32_t cnthp_ctl_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthp_ctl_el2_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthp_ctl_el2, 0x4) }
		inline uint32_t disable(uint32_t cnthp_ctl_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthp_ctl_el2_val, 0x4) }
	}

	namespace imask
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthp_ctl_el2, 1) }
		inline uint32_t is_enabled(uint32_t cnthp_ctl_el2_val) noexcept { IS_BIT_ENABLED_FUNC(cnthp_ctl_el2_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthp_ctl_el2, 1) }
		inline uint32_t is_disabled(uint32_t cnthp_ctl_el2_val) noexcept { IS_BIT_DISABLED_FUNC(cnthp_ctl_el2_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthp_ctl_el2, 0x2) }
		inline uint32_t enable(uint32_t cnthp_ctl_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthp_ctl_el2_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthp_ctl_el2, 0x2) }
		inline uint32_t disable(uint32_t cnthp_ctl_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthp_ctl_el2_val, 0x2) }
	}

	namespace enable
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthp_ctl_el2, 0) }
		inline uint32_t is_enabled(uint32_t cnthp_ctl_el2_val) noexcept { IS_BIT_ENABLED_FUNC(cnthp_ctl_el2_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthp_ctl_el2, 0) }
		inline uint32_t is_disabled(uint32_t cnthp_ctl_el2_val) noexcept { IS_BIT_DISABLED_FUNC(cnthp_ctl_el2_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthp_ctl_el2, 0x1) }
		inline uint32_t enable(uint32_t cnthp_ctl_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthp_ctl_el2_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthp_ctl_el2, 0x1) }
		inline uint32_t disable(uint32_t cnthp_ctl_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthp_ctl_el2_val, 0x1) }
	}
}

// CNTHP_CVAL_EL2 (Counter-timer Hypervisor Physical Timer CompareValue register)
// Holds the compare value for the EL2 physical timer.
namespace cnthp_cval_el2
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(cnthp_cval_el2) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cnthp_cval_el2, val) }

	namespace comparevalue
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(cnthp_cval_el2, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t cnthp_cval_el2_val) noexcept { GET_BITFIELD_FUNC(cnthp_cval_el2_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cnthp_cval_el2, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t cnthp_cval_el2, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cnthp_cval_el2, value, 0xffffffffffffffff, 0) }
	}
}

// CNTHP_TVAL_EL2 (Counter-timer Hypervisor Physical Timer TimerValue register)
// Holds the timer value for the EL2 physical timer.
namespace cnthp_tval_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cnthp_tval_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cnthp_tval_el2, val) }

	namespace timervalue
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cnthp_tval_el2, 0xffffffff, 0) }
		inline uint32_t get(uint32_t cnthp_tval_el2_val) noexcept { GET_BITFIELD_FUNC(cnthp_tval_el2_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cnthp_tval_el2, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t cnthp_tval_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cnthp_tval_el2, value, 0xffffffff, 0) }
	}
}

// CNTHV_CTL_EL2 (Counter-timer Virtual Timer Control register (EL2))
// Control register for the EL2 virtual timer.
namespace cnthv_ctl_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cnthv_ctl_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cnthv_ctl_el2, val) }

	namespace istatus
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthv_ctl_el2, 2) }
		inline uint32_t is_enabled(uint32_t cnthv_ctl_el2_val) noexcept { IS_BIT_ENABLED_FUNC(cnthv_ctl_el2_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthv_ctl_el2, 2) }
		inline uint32_t is_disabled(uint32_t cnthv_ctl_el2_val) noexcept { IS_BIT_DISABLED_FUNC(cnthv_ctl_el2_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthv_ctl_el2, 0x4) }
		inline uint32_t enable(uint32_t cnthv_ctl_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthv_ctl_el2_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthv_ctl_el2, 0x4) }
		inline uint32_t disable(uint32_t cnthv_ctl_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthv_ctl_el2_val, 0x4) }
	}

	namespace imask
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthv_ctl_el2, 1) }
		inline uint32_t is_enabled(uint32_t cnthv_ctl_el2_val) noexcept { IS_BIT_ENABLED_FUNC(cnthv_ctl_el2_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthv_ctl_el2, 1) }
		inline uint32_t is_disabled(uint32_t cnthv_ctl_el2_val) noexcept { IS_BIT_DISABLED_FUNC(cnthv_ctl_el2_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthv_ctl_el2, 0x2) }
		inline uint32_t enable(uint32_t cnthv_ctl_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthv_ctl_el2_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthv_ctl_el2, 0x2) }
		inline uint32_t disable(uint32_t cnthv_ctl_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthv_ctl_el2_val, 0x2) }
	}

	namespace enable
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cnthv_ctl_el2, 0) }
		inline uint32_t is_enabled(uint32_t cnthv_ctl_el2_val) noexcept { IS_BIT_ENABLED_FUNC(cnthv_ctl_el2_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cnthv_ctl_el2, 0) }
		inline uint32_t is_disabled(uint32_t cnthv_ctl_el2_val) noexcept { IS_BIT_DISABLED_FUNC(cnthv_ctl_el2_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cnthv_ctl_el2, 0x1) }
		inline uint32_t enable(uint32_t cnthv_ctl_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(cnthv_ctl_el2_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cnthv_ctl_el2, 0x1) }
		inline uint32_t disable(uint32_t cnthv_ctl_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cnthv_ctl_el2_val, 0x1) }
	}
}

// CNTHV_CVAL_EL2 (Counter-timer Virtual Timer CompareValue register (EL2))
// Holds the compare value for the EL2 virtual timer.
namespace cnthv_cval_el2
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(cnthv_cval_el2) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cnthv_cval_el2, val) }

	namespace comparevalue
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(cnthv_cval_el2, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t cnthv_cval_el2_val) noexcept { GET_BITFIELD_FUNC(cnthv_cval_el2_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cnthv_cval_el2, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t cnthv_cval_el2, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cnthv_cval_el2, value, 0xffffffffffffffff, 0) }
	}
}

// CNTHV_TVAL_EL2 (Counter-timer Virtual Timer TimerValue register (EL2))
// Holds the timer value for the EL2 virtual timer.
namespace cnthv_tval_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cnthv_tval_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cnthv_tval_el2, val) }

	namespace timervalue
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cnthv_tval_el2, 0xffffffff, 0) }
		inline uint32_t get(uint32_t cnthv_tval_el2_val) noexcept { GET_BITFIELD_FUNC(cnthv_tval_el2_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cnthv_tval_el2, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t cnthv_tval_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cnthv_tval_el2, value, 0xffffffff, 0) }
	}
}

// CNTKCTL_EL1 (Counter-timer Kernel Control register)
// See the ARMv8 architecture reference manual for a description of this register
namespace cntkctl_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntkctl_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntkctl_el1, val) }

	namespace el0pten
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntkctl_el1, 9) }
		inline uint32_t is_enabled(uint32_t cntkctl_el1_val) noexcept { IS_BIT_ENABLED_FUNC(cntkctl_el1_val, 9) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntkctl_el1, 9) }
		inline uint32_t is_disabled(uint32_t cntkctl_el1_val) noexcept { IS_BIT_DISABLED_FUNC(cntkctl_el1_val, 9) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntkctl_el1, 0x200) }
		inline uint32_t enable(uint32_t cntkctl_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(cntkctl_el1_val, 0x200) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntkctl_el1, 0x200) }
		inline uint32_t disable(uint32_t cntkctl_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntkctl_el1_val, 0x200) }
	}

	namespace el0vten
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntkctl_el1, 8) }
		inline uint32_t is_enabled(uint32_t cntkctl_el1_val) noexcept { IS_BIT_ENABLED_FUNC(cntkctl_el1_val, 8) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntkctl_el1, 8) }
		inline uint32_t is_disabled(uint32_t cntkctl_el1_val) noexcept { IS_BIT_DISABLED_FUNC(cntkctl_el1_val, 8) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntkctl_el1, 0x100) }
		inline uint32_t enable(uint32_t cntkctl_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(cntkctl_el1_val, 0x100) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntkctl_el1, 0x100) }
		inline uint32_t disable(uint32_t cntkctl_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntkctl_el1_val, 0x100) }
	}

	namespace evnti
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntkctl_el1, 0xf0, 4) }
		inline uint32_t get(uint32_t cntkctl_el1_val) noexcept { GET_BITFIELD_FUNC(cntkctl_el1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntkctl_el1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t cntkctl_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntkctl_el1, value, 0xf0, 4) }
	}

	namespace evntdir
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntkctl_el1, 3) }
		inline uint32_t is_enabled(uint32_t cntkctl_el1_val) noexcept { IS_BIT_ENABLED_FUNC(cntkctl_el1_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntkctl_el1, 3) }
		inline uint32_t is_disabled(uint32_t cntkctl_el1_val) noexcept { IS_BIT_DISABLED_FUNC(cntkctl_el1_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntkctl_el1, 0x8) }
		inline uint32_t enable(uint32_t cntkctl_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(cntkctl_el1_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntkctl_el1, 0x8) }
		inline uint32_t disable(uint32_t cntkctl_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntkctl_el1_val, 0x8) }
	}

	namespace evnten
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntkctl_el1, 2) }
		inline uint32_t is_enabled(uint32_t cntkctl_el1_val) noexcept { IS_BIT_ENABLED_FUNC(cntkctl_el1_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntkctl_el1, 2) }
		inline uint32_t is_disabled(uint32_t cntkctl_el1_val) noexcept { IS_BIT_DISABLED_FUNC(cntkctl_el1_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntkctl_el1, 0x4) }
		inline uint32_t enable(uint32_t cntkctl_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(cntkctl_el1_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntkctl_el1, 0x4) }
		inline uint32_t disable(uint32_t cntkctl_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntkctl_el1_val, 0x4) }
	}

	namespace el0vcten
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntkctl_el1, 1) }
		inline uint32_t is_enabled(uint32_t cntkctl_el1_val) noexcept { IS_BIT_ENABLED_FUNC(cntkctl_el1_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntkctl_el1, 1) }
		inline uint32_t is_disabled(uint32_t cntkctl_el1_val) noexcept { IS_BIT_DISABLED_FUNC(cntkctl_el1_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntkctl_el1, 0x2) }
		inline uint32_t enable(uint32_t cntkctl_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(cntkctl_el1_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntkctl_el1, 0x2) }
		inline uint32_t disable(uint32_t cntkctl_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntkctl_el1_val, 0x2) }
	}

	namespace el0pcten
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntkctl_el1, 0) }
		inline uint32_t is_enabled(uint32_t cntkctl_el1_val) noexcept { IS_BIT_ENABLED_FUNC(cntkctl_el1_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntkctl_el1, 0) }
		inline uint32_t is_disabled(uint32_t cntkctl_el1_val) noexcept { IS_BIT_DISABLED_FUNC(cntkctl_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntkctl_el1, 0x1) }
		inline uint32_t enable(uint32_t cntkctl_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(cntkctl_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntkctl_el1, 0x1) }
		inline uint32_t disable(uint32_t cntkctl_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntkctl_el1_val, 0x1) }
	}
}

// CNTP_CTL_EL0 (Counter-timer Physical Timer Control register)
// Control register for the EL1 physical timer.
namespace cntp_ctl_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntp_ctl_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntp_ctl_el0, val) }

	namespace istatus
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntp_ctl_el0, 2) }
		inline uint32_t is_enabled(uint32_t cntp_ctl_el0_val) noexcept { IS_BIT_ENABLED_FUNC(cntp_ctl_el0_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntp_ctl_el0, 2) }
		inline uint32_t is_disabled(uint32_t cntp_ctl_el0_val) noexcept { IS_BIT_DISABLED_FUNC(cntp_ctl_el0_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntp_ctl_el0, 0x4) }
		inline uint32_t enable(uint32_t cntp_ctl_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(cntp_ctl_el0_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntp_ctl_el0, 0x4) }
		inline uint32_t disable(uint32_t cntp_ctl_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntp_ctl_el0_val, 0x4) }
	}

	namespace imask
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntp_ctl_el0, 1) }
		inline uint32_t is_enabled(uint32_t cntp_ctl_el0_val) noexcept { IS_BIT_ENABLED_FUNC(cntp_ctl_el0_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntp_ctl_el0, 1) }
		inline uint32_t is_disabled(uint32_t cntp_ctl_el0_val) noexcept { IS_BIT_DISABLED_FUNC(cntp_ctl_el0_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntp_ctl_el0, 0x2) }
		inline uint32_t enable(uint32_t cntp_ctl_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(cntp_ctl_el0_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntp_ctl_el0, 0x2) }
		inline uint32_t disable(uint32_t cntp_ctl_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntp_ctl_el0_val, 0x2) }
	}

	namespace enable
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntp_ctl_el0, 0) }
		inline uint32_t is_enabled(uint32_t cntp_ctl_el0_val) noexcept { IS_BIT_ENABLED_FUNC(cntp_ctl_el0_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntp_ctl_el0, 0) }
		inline uint32_t is_disabled(uint32_t cntp_ctl_el0_val) noexcept { IS_BIT_DISABLED_FUNC(cntp_ctl_el0_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntp_ctl_el0, 0x1) }
		inline uint32_t enable(uint32_t cntp_ctl_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(cntp_ctl_el0_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntp_ctl_el0, 0x1) }
		inline uint32_t disable(uint32_t cntp_ctl_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntp_ctl_el0_val, 0x1) }
	}
}

// CNTP_CVAL_EL0 (Counter-timer Physical Timer CompareValue register)
// Holds the compare value for the EL1 physical timer.
namespace cntp_cval_el0
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(cntp_cval_el0) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntp_cval_el0, val) }

	namespace comparevalue
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntp_cval_el0, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t cntp_cval_el0_val) noexcept { GET_BITFIELD_FUNC(cntp_cval_el0_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntp_cval_el0, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t cntp_cval_el0, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntp_cval_el0, value, 0xffffffffffffffff, 0) }
	}
}

// CNTP_TVAL_EL0 (Counter-timer Physical Timer TimerValue register)
// Holds the timer value for the EL1 physical timer.
namespace cntp_tval_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntp_tval_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntp_tval_el0, val) }

	namespace timervalue
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntp_tval_el0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t cntp_tval_el0_val) noexcept { GET_BITFIELD_FUNC(cntp_tval_el0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntp_tval_el0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t cntp_tval_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntp_tval_el0, value, 0xffffffff, 0) }
	}
}

// CNTPCT_EL0 (Counter-timer Physical Count register)
// Holds the 64-bit physical count value.
namespace cntpct_el0
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(cntpct_el0) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntpct_el0, val) }

	namespace physical_count_value
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntpct_el0, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t cntpct_el0_val) noexcept { GET_BITFIELD_FUNC(cntpct_el0_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntpct_el0, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t cntpct_el0, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntpct_el0, value, 0xffffffffffffffff, 0) }
	}
}

// CNTPS_CTL_EL1 (Counter-timer Physical Secure Timer Control register)
// Control register for the secure physical timer, usually accessible at EL3 but configurably accessible at EL1 in Secure state.
namespace cntps_ctl_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntps_ctl_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntps_ctl_el1, val) }

	namespace istatus
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntps_ctl_el1, 2) }
		inline uint32_t is_enabled(uint32_t cntps_ctl_el1_val) noexcept { IS_BIT_ENABLED_FUNC(cntps_ctl_el1_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntps_ctl_el1, 2) }
		inline uint32_t is_disabled(uint32_t cntps_ctl_el1_val) noexcept { IS_BIT_DISABLED_FUNC(cntps_ctl_el1_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntps_ctl_el1, 0x4) }
		inline uint32_t enable(uint32_t cntps_ctl_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(cntps_ctl_el1_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntps_ctl_el1, 0x4) }
		inline uint32_t disable(uint32_t cntps_ctl_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntps_ctl_el1_val, 0x4) }
	}

	namespace imask
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntps_ctl_el1, 1) }
		inline uint32_t is_enabled(uint32_t cntps_ctl_el1_val) noexcept { IS_BIT_ENABLED_FUNC(cntps_ctl_el1_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntps_ctl_el1, 1) }
		inline uint32_t is_disabled(uint32_t cntps_ctl_el1_val) noexcept { IS_BIT_DISABLED_FUNC(cntps_ctl_el1_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntps_ctl_el1, 0x2) }
		inline uint32_t enable(uint32_t cntps_ctl_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(cntps_ctl_el1_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntps_ctl_el1, 0x2) }
		inline uint32_t disable(uint32_t cntps_ctl_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntps_ctl_el1_val, 0x2) }
	}

	namespace enable
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntps_ctl_el1, 0) }
		inline uint32_t is_enabled(uint32_t cntps_ctl_el1_val) noexcept { IS_BIT_ENABLED_FUNC(cntps_ctl_el1_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntps_ctl_el1, 0) }
		inline uint32_t is_disabled(uint32_t cntps_ctl_el1_val) noexcept { IS_BIT_DISABLED_FUNC(cntps_ctl_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntps_ctl_el1, 0x1) }
		inline uint32_t enable(uint32_t cntps_ctl_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(cntps_ctl_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntps_ctl_el1, 0x1) }
		inline uint32_t disable(uint32_t cntps_ctl_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntps_ctl_el1_val, 0x1) }
	}
}

// CNTPS_CVAL_EL1 (Counter-timer Physical Secure Timer CompareValue register)
// Holds the compare value for the secure physical timer, usually accessible at EL3 but configurably accessible at EL1 in Secure state.
namespace cntps_cval_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(cntps_cval_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntps_cval_el1, val) }

	namespace comparevalue
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntps_cval_el1, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t cntps_cval_el1_val) noexcept { GET_BITFIELD_FUNC(cntps_cval_el1_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntps_cval_el1, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t cntps_cval_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntps_cval_el1, value, 0xffffffffffffffff, 0) }
	}
}

// CNTPS_TVAL_EL1 (Counter-timer Physical Secure Timer TimerValue register)
// Holds the timer value for the secure physical timer, usually accessible at EL3 but configurably accessible at EL1 in Secure state.
namespace cntps_tval_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntps_tval_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntps_tval_el1, val) }

	namespace timervalue
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntps_tval_el1, 0xffffffff, 0) }
		inline uint32_t get(uint32_t cntps_tval_el1_val) noexcept { GET_BITFIELD_FUNC(cntps_tval_el1_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntps_tval_el1, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t cntps_tval_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntps_tval_el1, value, 0xffffffff, 0) }
	}
}

// CNTV_CTL_EL0 (Counter-timer Virtual Timer Control register)
// Control register for the virtual timer.
namespace cntv_ctl_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntv_ctl_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntv_ctl_el0, val) }

	namespace istatus
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntv_ctl_el0, 2) }
		inline uint32_t is_enabled(uint32_t cntv_ctl_el0_val) noexcept { IS_BIT_ENABLED_FUNC(cntv_ctl_el0_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntv_ctl_el0, 2) }
		inline uint32_t is_disabled(uint32_t cntv_ctl_el0_val) noexcept { IS_BIT_DISABLED_FUNC(cntv_ctl_el0_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntv_ctl_el0, 0x4) }
		inline uint32_t enable(uint32_t cntv_ctl_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(cntv_ctl_el0_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntv_ctl_el0, 0x4) }
		inline uint32_t disable(uint32_t cntv_ctl_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntv_ctl_el0_val, 0x4) }
	}

	namespace imask
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntv_ctl_el0, 1) }
		inline uint32_t is_enabled(uint32_t cntv_ctl_el0_val) noexcept { IS_BIT_ENABLED_FUNC(cntv_ctl_el0_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntv_ctl_el0, 1) }
		inline uint32_t is_disabled(uint32_t cntv_ctl_el0_val) noexcept { IS_BIT_DISABLED_FUNC(cntv_ctl_el0_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntv_ctl_el0, 0x2) }
		inline uint32_t enable(uint32_t cntv_ctl_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(cntv_ctl_el0_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntv_ctl_el0, 0x2) }
		inline uint32_t disable(uint32_t cntv_ctl_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntv_ctl_el0_val, 0x2) }
	}

	namespace enable
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntv_ctl_el0, 0) }
		inline uint32_t is_enabled(uint32_t cntv_ctl_el0_val) noexcept { IS_BIT_ENABLED_FUNC(cntv_ctl_el0_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntv_ctl_el0, 0) }
		inline uint32_t is_disabled(uint32_t cntv_ctl_el0_val) noexcept { IS_BIT_DISABLED_FUNC(cntv_ctl_el0_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntv_ctl_el0, 0x1) }
		inline uint32_t enable(uint32_t cntv_ctl_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(cntv_ctl_el0_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntv_ctl_el0, 0x1) }
		inline uint32_t disable(uint32_t cntv_ctl_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntv_ctl_el0_val, 0x1) }
	}
}

// CNTV_CVAL_EL0 (Counter-timer Virtual Timer CompareValue register)
// Holds the compare value for the virtual timer.
namespace cntv_cval_el0
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(cntv_cval_el0) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntv_cval_el0, val) }

	namespace comparevalue
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntv_cval_el0, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t cntv_cval_el0_val) noexcept { GET_BITFIELD_FUNC(cntv_cval_el0_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntv_cval_el0, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t cntv_cval_el0, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntv_cval_el0, value, 0xffffffffffffffff, 0) }
	}
}

// CNTV_TVAL_EL0 (Counter-timer Virtual Timer TimerValue register)
// Holds the timer value for the EL1 virtual timer.
namespace cntv_tval_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntv_tval_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntv_tval_el0, val) }

	namespace timervalue
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntv_tval_el0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t cntv_tval_el0_val) noexcept { GET_BITFIELD_FUNC(cntv_tval_el0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntv_tval_el0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t cntv_tval_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntv_tval_el0, value, 0xffffffff, 0) }
	}
}

// CNTVCT_EL0 (Counter-timer Virtual Count register)
// Holds the 64-bit virtual count value. The virtual count value is equal to the physical count value visible in CNTPCT_EL0 minus the virtual offset visible in CNTVOFF_EL2.
namespace cntvct_el0
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(cntvct_el0) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntvct_el0, val) }

	namespace virtual_count_value
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntvct_el0, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t cntvct_el0_val) noexcept { GET_BITFIELD_FUNC(cntvct_el0_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntvct_el0, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t cntvct_el0, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntvct_el0, value, 0xffffffffffffffff, 0) }
	}
}

// CNTVOFF_EL2 (Counter-timer Virtual Offset register)
// Holds the 64-bit virtual offset. This is the offset between the physical count value visible in CNTPCT_EL0 and the virtual count value visible in CNTVCT_EL0.
namespace cntvoff_el2
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(cntvoff_el2) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntvoff_el2, val) }

	namespace virtual_offset
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntvoff_el2, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t cntvoff_el2_val) noexcept { GET_BITFIELD_FUNC(cntvoff_el2_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntvoff_el2, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t cntvoff_el2, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntvoff_el2, value, 0xffffffffffffffff, 0) }
	}
}

// CONTEXTIDR_EL1 (Context ID Register (EL1))
// See the ARMv8 architecture reference manual for a description of this register
namespace contextidr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(contextidr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(contextidr_el1, val) }

	namespace procid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(contextidr_el1, 0xffffffff, 0) }
		inline uint32_t get(uint32_t contextidr_el1_val) noexcept { GET_BITFIELD_FUNC(contextidr_el1_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(contextidr_el1, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t contextidr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(contextidr_el1, value, 0xffffffff, 0) }
	}
}

// CONTEXTIDR_EL2 (Context ID Register (EL2))
// See the ARMv8 architecture reference manual for a description of this register
namespace contextidr_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(contextidr_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(contextidr_el2, val) }

	namespace procid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(contextidr_el2, 0xffffffff, 0) }
		inline uint32_t get(uint32_t contextidr_el2_val) noexcept { GET_BITFIELD_FUNC(contextidr_el2_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(contextidr_el2, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t contextidr_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(contextidr_el2, value, 0xffffffff, 0) }
	}
}

// CPACR_EL1 (Architectural Feature Access Control Register)
// Controls access to trace, SVE, Advanced SIMD and floating-point functionality.
namespace cpacr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cpacr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cpacr_el1, val) }
}

// CPTR_EL2 (Architectural Feature Trap Register (EL2))
// See the ARMv8 architecture reference manual for a description of this register
namespace cptr_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cptr_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cptr_el2, val) }

	// Fieldset valid when: HCR_EL2.E2H == 0
	namespace fieldset_1
	{	}

	// Fieldset valid when: HCR_EL2.E2H == 1
	namespace fieldset_2
	{	}
}

// CPTR_EL3 (Architectural Feature Trap Register (EL3))
// Controls trapping to EL3 of access to CPACR_EL1, CPTR_EL2, trace functionality and registers associated with SVE, Advanced SIMD and floating-point execution. Also controls EL3 access to trace functionality and registers associated with SVE, Advanced SIMD and floating-point execution.
namespace cptr_el3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cptr_el3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cptr_el3, val) }
}

// CSSELR_EL1 (Cache Size Selection Register)
// Selects the current Cache Size ID Register, CCSIDR_EL1, by specifying the required cache level and the cache type (either instruction or data cache).
namespace csselr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(csselr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(csselr_el1, val) }

	namespace level
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(csselr_el1, 0xe, 1) }
		inline uint32_t get(uint32_t csselr_el1_val) noexcept { GET_BITFIELD_FUNC(csselr_el1_val, 0xe, 1) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(csselr_el1, value, 0xe, 1) }
		inline uint32_t set(uint32_t csselr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(csselr_el1, value, 0xe, 1) }
	}

	namespace ind
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(csselr_el1, 0) }
		inline uint32_t is_enabled(uint32_t csselr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(csselr_el1_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(csselr_el1, 0) }
		inline uint32_t is_disabled(uint32_t csselr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(csselr_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(csselr_el1, 0x1) }
		inline uint32_t enable(uint32_t csselr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(csselr_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(csselr_el1, 0x1) }
		inline uint32_t disable(uint32_t csselr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(csselr_el1_val, 0x1) }
	}
}

// CTR_EL0 (Cache Type Register)
// Provides information about the architecture of the caches.
namespace ctr_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctr_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctr_el0, val) }

	namespace cwg
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctr_el0, 0xf000000, 24) }
		inline uint32_t get(uint32_t ctr_el0_val) noexcept { GET_BITFIELD_FUNC(ctr_el0_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctr_el0, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t ctr_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctr_el0, value, 0xf000000, 24) }
	}

	namespace erg
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctr_el0, 0xf00000, 20) }
		inline uint32_t get(uint32_t ctr_el0_val) noexcept { GET_BITFIELD_FUNC(ctr_el0_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctr_el0, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t ctr_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctr_el0, value, 0xf00000, 20) }
	}

	namespace dminline
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctr_el0, 0xf0000, 16) }
		inline uint32_t get(uint32_t ctr_el0_val) noexcept { GET_BITFIELD_FUNC(ctr_el0_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctr_el0, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t ctr_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctr_el0, value, 0xf0000, 16) }
	}

	namespace l1ip
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctr_el0, 0xc000, 14) }
		inline uint32_t get(uint32_t ctr_el0_val) noexcept { GET_BITFIELD_FUNC(ctr_el0_val, 0xc000, 14) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctr_el0, value, 0xc000, 14) }
		inline uint32_t set(uint32_t ctr_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctr_el0, value, 0xc000, 14) }
	}

	namespace iminline
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctr_el0, 0xf, 0) }
		inline uint32_t get(uint32_t ctr_el0_val) noexcept { GET_BITFIELD_FUNC(ctr_el0_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctr_el0, value, 0xf, 0) }
		inline uint32_t set(uint32_t ctr_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctr_el0, value, 0xf, 0) }
	}
}

// CurrentEL (Current Exception Level)
// Holds the current Exception level.
namespace currentel
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(currentel) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(currentel, val) }

	namespace el
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(currentel, 0xc, 2) }
		inline uint32_t get(uint32_t currentel_val) noexcept { GET_BITFIELD_FUNC(currentel_val, 0xc, 2) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(currentel, value, 0xc, 2) }
		inline uint32_t set(uint32_t currentel, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(currentel, value, 0xc, 2) }
	}
}

// DACR32_EL2 (Domain Access Control Register)
// Allows access to the AArch32 DACR register from AArch64 state only. Its value has no effect on execution in AArch64 state.
namespace dacr32_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dacr32_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dacr32_el2, val) }

	namespace d_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dacr32_el2, 0xffffffff, 0) }
		inline uint32_t get(uint32_t dacr32_el2_val) noexcept { GET_BITFIELD_FUNC(dacr32_el2_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dacr32_el2, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t dacr32_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dacr32_el2, value, 0xffffffff, 0) }
	}
}

// DAIF (Interrupt Mask Bits)
// Allows access to the interrupt mask bits.
namespace daif
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(daif) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(daif, val) }

	namespace d
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(daif, 9) }
		inline uint32_t is_enabled(uint32_t daif_val) noexcept { IS_BIT_ENABLED_FUNC(daif_val, 9) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(daif, 9) }
		inline uint32_t is_disabled(uint32_t daif_val) noexcept { IS_BIT_DISABLED_FUNC(daif_val, 9) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(daif, 0x200) }
		inline uint32_t enable(uint32_t daif_val) noexcept { SET_BITS_BY_MASK_FUNC(daif_val, 0x200) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(daif, 0x200) }
		inline uint32_t disable(uint32_t daif_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(daif_val, 0x200) }
	}

	namespace a
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(daif, 8) }
		inline uint32_t is_enabled(uint32_t daif_val) noexcept { IS_BIT_ENABLED_FUNC(daif_val, 8) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(daif, 8) }
		inline uint32_t is_disabled(uint32_t daif_val) noexcept { IS_BIT_DISABLED_FUNC(daif_val, 8) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(daif, 0x100) }
		inline uint32_t enable(uint32_t daif_val) noexcept { SET_BITS_BY_MASK_FUNC(daif_val, 0x100) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(daif, 0x100) }
		inline uint32_t disable(uint32_t daif_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(daif_val, 0x100) }
	}

	namespace i
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(daif, 7) }
		inline uint32_t is_enabled(uint32_t daif_val) noexcept { IS_BIT_ENABLED_FUNC(daif_val, 7) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(daif, 7) }
		inline uint32_t is_disabled(uint32_t daif_val) noexcept { IS_BIT_DISABLED_FUNC(daif_val, 7) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(daif, 0x80) }
		inline uint32_t enable(uint32_t daif_val) noexcept { SET_BITS_BY_MASK_FUNC(daif_val, 0x80) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(daif, 0x80) }
		inline uint32_t disable(uint32_t daif_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(daif_val, 0x80) }
	}

	namespace f
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(daif, 6) }
		inline uint32_t is_enabled(uint32_t daif_val) noexcept { IS_BIT_ENABLED_FUNC(daif_val, 6) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(daif, 6) }
		inline uint32_t is_disabled(uint32_t daif_val) noexcept { IS_BIT_DISABLED_FUNC(daif_val, 6) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(daif, 0x40) }
		inline uint32_t enable(uint32_t daif_val) noexcept { SET_BITS_BY_MASK_FUNC(daif_val, 0x40) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(daif, 0x40) }
		inline uint32_t disable(uint32_t daif_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(daif_val, 0x40) }
	}
}

// DBGAUTHSTATUS_EL1 (Debug Authentication Status register)
// Provides information about the state of the IMPLEMENTATION DEFINED authentication interface for debug.
namespace dbgauthstatus_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgauthstatus_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgauthstatus_el1, val) }

	namespace snid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgauthstatus_el1, 0xc0, 6) }
		inline uint32_t get(uint32_t dbgauthstatus_el1_val) noexcept { GET_BITFIELD_FUNC(dbgauthstatus_el1_val, 0xc0, 6) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgauthstatus_el1, value, 0xc0, 6) }
		inline uint32_t set(uint32_t dbgauthstatus_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgauthstatus_el1, value, 0xc0, 6) }
	}

	namespace sid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgauthstatus_el1, 0x30, 4) }
		inline uint32_t get(uint32_t dbgauthstatus_el1_val) noexcept { GET_BITFIELD_FUNC(dbgauthstatus_el1_val, 0x30, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgauthstatus_el1, value, 0x30, 4) }
		inline uint32_t set(uint32_t dbgauthstatus_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgauthstatus_el1, value, 0x30, 4) }
	}

	namespace nsnid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgauthstatus_el1, 0xc, 2) }
		inline uint32_t get(uint32_t dbgauthstatus_el1_val) noexcept { GET_BITFIELD_FUNC(dbgauthstatus_el1_val, 0xc, 2) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgauthstatus_el1, value, 0xc, 2) }
		inline uint32_t set(uint32_t dbgauthstatus_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgauthstatus_el1, value, 0xc, 2) }
	}

	namespace nsid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgauthstatus_el1, 0x3, 0) }
		inline uint32_t get(uint32_t dbgauthstatus_el1_val) noexcept { GET_BITFIELD_FUNC(dbgauthstatus_el1_val, 0x3, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgauthstatus_el1, value, 0x3, 0) }
		inline uint32_t set(uint32_t dbgauthstatus_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgauthstatus_el1, value, 0x3, 0) }
	}
}

// DBGBCR<n>_EL1 (Debug Breakpoint Control Registers)
// Holds control information for a breakpoint. Forms breakpoint n together with value register DBGBVR<n>_EL1.
namespace dbgbcr<n>_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgbcr<n>_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgbcr<n>_el1, val) }

	namespace bt
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbcr<n>_el1, 0xf00000, 20) }
		inline uint32_t get(uint32_t dbgbcr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgbcr<n>_el1_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbcr<n>_el1, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t dbgbcr<n>_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbcr<n>_el1, value, 0xf00000, 20) }
	}

	namespace lbn
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbcr<n>_el1, 0xf0000, 16) }
		inline uint32_t get(uint32_t dbgbcr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgbcr<n>_el1_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbcr<n>_el1, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t dbgbcr<n>_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbcr<n>_el1, value, 0xf0000, 16) }
	}

	namespace ssc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbcr<n>_el1, 0xc000, 14) }
		inline uint32_t get(uint32_t dbgbcr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgbcr<n>_el1_val, 0xc000, 14) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbcr<n>_el1, value, 0xc000, 14) }
		inline uint32_t set(uint32_t dbgbcr<n>_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbcr<n>_el1, value, 0xc000, 14) }
	}

	namespace hmc
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgbcr<n>_el1, 13) }
		inline uint32_t is_enabled(uint32_t dbgbcr<n>_el1_val) noexcept { IS_BIT_ENABLED_FUNC(dbgbcr<n>_el1_val, 13) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgbcr<n>_el1, 13) }
		inline uint32_t is_disabled(uint32_t dbgbcr<n>_el1_val) noexcept { IS_BIT_DISABLED_FUNC(dbgbcr<n>_el1_val, 13) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgbcr<n>_el1, 0x2000) }
		inline uint32_t enable(uint32_t dbgbcr<n>_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgbcr<n>_el1_val, 0x2000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgbcr<n>_el1, 0x2000) }
		inline uint32_t disable(uint32_t dbgbcr<n>_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgbcr<n>_el1_val, 0x2000) }
	}

	namespace bas
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbcr<n>_el1, 0x1e0, 5) }
		inline uint32_t get(uint32_t dbgbcr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgbcr<n>_el1_val, 0x1e0, 5) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbcr<n>_el1, value, 0x1e0, 5) }
		inline uint32_t set(uint32_t dbgbcr<n>_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbcr<n>_el1, value, 0x1e0, 5) }
	}

	namespace pmc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbcr<n>_el1, 0x6, 1) }
		inline uint32_t get(uint32_t dbgbcr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgbcr<n>_el1_val, 0x6, 1) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbcr<n>_el1, value, 0x6, 1) }
		inline uint32_t set(uint32_t dbgbcr<n>_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbcr<n>_el1, value, 0x6, 1) }
	}

	namespace e
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgbcr<n>_el1, 0) }
		inline uint32_t is_enabled(uint32_t dbgbcr<n>_el1_val) noexcept { IS_BIT_ENABLED_FUNC(dbgbcr<n>_el1_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgbcr<n>_el1, 0) }
		inline uint32_t is_disabled(uint32_t dbgbcr<n>_el1_val) noexcept { IS_BIT_DISABLED_FUNC(dbgbcr<n>_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgbcr<n>_el1, 0x1) }
		inline uint32_t enable(uint32_t dbgbcr<n>_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgbcr<n>_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgbcr<n>_el1, 0x1) }
		inline uint32_t disable(uint32_t dbgbcr<n>_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgbcr<n>_el1_val, 0x1) }
	}
}

// DBGBVR<n>_EL1 (Debug Breakpoint Value Registers)
// Holds a virtual address, or a VMID and/or a context ID, for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR<n>_EL1.
namespace dbgbvr<n>_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(dbgbvr<n>_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgbvr<n>_el1, val) }

	// Fieldset valid when: DBGBCR<n>_EL1.BT==0b000x
	namespace fieldset_1
	{	}

	// Fieldset valid when: DBGBCR<n>_EL1.BT==0b001x
	namespace fieldset_2
	{
		namespace contextid
		{
			inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbvr<n>_el1, 0xffffffff, 0) }
			inline uint64_t get(uint64_t dbgbvr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgbvr<n>_el1_val, 0xffffffff, 0) }
			inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbvr<n>_el1, value, 0xffffffff, 0) }
			inline uint64_t set(uint64_t dbgbvr<n>_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbvr<n>_el1, value, 0xffffffff, 0) }
		}
	}

	// Fieldset valid when: DBGBCR<n>_EL1.BT==0b011x
	namespace fieldset_3
	{
		namespace contextid
		{
			inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbvr<n>_el1, 0xffffffff, 0) }
			inline uint64_t get(uint64_t dbgbvr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgbvr<n>_el1_val, 0xffffffff, 0) }
			inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbvr<n>_el1, value, 0xffffffff, 0) }
			inline uint64_t set(uint64_t dbgbvr<n>_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbvr<n>_el1, value, 0xffffffff, 0) }
		}
	}

	// Fieldset valid when: DBGBCR<n>_EL1.BT==0b100x and EL2 implemented
	namespace fieldset_4
	{	}

	// Fieldset valid when: DBGBCR<n>_EL1.BT==0b101x and EL2 implemented
	namespace fieldset_5
	{	}

	// Fieldset valid when: DBGBCR<n>_EL1.BT==0b110x and EL2 implemented
	namespace fieldset_6
	{
		namespace contextid2
		{
			inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbvr<n>_el1, 0xffffffff00000000, 32) }
			inline uint64_t get(uint64_t dbgbvr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgbvr<n>_el1_val, 0xffffffff00000000, 32) }
			inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbvr<n>_el1, value, 0xffffffff00000000, 32) }
			inline uint64_t set(uint64_t dbgbvr<n>_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbvr<n>_el1, value, 0xffffffff00000000, 32) }
		}
	}

	// Fieldset valid when: DBGBCR<n>_EL1.BT==0b111x and EL2 implemented
	namespace fieldset_7
	{
		namespace contextid2
		{
			inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbvr<n>_el1, 0xffffffff00000000, 32) }
			inline uint64_t get(uint64_t dbgbvr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgbvr<n>_el1_val, 0xffffffff00000000, 32) }
			inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbvr<n>_el1, value, 0xffffffff00000000, 32) }
			inline uint64_t set(uint64_t dbgbvr<n>_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbvr<n>_el1, value, 0xffffffff00000000, 32) }
		}

		namespace contextid
		{
			inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbvr<n>_el1, 0xffffffff, 0) }
			inline uint64_t get(uint64_t dbgbvr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgbvr<n>_el1_val, 0xffffffff, 0) }
			inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbvr<n>_el1, value, 0xffffffff, 0) }
			inline uint64_t set(uint64_t dbgbvr<n>_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbvr<n>_el1, value, 0xffffffff, 0) }
		}
	}
}

// DBGCLAIMCLR_EL1 (Debug Claim Tag Clear register)
// See the ARMv8 architecture reference manual for a description of this register
namespace dbgclaimclr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgclaimclr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgclaimclr_el1, val) }

	namespace claim
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgclaimclr_el1, 0xff, 0) }
		inline uint32_t get(uint32_t dbgclaimclr_el1_val) noexcept { GET_BITFIELD_FUNC(dbgclaimclr_el1_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgclaimclr_el1, value, 0xff, 0) }
		inline uint32_t set(uint32_t dbgclaimclr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgclaimclr_el1, value, 0xff, 0) }
	}
}

// DBGCLAIMSET_EL1 (Debug Claim Tag Set register)
// See the ARMv8 architecture reference manual for a description of this register
namespace dbgclaimset_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgclaimset_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgclaimset_el1, val) }

	namespace claim
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgclaimset_el1, 0xff, 0) }
		inline uint32_t get(uint32_t dbgclaimset_el1_val) noexcept { GET_BITFIELD_FUNC(dbgclaimset_el1_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgclaimset_el1, value, 0xff, 0) }
		inline uint32_t set(uint32_t dbgclaimset_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgclaimset_el1, value, 0xff, 0) }
	}
}

// DBGDTR_EL0 (Debug Data Transfer Register, half-duplex)
// Transfers 64 bits of data between the PE and an external debugger. Can transfer both ways using only a single register.
namespace dbgdtr_el0
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(dbgdtr_el0) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgdtr_el0, val) }

	namespace highword
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdtr_el0, 0xffffffff00000000, 32) }
		inline uint64_t get(uint64_t dbgdtr_el0_val) noexcept { GET_BITFIELD_FUNC(dbgdtr_el0_val, 0xffffffff00000000, 32) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdtr_el0, value, 0xffffffff00000000, 32) }
		inline uint64_t set(uint64_t dbgdtr_el0, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdtr_el0, value, 0xffffffff00000000, 32) }
	}

	namespace lowword
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdtr_el0, 0xffffffff, 0) }
		inline uint64_t get(uint64_t dbgdtr_el0_val) noexcept { GET_BITFIELD_FUNC(dbgdtr_el0_val, 0xffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdtr_el0, value, 0xffffffff, 0) }
		inline uint64_t set(uint64_t dbgdtr_el0, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdtr_el0, value, 0xffffffff, 0) }
	}
}

// DBGDTRRX_EL0 (Debug Data Transfer Register, Receive)
// Transfers data from an external debugger to the PE. For example, it is used by a debugger transferring commands and data to a debug target. It is a component of the Debug Communications Channel.
namespace dbgdtrrx_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgdtrrx_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgdtrrx_el0, val) }

	namespace update_dtrrx
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdtrrx_el0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t dbgdtrrx_el0_val) noexcept { GET_BITFIELD_FUNC(dbgdtrrx_el0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdtrrx_el0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t dbgdtrrx_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdtrrx_el0, value, 0xffffffff, 0) }
	}
}

// DBGDTRTX_EL0 (Debug Data Transfer Register, Transmit)
// Transfers data from the PE to an external debugger. For example, it is used by a debug target to transfer data to the debugger. It is a component of the Debug Communication Channel.
namespace dbgdtrtx_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgdtrtx_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgdtrtx_el0, val) }

	namespace return_dtrtx
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdtrtx_el0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t dbgdtrtx_el0_val) noexcept { GET_BITFIELD_FUNC(dbgdtrtx_el0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdtrtx_el0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t dbgdtrtx_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdtrtx_el0, value, 0xffffffff, 0) }
	}
}

// DBGPRCR_EL1 (Debug Power Control Register)
// Controls behavior of the PE on powerdown request.
namespace dbgprcr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgprcr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgprcr_el1, val) }

	namespace corenpdrq
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgprcr_el1, 0) }
		inline uint32_t is_enabled(uint32_t dbgprcr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(dbgprcr_el1_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgprcr_el1, 0) }
		inline uint32_t is_disabled(uint32_t dbgprcr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(dbgprcr_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgprcr_el1, 0x1) }
		inline uint32_t enable(uint32_t dbgprcr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgprcr_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgprcr_el1, 0x1) }
		inline uint32_t disable(uint32_t dbgprcr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgprcr_el1_val, 0x1) }
	}
}

// DBGVCR32_EL2 (Debug Vector Catch Register)
// Allows access to the AArch32 register DBGVCR from AArch64 state only. Its value has no effect on execution in AArch64 state.
namespace dbgvcr32_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgvcr32_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgvcr32_el2, val) }

	// Fieldset valid when: EL3 implemented and using AArch64
	namespace fieldset_1
	{
		namespace nsf
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr32_el2, 31) }
			inline uint32_t is_enabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr32_el2_val, 31) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr32_el2, 31) }
			inline uint32_t is_disabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr32_el2_val, 31) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x80000000) }
			inline uint32_t enable(uint32_t dbgvcr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x80000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x80000000) }
			inline uint32_t disable(uint32_t dbgvcr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x80000000) }
		}

		namespace nsi
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr32_el2, 30) }
			inline uint32_t is_enabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr32_el2_val, 30) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr32_el2, 30) }
			inline uint32_t is_disabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr32_el2_val, 30) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x40000000) }
			inline uint32_t enable(uint32_t dbgvcr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x40000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x40000000) }
			inline uint32_t disable(uint32_t dbgvcr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x40000000) }
		}

		namespace nsd
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr32_el2, 28) }
			inline uint32_t is_enabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr32_el2_val, 28) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr32_el2, 28) }
			inline uint32_t is_disabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr32_el2_val, 28) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x10000000) }
			inline uint32_t enable(uint32_t dbgvcr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x10000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x10000000) }
			inline uint32_t disable(uint32_t dbgvcr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x10000000) }
		}

		namespace nsp
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr32_el2, 27) }
			inline uint32_t is_enabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr32_el2_val, 27) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr32_el2, 27) }
			inline uint32_t is_disabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr32_el2_val, 27) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x8000000) }
			inline uint32_t enable(uint32_t dbgvcr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x8000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x8000000) }
			inline uint32_t disable(uint32_t dbgvcr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x8000000) }
		}

		namespace nss
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr32_el2, 26) }
			inline uint32_t is_enabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr32_el2_val, 26) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr32_el2, 26) }
			inline uint32_t is_disabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr32_el2_val, 26) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x4000000) }
			inline uint32_t enable(uint32_t dbgvcr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x4000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x4000000) }
			inline uint32_t disable(uint32_t dbgvcr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x4000000) }
		}

		namespace nsu
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr32_el2, 25) }
			inline uint32_t is_enabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr32_el2_val, 25) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr32_el2, 25) }
			inline uint32_t is_disabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr32_el2_val, 25) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x2000000) }
			inline uint32_t enable(uint32_t dbgvcr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x2000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x2000000) }
			inline uint32_t disable(uint32_t dbgvcr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x2000000) }
		}

		namespace sf
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr32_el2, 7) }
			inline uint32_t is_enabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr32_el2_val, 7) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr32_el2, 7) }
			inline uint32_t is_disabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr32_el2_val, 7) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x80) }
			inline uint32_t enable(uint32_t dbgvcr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x80) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x80) }
			inline uint32_t disable(uint32_t dbgvcr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x80) }
		}

		namespace si
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr32_el2, 6) }
			inline uint32_t is_enabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr32_el2_val, 6) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr32_el2, 6) }
			inline uint32_t is_disabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr32_el2_val, 6) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x40) }
			inline uint32_t enable(uint32_t dbgvcr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x40) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x40) }
			inline uint32_t disable(uint32_t dbgvcr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x40) }
		}

		namespace sd
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr32_el2, 4) }
			inline uint32_t is_enabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr32_el2_val, 4) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr32_el2, 4) }
			inline uint32_t is_disabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr32_el2_val, 4) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x10) }
			inline uint32_t enable(uint32_t dbgvcr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x10) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x10) }
			inline uint32_t disable(uint32_t dbgvcr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x10) }
		}

		namespace sp
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr32_el2, 3) }
			inline uint32_t is_enabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr32_el2_val, 3) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr32_el2, 3) }
			inline uint32_t is_disabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr32_el2_val, 3) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x8) }
			inline uint32_t enable(uint32_t dbgvcr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x8) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x8) }
			inline uint32_t disable(uint32_t dbgvcr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x8) }
		}

		namespace ss
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr32_el2, 2) }
			inline uint32_t is_enabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr32_el2_val, 2) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr32_el2, 2) }
			inline uint32_t is_disabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr32_el2_val, 2) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x4) }
			inline uint32_t enable(uint32_t dbgvcr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x4) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x4) }
			inline uint32_t disable(uint32_t dbgvcr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x4) }
		}

		namespace su
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr32_el2, 1) }
			inline uint32_t is_enabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr32_el2_val, 1) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr32_el2, 1) }
			inline uint32_t is_disabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr32_el2_val, 1) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x2) }
			inline uint32_t enable(uint32_t dbgvcr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x2) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x2) }
			inline uint32_t disable(uint32_t dbgvcr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x2) }
		}
	}

	// Fieldset valid when: EL3 not implemented
	namespace fieldset_2
	{
		namespace f
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr32_el2, 7) }
			inline uint32_t is_enabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr32_el2_val, 7) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr32_el2, 7) }
			inline uint32_t is_disabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr32_el2_val, 7) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x80) }
			inline uint32_t enable(uint32_t dbgvcr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x80) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x80) }
			inline uint32_t disable(uint32_t dbgvcr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x80) }
		}

		namespace i
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr32_el2, 6) }
			inline uint32_t is_enabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr32_el2_val, 6) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr32_el2, 6) }
			inline uint32_t is_disabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr32_el2_val, 6) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x40) }
			inline uint32_t enable(uint32_t dbgvcr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x40) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x40) }
			inline uint32_t disable(uint32_t dbgvcr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x40) }
		}

		namespace d
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr32_el2, 4) }
			inline uint32_t is_enabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr32_el2_val, 4) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr32_el2, 4) }
			inline uint32_t is_disabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr32_el2_val, 4) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x10) }
			inline uint32_t enable(uint32_t dbgvcr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x10) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x10) }
			inline uint32_t disable(uint32_t dbgvcr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x10) }
		}

		namespace p
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr32_el2, 3) }
			inline uint32_t is_enabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr32_el2_val, 3) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr32_el2, 3) }
			inline uint32_t is_disabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr32_el2_val, 3) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x8) }
			inline uint32_t enable(uint32_t dbgvcr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x8) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x8) }
			inline uint32_t disable(uint32_t dbgvcr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x8) }
		}

		namespace s
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr32_el2, 2) }
			inline uint32_t is_enabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr32_el2_val, 2) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr32_el2, 2) }
			inline uint32_t is_disabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr32_el2_val, 2) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x4) }
			inline uint32_t enable(uint32_t dbgvcr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x4) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x4) }
			inline uint32_t disable(uint32_t dbgvcr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x4) }
		}

		namespace u
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgvcr32_el2, 1) }
			inline uint32_t is_enabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(dbgvcr32_el2_val, 1) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgvcr32_el2, 1) }
			inline uint32_t is_disabled(uint32_t dbgvcr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(dbgvcr32_el2_val, 1) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x2) }
			inline uint32_t enable(uint32_t dbgvcr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x2) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgvcr32_el2, 0x2) }
			inline uint32_t disable(uint32_t dbgvcr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgvcr32_el2_val, 0x2) }
		}
	}
}

// DBGWCR<n>_EL1 (Debug Watchpoint Control Registers)
// Holds control information for a watchpoint. Forms watchpoint n together with value register DBGWVR<n>_EL1.
namespace dbgwcr<n>_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgwcr<n>_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgwcr<n>_el1, val) }

	namespace mask
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgwcr<n>_el1, 0x1f000000, 24) }
		inline uint32_t get(uint32_t dbgwcr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgwcr<n>_el1_val, 0x1f000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgwcr<n>_el1, value, 0x1f000000, 24) }
		inline uint32_t set(uint32_t dbgwcr<n>_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgwcr<n>_el1, value, 0x1f000000, 24) }
	}

	namespace wt
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgwcr<n>_el1, 20) }
		inline uint32_t is_enabled(uint32_t dbgwcr<n>_el1_val) noexcept { IS_BIT_ENABLED_FUNC(dbgwcr<n>_el1_val, 20) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgwcr<n>_el1, 20) }
		inline uint32_t is_disabled(uint32_t dbgwcr<n>_el1_val) noexcept { IS_BIT_DISABLED_FUNC(dbgwcr<n>_el1_val, 20) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgwcr<n>_el1, 0x100000) }
		inline uint32_t enable(uint32_t dbgwcr<n>_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgwcr<n>_el1_val, 0x100000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgwcr<n>_el1, 0x100000) }
		inline uint32_t disable(uint32_t dbgwcr<n>_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgwcr<n>_el1_val, 0x100000) }
	}

	namespace lbn
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgwcr<n>_el1, 0xf0000, 16) }
		inline uint32_t get(uint32_t dbgwcr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgwcr<n>_el1_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgwcr<n>_el1, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t dbgwcr<n>_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgwcr<n>_el1, value, 0xf0000, 16) }
	}

	namespace ssc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgwcr<n>_el1, 0xc000, 14) }
		inline uint32_t get(uint32_t dbgwcr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgwcr<n>_el1_val, 0xc000, 14) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgwcr<n>_el1, value, 0xc000, 14) }
		inline uint32_t set(uint32_t dbgwcr<n>_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgwcr<n>_el1, value, 0xc000, 14) }
	}

	namespace hmc
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgwcr<n>_el1, 13) }
		inline uint32_t is_enabled(uint32_t dbgwcr<n>_el1_val) noexcept { IS_BIT_ENABLED_FUNC(dbgwcr<n>_el1_val, 13) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgwcr<n>_el1, 13) }
		inline uint32_t is_disabled(uint32_t dbgwcr<n>_el1_val) noexcept { IS_BIT_DISABLED_FUNC(dbgwcr<n>_el1_val, 13) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgwcr<n>_el1, 0x2000) }
		inline uint32_t enable(uint32_t dbgwcr<n>_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgwcr<n>_el1_val, 0x2000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgwcr<n>_el1, 0x2000) }
		inline uint32_t disable(uint32_t dbgwcr<n>_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgwcr<n>_el1_val, 0x2000) }
	}

	namespace bas
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgwcr<n>_el1, 0x1fe0, 5) }
		inline uint32_t get(uint32_t dbgwcr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgwcr<n>_el1_val, 0x1fe0, 5) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgwcr<n>_el1, value, 0x1fe0, 5) }
		inline uint32_t set(uint32_t dbgwcr<n>_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgwcr<n>_el1, value, 0x1fe0, 5) }
	}

	namespace lsc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgwcr<n>_el1, 0x18, 3) }
		inline uint32_t get(uint32_t dbgwcr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgwcr<n>_el1_val, 0x18, 3) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgwcr<n>_el1, value, 0x18, 3) }
		inline uint32_t set(uint32_t dbgwcr<n>_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgwcr<n>_el1, value, 0x18, 3) }
	}

	namespace pac
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgwcr<n>_el1, 0x6, 1) }
		inline uint32_t get(uint32_t dbgwcr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgwcr<n>_el1_val, 0x6, 1) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgwcr<n>_el1, value, 0x6, 1) }
		inline uint32_t set(uint32_t dbgwcr<n>_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgwcr<n>_el1, value, 0x6, 1) }
	}

	namespace e
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgwcr<n>_el1, 0) }
		inline uint32_t is_enabled(uint32_t dbgwcr<n>_el1_val) noexcept { IS_BIT_ENABLED_FUNC(dbgwcr<n>_el1_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgwcr<n>_el1, 0) }
		inline uint32_t is_disabled(uint32_t dbgwcr<n>_el1_val) noexcept { IS_BIT_DISABLED_FUNC(dbgwcr<n>_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgwcr<n>_el1, 0x1) }
		inline uint32_t enable(uint32_t dbgwcr<n>_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgwcr<n>_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgwcr<n>_el1, 0x1) }
		inline uint32_t disable(uint32_t dbgwcr<n>_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgwcr<n>_el1_val, 0x1) }
	}
}

// DBGWVR<n>_EL1 (Debug Watchpoint Value Registers)
// Holds a data address value for use in watchpoint matching. Forms watchpoint n together with control register DBGWCR<n>_EL1.
namespace dbgwvr<n>_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(dbgwvr<n>_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgwvr<n>_el1, val) }
}

// DC CISW (Data or unified Cache line Clean and Invalidate by Set/Way)
// Clean and Invalidate data cache by set/way.
namespace dc cisw
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(dc cisw) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dc cisw, val) }

	namespace setway
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dc cisw, 0xfffffff0, 4) }
		inline uint64_t get(uint64_t dc cisw_val) noexcept { GET_BITFIELD_FUNC(dc cisw_val, 0xfffffff0, 4) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dc cisw, value, 0xfffffff0, 4) }
		inline uint64_t set(uint64_t dc cisw, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dc cisw, value, 0xfffffff0, 4) }
	}

	namespace level
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dc cisw, 0xe, 1) }
		inline uint64_t get(uint64_t dc cisw_val) noexcept { GET_BITFIELD_FUNC(dc cisw_val, 0xe, 1) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dc cisw, value, 0xe, 1) }
		inline uint64_t set(uint64_t dc cisw, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dc cisw, value, 0xe, 1) }
	}
}

// DC CIVAC (Data or unified Cache line Clean and Invalidate by VA to PoC)
// Clean and Invalidate data cache by address to Point of Coherency.
namespace dc civac
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(dc civac) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dc civac, val) }

	namespace virtual_address_to_use
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dc civac, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t dc civac_val) noexcept { GET_BITFIELD_FUNC(dc civac_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dc civac, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t dc civac, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dc civac, value, 0xffffffffffffffff, 0) }
	}
}

// DC CSW (Data or unified Cache line Clean by Set/Way)
// Clean data cache by set/way.
namespace dc csw
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(dc csw) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dc csw, val) }

	namespace setway
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dc csw, 0xfffffff0, 4) }
		inline uint64_t get(uint64_t dc csw_val) noexcept { GET_BITFIELD_FUNC(dc csw_val, 0xfffffff0, 4) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dc csw, value, 0xfffffff0, 4) }
		inline uint64_t set(uint64_t dc csw, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dc csw, value, 0xfffffff0, 4) }
	}

	namespace level
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dc csw, 0xe, 1) }
		inline uint64_t get(uint64_t dc csw_val) noexcept { GET_BITFIELD_FUNC(dc csw_val, 0xe, 1) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dc csw, value, 0xe, 1) }
		inline uint64_t set(uint64_t dc csw, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dc csw, value, 0xe, 1) }
	}
}

// DC CVAC (Data or unified Cache line Clean by VA to PoC)
// Clean data cache by address to Point of Coherency.
namespace dc cvac
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(dc cvac) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dc cvac, val) }

	namespace virtual_address_to_use
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dc cvac, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t dc cvac_val) noexcept { GET_BITFIELD_FUNC(dc cvac_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dc cvac, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t dc cvac, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dc cvac, value, 0xffffffffffffffff, 0) }
	}
}

// DC CVAP (Data or unified Cache line Clean by VA to PoP)
// See the ARMv8 architecture reference manual for a description of this register
namespace dc cvap
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(dc cvap) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dc cvap, val) }

	namespace virtual_address_to_use
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dc cvap, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t dc cvap_val) noexcept { GET_BITFIELD_FUNC(dc cvap_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dc cvap, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t dc cvap, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dc cvap, value, 0xffffffffffffffff, 0) }
	}
}

// DC CVAU (Data or unified Cache line Clean by VA to PoU)
// Clean data cache by address to Point of Unification.
namespace dc cvau
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(dc cvau) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dc cvau, val) }

	namespace virtual_address_to_use
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dc cvau, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t dc cvau_val) noexcept { GET_BITFIELD_FUNC(dc cvau_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dc cvau, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t dc cvau, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dc cvau, value, 0xffffffffffffffff, 0) }
	}
}

// DC ISW (Data or unified Cache line Invalidate by Set/Way)
// Invalidate data cache by set/way.
namespace dc isw
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(dc isw) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dc isw, val) }

	namespace setway
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dc isw, 0xfffffff0, 4) }
		inline uint64_t get(uint64_t dc isw_val) noexcept { GET_BITFIELD_FUNC(dc isw_val, 0xfffffff0, 4) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dc isw, value, 0xfffffff0, 4) }
		inline uint64_t set(uint64_t dc isw, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dc isw, value, 0xfffffff0, 4) }
	}

	namespace level
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dc isw, 0xe, 1) }
		inline uint64_t get(uint64_t dc isw_val) noexcept { GET_BITFIELD_FUNC(dc isw_val, 0xe, 1) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dc isw, value, 0xe, 1) }
		inline uint64_t set(uint64_t dc isw, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dc isw, value, 0xe, 1) }
	}
}

// DC IVAC (Data or unified Cache line Invalidate by VA to PoC)
// Invalidate data cache by address to Point of Coherency.
namespace dc ivac
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(dc ivac) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dc ivac, val) }

	namespace virtual_address_to_use
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dc ivac, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t dc ivac_val) noexcept { GET_BITFIELD_FUNC(dc ivac_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dc ivac, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t dc ivac, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dc ivac, value, 0xffffffffffffffff, 0) }
	}
}

// DC ZVA (Data Cache Zero by VA)
// Zero data cache by address. Zeroes a naturally aligned block of N bytes, where the size of N is identified in DCZID_EL0.
namespace dc zva
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(dc zva) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dc zva, val) }

	namespace virtual_address_to_use
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dc zva, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t dc zva_val) noexcept { GET_BITFIELD_FUNC(dc zva_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dc zva, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t dc zva, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dc zva, value, 0xffffffffffffffff, 0) }
	}
}

// DCZID_EL0 (Data Cache Zero ID register)
// Indicates the block size that is written with byte values of 0 by the DC ZVA (Data Cache Zero by Address) system instruction.
namespace dczid_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dczid_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dczid_el0, val) }

	namespace dzp
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dczid_el0, 4) }
		inline uint32_t is_enabled(uint32_t dczid_el0_val) noexcept { IS_BIT_ENABLED_FUNC(dczid_el0_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dczid_el0, 4) }
		inline uint32_t is_disabled(uint32_t dczid_el0_val) noexcept { IS_BIT_DISABLED_FUNC(dczid_el0_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dczid_el0, 0x10) }
		inline uint32_t enable(uint32_t dczid_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(dczid_el0_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dczid_el0, 0x10) }
		inline uint32_t disable(uint32_t dczid_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dczid_el0_val, 0x10) }
	}

	namespace bs
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dczid_el0, 0xf, 0) }
		inline uint32_t get(uint32_t dczid_el0_val) noexcept { GET_BITFIELD_FUNC(dczid_el0_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dczid_el0, value, 0xf, 0) }
		inline uint32_t set(uint32_t dczid_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dczid_el0, value, 0xf, 0) }
	}
}

// DLR_EL0 (Debug Link Register)
// In Debug state, holds the address to restart from.
namespace dlr_el0
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(dlr_el0) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dlr_el0, val) }

	namespace restart_address
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dlr_el0, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t dlr_el0_val) noexcept { GET_BITFIELD_FUNC(dlr_el0_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dlr_el0, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t dlr_el0, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dlr_el0, value, 0xffffffffffffffff, 0) }
	}
}

// DSPSR_EL0 (Debug Saved Program Status Register)
// Holds the saved process state on entry to Debug state.
namespace dspsr_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dspsr_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dspsr_el0, val) }

	// Fieldset valid when: exiting Debug state to AArch32
	namespace fieldset_1
	{	}

	// Fieldset valid when: entering Debug state from AArch64 and exiting Debug state to AArch64
	namespace fieldset_2
	{	}
}

// ELR_EL1 (Exception Link Register (EL1))
// When taking an exception to EL1, holds the address to return to.
namespace elr_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(elr_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(elr_el1, val) }

	namespace return_address
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(elr_el1, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t elr_el1_val) noexcept { GET_BITFIELD_FUNC(elr_el1_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(elr_el1, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t elr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(elr_el1, value, 0xffffffffffffffff, 0) }
	}
}

// ELR_EL2 (Exception Link Register (EL2))
// When taking an exception to EL2, holds the address to return to.
namespace elr_el2
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(elr_el2) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(elr_el2, val) }

	namespace return_address
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(elr_el2, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t elr_el2_val) noexcept { GET_BITFIELD_FUNC(elr_el2_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(elr_el2, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t elr_el2, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(elr_el2, value, 0xffffffffffffffff, 0) }
	}
}

// ELR_EL3 (Exception Link Register (EL3))
// When taking an exception to EL3, holds the address to return to.
namespace elr_el3
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(elr_el3) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(elr_el3, val) }

	namespace return_address
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(elr_el3, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t elr_el3_val) noexcept { GET_BITFIELD_FUNC(elr_el3_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(elr_el3, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t elr_el3, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(elr_el3, value, 0xffffffffffffffff, 0) }
	}
}

// ESR_EL1 (Exception Syndrome Register (EL1))
// Holds syndrome information for an exception taken to EL1.
namespace esr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(esr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(esr_el1, val) }

	namespace ec
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(esr_el1, 0xfc000000, 26) }
		inline uint32_t get(uint32_t esr_el1_val) noexcept { GET_BITFIELD_FUNC(esr_el1_val, 0xfc000000, 26) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(esr_el1, value, 0xfc000000, 26) }
		inline uint32_t set(uint32_t esr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(esr_el1, value, 0xfc000000, 26) }
	}

	namespace il
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(esr_el1, 25) }
		inline uint32_t is_enabled(uint32_t esr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(esr_el1_val, 25) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(esr_el1, 25) }
		inline uint32_t is_disabled(uint32_t esr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(esr_el1_val, 25) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(esr_el1, 0x2000000) }
		inline uint32_t enable(uint32_t esr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(esr_el1_val, 0x2000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(esr_el1, 0x2000000) }
		inline uint32_t disable(uint32_t esr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(esr_el1_val, 0x2000000) }
	}

	namespace iss
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(esr_el1, 0x1ffffff, 0) }
		inline uint32_t get(uint32_t esr_el1_val) noexcept { GET_BITFIELD_FUNC(esr_el1_val, 0x1ffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(esr_el1, value, 0x1ffffff, 0) }
		inline uint32_t set(uint32_t esr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(esr_el1, value, 0x1ffffff, 0) }
	}
}

// ESR_EL2 (Exception Syndrome Register (EL2))
// Holds syndrome information for an exception taken to EL2.
namespace esr_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(esr_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(esr_el2, val) }

	namespace ec
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(esr_el2, 0xfc000000, 26) }
		inline uint32_t get(uint32_t esr_el2_val) noexcept { GET_BITFIELD_FUNC(esr_el2_val, 0xfc000000, 26) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(esr_el2, value, 0xfc000000, 26) }
		inline uint32_t set(uint32_t esr_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(esr_el2, value, 0xfc000000, 26) }
	}

	namespace il
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(esr_el2, 25) }
		inline uint32_t is_enabled(uint32_t esr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(esr_el2_val, 25) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(esr_el2, 25) }
		inline uint32_t is_disabled(uint32_t esr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(esr_el2_val, 25) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(esr_el2, 0x2000000) }
		inline uint32_t enable(uint32_t esr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(esr_el2_val, 0x2000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(esr_el2, 0x2000000) }
		inline uint32_t disable(uint32_t esr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(esr_el2_val, 0x2000000) }
	}

	namespace iss
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(esr_el2, 0x1ffffff, 0) }
		inline uint32_t get(uint32_t esr_el2_val) noexcept { GET_BITFIELD_FUNC(esr_el2_val, 0x1ffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(esr_el2, value, 0x1ffffff, 0) }
		inline uint32_t set(uint32_t esr_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(esr_el2, value, 0x1ffffff, 0) }
	}
}

// ESR_EL3 (Exception Syndrome Register (EL3))
// Holds syndrome information for an exception taken to EL3.
namespace esr_el3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(esr_el3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(esr_el3, val) }

	namespace ec
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(esr_el3, 0xfc000000, 26) }
		inline uint32_t get(uint32_t esr_el3_val) noexcept { GET_BITFIELD_FUNC(esr_el3_val, 0xfc000000, 26) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(esr_el3, value, 0xfc000000, 26) }
		inline uint32_t set(uint32_t esr_el3, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(esr_el3, value, 0xfc000000, 26) }
	}

	namespace il
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(esr_el3, 25) }
		inline uint32_t is_enabled(uint32_t esr_el3_val) noexcept { IS_BIT_ENABLED_FUNC(esr_el3_val, 25) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(esr_el3, 25) }
		inline uint32_t is_disabled(uint32_t esr_el3_val) noexcept { IS_BIT_DISABLED_FUNC(esr_el3_val, 25) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(esr_el3, 0x2000000) }
		inline uint32_t enable(uint32_t esr_el3_val) noexcept { SET_BITS_BY_MASK_FUNC(esr_el3_val, 0x2000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(esr_el3, 0x2000000) }
		inline uint32_t disable(uint32_t esr_el3_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(esr_el3_val, 0x2000000) }
	}

	namespace iss
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(esr_el3, 0x1ffffff, 0) }
		inline uint32_t get(uint32_t esr_el3_val) noexcept { GET_BITFIELD_FUNC(esr_el3_val, 0x1ffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(esr_el3, value, 0x1ffffff, 0) }
		inline uint32_t set(uint32_t esr_el3, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(esr_el3, value, 0x1ffffff, 0) }
	}
}

// ESR_ELx (Exception Syndrome Register (ELx))
// Holds syndrome information for an exception taken to ELx.
namespace esr_elx
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(esr_elx) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(esr_elx, val) }

	namespace ec
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(esr_elx, 0xfc000000, 26) }
		inline uint32_t get(uint32_t esr_elx_val) noexcept { GET_BITFIELD_FUNC(esr_elx_val, 0xfc000000, 26) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(esr_elx, value, 0xfc000000, 26) }
		inline uint32_t set(uint32_t esr_elx, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(esr_elx, value, 0xfc000000, 26) }
	}

	namespace il
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(esr_elx, 25) }
		inline uint32_t is_enabled(uint32_t esr_elx_val) noexcept { IS_BIT_ENABLED_FUNC(esr_elx_val, 25) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(esr_elx, 25) }
		inline uint32_t is_disabled(uint32_t esr_elx_val) noexcept { IS_BIT_DISABLED_FUNC(esr_elx_val, 25) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(esr_elx, 0x2000000) }
		inline uint32_t enable(uint32_t esr_elx_val) noexcept { SET_BITS_BY_MASK_FUNC(esr_elx_val, 0x2000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(esr_elx, 0x2000000) }
		inline uint32_t disable(uint32_t esr_elx_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(esr_elx_val, 0x2000000) }
	}

	namespace iss
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(esr_elx, 0x1ffffff, 0) }
		inline uint32_t get(uint32_t esr_elx_val) noexcept { GET_BITFIELD_FUNC(esr_elx_val, 0x1ffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(esr_elx, value, 0x1ffffff, 0) }
		inline uint32_t set(uint32_t esr_elx, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(esr_elx, value, 0x1ffffff, 0) }
	}
}

// FAR_EL1 (Fault Address Register (EL1))
// Holds the faulting Virtual Address for all synchronous Instruction or Data Abort, PC alignment fault and Watchpoint exceptions that are taken to EL1.
namespace far_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(far_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(far_el1, val) }

	namespace faulting_virtual_address_for_synchronous_exceptions_taken_to_el1
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(far_el1, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t far_el1_val) noexcept { GET_BITFIELD_FUNC(far_el1_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(far_el1, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t far_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(far_el1, value, 0xffffffffffffffff, 0) }
	}
}

// FAR_EL2 (Fault Address Register (EL2))
// Holds the faulting Virtual Address for all synchronous Instruction or Data Abort, PC alignment fault and Watchpoint exceptions that are taken to EL2.
namespace far_el2
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(far_el2) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(far_el2, val) }

	namespace faulting_virtual_address_for_synchronous_exceptions_taken_to_el2
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(far_el2, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t far_el2_val) noexcept { GET_BITFIELD_FUNC(far_el2_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(far_el2, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t far_el2, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(far_el2, value, 0xffffffffffffffff, 0) }
	}
}

// FAR_EL3 (Fault Address Register (EL3))
// Holds the faulting Virtual Address for all synchronous Instruction or Data Abort and PC alignment fault exceptions that are taken to EL3.
namespace far_el3
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(far_el3) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(far_el3, val) }

	namespace faulting_virtual_address_for_synchronous_exceptions_taken_to_el3
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(far_el3, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t far_el3_val) noexcept { GET_BITFIELD_FUNC(far_el3_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(far_el3, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t far_el3, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(far_el3, value, 0xffffffffffffffff, 0) }
	}
}

// FPCR (Floating-point Control Register)
// Controls floating-point behavior.
namespace fpcr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(fpcr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(fpcr, val) }
}

// FPEXC32_EL2 (Floating-Point Exception Control register)
// Allows access to the AArch32 register FPEXC from AArch64 state only. Its value has no effect on execution in AArch64 state.
namespace fpexc32_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(fpexc32_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(fpexc32_el2, val) }
}

// FPSR (Floating-point Status Register)
// Provides floating-point system status information.
namespace fpsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(fpsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(fpsr, val) }

	namespace n
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(fpsr, 31) }
		inline uint32_t is_enabled(uint32_t fpsr_val) noexcept { IS_BIT_ENABLED_FUNC(fpsr_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(fpsr, 31) }
		inline uint32_t is_disabled(uint32_t fpsr_val) noexcept { IS_BIT_DISABLED_FUNC(fpsr_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(fpsr, 0x80000000) }
		inline uint32_t enable(uint32_t fpsr_val) noexcept { SET_BITS_BY_MASK_FUNC(fpsr_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(fpsr, 0x80000000) }
		inline uint32_t disable(uint32_t fpsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(fpsr_val, 0x80000000) }
	}

	namespace z
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(fpsr, 30) }
		inline uint32_t is_enabled(uint32_t fpsr_val) noexcept { IS_BIT_ENABLED_FUNC(fpsr_val, 30) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(fpsr, 30) }
		inline uint32_t is_disabled(uint32_t fpsr_val) noexcept { IS_BIT_DISABLED_FUNC(fpsr_val, 30) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(fpsr, 0x40000000) }
		inline uint32_t enable(uint32_t fpsr_val) noexcept { SET_BITS_BY_MASK_FUNC(fpsr_val, 0x40000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(fpsr, 0x40000000) }
		inline uint32_t disable(uint32_t fpsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(fpsr_val, 0x40000000) }
	}

	namespace c
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(fpsr, 29) }
		inline uint32_t is_enabled(uint32_t fpsr_val) noexcept { IS_BIT_ENABLED_FUNC(fpsr_val, 29) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(fpsr, 29) }
		inline uint32_t is_disabled(uint32_t fpsr_val) noexcept { IS_BIT_DISABLED_FUNC(fpsr_val, 29) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(fpsr, 0x20000000) }
		inline uint32_t enable(uint32_t fpsr_val) noexcept { SET_BITS_BY_MASK_FUNC(fpsr_val, 0x20000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(fpsr, 0x20000000) }
		inline uint32_t disable(uint32_t fpsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(fpsr_val, 0x20000000) }
	}

	namespace v
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(fpsr, 28) }
		inline uint32_t is_enabled(uint32_t fpsr_val) noexcept { IS_BIT_ENABLED_FUNC(fpsr_val, 28) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(fpsr, 28) }
		inline uint32_t is_disabled(uint32_t fpsr_val) noexcept { IS_BIT_DISABLED_FUNC(fpsr_val, 28) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(fpsr, 0x10000000) }
		inline uint32_t enable(uint32_t fpsr_val) noexcept { SET_BITS_BY_MASK_FUNC(fpsr_val, 0x10000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(fpsr, 0x10000000) }
		inline uint32_t disable(uint32_t fpsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(fpsr_val, 0x10000000) }
	}

	namespace qc
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(fpsr, 27) }
		inline uint32_t is_enabled(uint32_t fpsr_val) noexcept { IS_BIT_ENABLED_FUNC(fpsr_val, 27) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(fpsr, 27) }
		inline uint32_t is_disabled(uint32_t fpsr_val) noexcept { IS_BIT_DISABLED_FUNC(fpsr_val, 27) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(fpsr, 0x8000000) }
		inline uint32_t enable(uint32_t fpsr_val) noexcept { SET_BITS_BY_MASK_FUNC(fpsr_val, 0x8000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(fpsr, 0x8000000) }
		inline uint32_t disable(uint32_t fpsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(fpsr_val, 0x8000000) }
	}

	namespace idc
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(fpsr, 7) }
		inline uint32_t is_enabled(uint32_t fpsr_val) noexcept { IS_BIT_ENABLED_FUNC(fpsr_val, 7) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(fpsr, 7) }
		inline uint32_t is_disabled(uint32_t fpsr_val) noexcept { IS_BIT_DISABLED_FUNC(fpsr_val, 7) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(fpsr, 0x80) }
		inline uint32_t enable(uint32_t fpsr_val) noexcept { SET_BITS_BY_MASK_FUNC(fpsr_val, 0x80) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(fpsr, 0x80) }
		inline uint32_t disable(uint32_t fpsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(fpsr_val, 0x80) }
	}

	namespace ixc
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(fpsr, 4) }
		inline uint32_t is_enabled(uint32_t fpsr_val) noexcept { IS_BIT_ENABLED_FUNC(fpsr_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(fpsr, 4) }
		inline uint32_t is_disabled(uint32_t fpsr_val) noexcept { IS_BIT_DISABLED_FUNC(fpsr_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(fpsr, 0x10) }
		inline uint32_t enable(uint32_t fpsr_val) noexcept { SET_BITS_BY_MASK_FUNC(fpsr_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(fpsr, 0x10) }
		inline uint32_t disable(uint32_t fpsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(fpsr_val, 0x10) }
	}

	namespace ufc
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(fpsr, 3) }
		inline uint32_t is_enabled(uint32_t fpsr_val) noexcept { IS_BIT_ENABLED_FUNC(fpsr_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(fpsr, 3) }
		inline uint32_t is_disabled(uint32_t fpsr_val) noexcept { IS_BIT_DISABLED_FUNC(fpsr_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(fpsr, 0x8) }
		inline uint32_t enable(uint32_t fpsr_val) noexcept { SET_BITS_BY_MASK_FUNC(fpsr_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(fpsr, 0x8) }
		inline uint32_t disable(uint32_t fpsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(fpsr_val, 0x8) }
	}

	namespace ofc
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(fpsr, 2) }
		inline uint32_t is_enabled(uint32_t fpsr_val) noexcept { IS_BIT_ENABLED_FUNC(fpsr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(fpsr, 2) }
		inline uint32_t is_disabled(uint32_t fpsr_val) noexcept { IS_BIT_DISABLED_FUNC(fpsr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(fpsr, 0x4) }
		inline uint32_t enable(uint32_t fpsr_val) noexcept { SET_BITS_BY_MASK_FUNC(fpsr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(fpsr, 0x4) }
		inline uint32_t disable(uint32_t fpsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(fpsr_val, 0x4) }
	}

	namespace dzc
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(fpsr, 1) }
		inline uint32_t is_enabled(uint32_t fpsr_val) noexcept { IS_BIT_ENABLED_FUNC(fpsr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(fpsr, 1) }
		inline uint32_t is_disabled(uint32_t fpsr_val) noexcept { IS_BIT_DISABLED_FUNC(fpsr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(fpsr, 0x2) }
		inline uint32_t enable(uint32_t fpsr_val) noexcept { SET_BITS_BY_MASK_FUNC(fpsr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(fpsr, 0x2) }
		inline uint32_t disable(uint32_t fpsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(fpsr_val, 0x2) }
	}

	namespace ioc
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(fpsr, 0) }
		inline uint32_t is_enabled(uint32_t fpsr_val) noexcept { IS_BIT_ENABLED_FUNC(fpsr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(fpsr, 0) }
		inline uint32_t is_disabled(uint32_t fpsr_val) noexcept { IS_BIT_DISABLED_FUNC(fpsr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(fpsr, 0x1) }
		inline uint32_t enable(uint32_t fpsr_val) noexcept { SET_BITS_BY_MASK_FUNC(fpsr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(fpsr, 0x1) }
		inline uint32_t disable(uint32_t fpsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(fpsr_val, 0x1) }
	}
}

// HACR_EL2 (Hypervisor Auxiliary Control Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace hacr_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(hacr_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(hacr_el2, val) }
}

// HCR_EL2 (Hypervisor Configuration Register)
// Provides configuration controls for virtualization, including defining whether various Non-secure operations are trapped to EL2.
namespace hcr_el2
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(hcr_el2) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(hcr_el2, val) }
}

// HPFAR_EL2 (Hypervisor IPA Fault Address Register)
// Holds the faulting IPA for some aborts on a stage 2 translation taken to EL2.
namespace hpfar_el2
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(hpfar_el2) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(hpfar_el2, val) }
}

// HSTR_EL2 (Hypervisor System Trap Register)
// Controls trapping to EL2 of Non-secure EL1 or lower AArch32 accesses to the System register in the coproc == 
namespace hstr_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(hstr_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(hstr_el2, val) }

	namespace t_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(hstr_el2, 0xffff, 0) }
		inline uint32_t get(uint32_t hstr_el2_val) noexcept { GET_BITFIELD_FUNC(hstr_el2_val, 0xffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(hstr_el2, value, 0xffff, 0) }
		inline uint32_t set(uint32_t hstr_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(hstr_el2, value, 0xffff, 0) }
	}
}

// IC IALLU (Instruction Cache Invalidate All to PoU)
// Invalidate all instruction caches to Point of Unification.
namespace ic iallu
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ic iallu) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ic iallu, val) }
}

// IC IALLUIS (Instruction Cache Invalidate All to PoU, Inner Shareable)
// Invalidate all instruction caches in Inner Shareable domain to Point of Unification.
namespace ic ialluis
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ic ialluis) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ic ialluis, val) }
}

// IC IVAU (Instruction Cache line Invalidate by VA to PoU)
// Invalidate instruction cache by address to Point of Unification.
namespace ic ivau
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(ic ivau) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ic ivau, val) }

	namespace virtual_address_to_use
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(ic ivau, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t ic ivau_val) noexcept { GET_BITFIELD_FUNC(ic ivau_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ic ivau, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t ic ivau, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ic ivau, value, 0xffffffffffffffff, 0) }
	}
}

// ICC_AP0R<n>_EL1 (Interrupt Controller Active Priorities Group 0 Registers)
// Provides information about Group 0 active priorities.
namespace icc_ap0r<n>_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_ap0r<n>_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_ap0r<n>_el1, val) }
}

// ICC_AP1R<n>_EL1 (Interrupt Controller Active Priorities Group 1 Registers)
// Provides information about Group 1 active priorities.
namespace icc_ap1r<n>_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_ap1r<n>_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_ap1r<n>_el1, val) }
}

// ICC_ASGI1R_EL1 (Interrupt Controller Alias Software Generated Interrupt Group 1 Register)
// Generates Group 1 SGIs for the Security state that is not the current Security state.
namespace icc_asgi1r_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(icc_asgi1r_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_asgi1r_el1, val) }

	namespace aff3
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_asgi1r_el1, 0xff000000000000, 48) }
		inline uint64_t get(uint64_t icc_asgi1r_el1_val) noexcept { GET_BITFIELD_FUNC(icc_asgi1r_el1_val, 0xff000000000000, 48) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_asgi1r_el1, value, 0xff000000000000, 48) }
		inline uint64_t set(uint64_t icc_asgi1r_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_asgi1r_el1, value, 0xff000000000000, 48) }
	}

	namespace rs
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_asgi1r_el1, 0xf00000000000, 44) }
		inline uint64_t get(uint64_t icc_asgi1r_el1_val) noexcept { GET_BITFIELD_FUNC(icc_asgi1r_el1_val, 0xf00000000000, 44) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_asgi1r_el1, value, 0xf00000000000, 44) }
		inline uint64_t set(uint64_t icc_asgi1r_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_asgi1r_el1, value, 0xf00000000000, 44) }
	}

	namespace irm
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_asgi1r_el1, 40) }
		inline uint64_t is_enabled(uint64_t icc_asgi1r_el1_val) noexcept { IS_BIT_ENABLED_FUNC(icc_asgi1r_el1_val, 40) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_asgi1r_el1, 40) }
		inline uint64_t is_disabled(uint64_t icc_asgi1r_el1_val) noexcept { IS_BIT_DISABLED_FUNC(icc_asgi1r_el1_val, 40) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_asgi1r_el1, 0x10000000000) }
		inline uint64_t enable(uint64_t icc_asgi1r_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_asgi1r_el1_val, 0x10000000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_asgi1r_el1, 0x10000000000) }
		inline uint64_t disable(uint64_t icc_asgi1r_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_asgi1r_el1_val, 0x10000000000) }
	}

	namespace aff2
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_asgi1r_el1, 0xff00000000, 32) }
		inline uint64_t get(uint64_t icc_asgi1r_el1_val) noexcept { GET_BITFIELD_FUNC(icc_asgi1r_el1_val, 0xff00000000, 32) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_asgi1r_el1, value, 0xff00000000, 32) }
		inline uint64_t set(uint64_t icc_asgi1r_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_asgi1r_el1, value, 0xff00000000, 32) }
	}

	namespace intid
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_asgi1r_el1, 0xf000000, 24) }
		inline uint64_t get(uint64_t icc_asgi1r_el1_val) noexcept { GET_BITFIELD_FUNC(icc_asgi1r_el1_val, 0xf000000, 24) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_asgi1r_el1, value, 0xf000000, 24) }
		inline uint64_t set(uint64_t icc_asgi1r_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_asgi1r_el1, value, 0xf000000, 24) }
	}

	namespace aff1
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_asgi1r_el1, 0xff0000, 16) }
		inline uint64_t get(uint64_t icc_asgi1r_el1_val) noexcept { GET_BITFIELD_FUNC(icc_asgi1r_el1_val, 0xff0000, 16) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_asgi1r_el1, value, 0xff0000, 16) }
		inline uint64_t set(uint64_t icc_asgi1r_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_asgi1r_el1, value, 0xff0000, 16) }
	}

	namespace targetlist
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_asgi1r_el1, 0xffff, 0) }
		inline uint64_t get(uint64_t icc_asgi1r_el1_val) noexcept { GET_BITFIELD_FUNC(icc_asgi1r_el1_val, 0xffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_asgi1r_el1, value, 0xffff, 0) }
		inline uint64_t set(uint64_t icc_asgi1r_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_asgi1r_el1, value, 0xffff, 0) }
	}
}

// ICC_BPR0_EL1 (Interrupt Controller Binary Point Register 0)
// Defines the point at which the priority value fields split into two parts, the group priority field and the subpriority field. The group priority field determines Group 0 interrupt preemption.
namespace icc_bpr0_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_bpr0_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_bpr0_el1, val) }

	namespace binarypoint
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_bpr0_el1, 0x7, 0) }
		inline uint32_t get(uint32_t icc_bpr0_el1_val) noexcept { GET_BITFIELD_FUNC(icc_bpr0_el1_val, 0x7, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_bpr0_el1, value, 0x7, 0) }
		inline uint32_t set(uint32_t icc_bpr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_bpr0_el1, value, 0x7, 0) }
	}
}

// ICC_BPR1_EL1 (Interrupt Controller Binary Point Register 1)
// Defines the point at which the priority value fields split into two parts, the group priority field and the subpriority field. The group priority field determines Group 1 interrupt preemption.
namespace icc_bpr1_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_bpr1_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_bpr1_el1, val) }

	namespace binarypoint
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_bpr1_el1, 0x7, 0) }
		inline uint32_t get(uint32_t icc_bpr1_el1_val) noexcept { GET_BITFIELD_FUNC(icc_bpr1_el1_val, 0x7, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_bpr1_el1, value, 0x7, 0) }
		inline uint32_t set(uint32_t icc_bpr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_bpr1_el1, value, 0x7, 0) }
	}
}

// ICC_CTLR_EL1 (Interrupt Controller Control Register (EL1))
// Controls aspects of the behavior of the GIC CPU interface and provides information about the features implemented.
namespace icc_ctlr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_ctlr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_ctlr_el1, val) }

	namespace rss
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_ctlr_el1, 18) }
		inline uint32_t is_enabled(uint32_t icc_ctlr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(icc_ctlr_el1_val, 18) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_ctlr_el1, 18) }
		inline uint32_t is_disabled(uint32_t icc_ctlr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(icc_ctlr_el1_val, 18) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el1, 0x40000) }
		inline uint32_t enable(uint32_t icc_ctlr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_ctlr_el1_val, 0x40000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el1, 0x40000) }
		inline uint32_t disable(uint32_t icc_ctlr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_ctlr_el1_val, 0x40000) }
	}

	namespace a3v
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_ctlr_el1, 15) }
		inline uint32_t is_enabled(uint32_t icc_ctlr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(icc_ctlr_el1_val, 15) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_ctlr_el1, 15) }
		inline uint32_t is_disabled(uint32_t icc_ctlr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(icc_ctlr_el1_val, 15) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el1, 0x8000) }
		inline uint32_t enable(uint32_t icc_ctlr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_ctlr_el1_val, 0x8000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el1, 0x8000) }
		inline uint32_t disable(uint32_t icc_ctlr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_ctlr_el1_val, 0x8000) }
	}

	namespace seis
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_ctlr_el1, 14) }
		inline uint32_t is_enabled(uint32_t icc_ctlr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(icc_ctlr_el1_val, 14) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_ctlr_el1, 14) }
		inline uint32_t is_disabled(uint32_t icc_ctlr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(icc_ctlr_el1_val, 14) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el1, 0x4000) }
		inline uint32_t enable(uint32_t icc_ctlr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_ctlr_el1_val, 0x4000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el1, 0x4000) }
		inline uint32_t disable(uint32_t icc_ctlr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_ctlr_el1_val, 0x4000) }
	}

	namespace idbits
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_ctlr_el1, 0x3800, 11) }
		inline uint32_t get(uint32_t icc_ctlr_el1_val) noexcept { GET_BITFIELD_FUNC(icc_ctlr_el1_val, 0x3800, 11) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_ctlr_el1, value, 0x3800, 11) }
		inline uint32_t set(uint32_t icc_ctlr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_ctlr_el1, value, 0x3800, 11) }
	}

	namespace pribits
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_ctlr_el1, 0x700, 8) }
		inline uint32_t get(uint32_t icc_ctlr_el1_val) noexcept { GET_BITFIELD_FUNC(icc_ctlr_el1_val, 0x700, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_ctlr_el1, value, 0x700, 8) }
		inline uint32_t set(uint32_t icc_ctlr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_ctlr_el1, value, 0x700, 8) }
	}

	namespace pmhe
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_ctlr_el1, 6) }
		inline uint32_t is_enabled(uint32_t icc_ctlr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(icc_ctlr_el1_val, 6) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_ctlr_el1, 6) }
		inline uint32_t is_disabled(uint32_t icc_ctlr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(icc_ctlr_el1_val, 6) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el1, 0x40) }
		inline uint32_t enable(uint32_t icc_ctlr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_ctlr_el1_val, 0x40) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el1, 0x40) }
		inline uint32_t disable(uint32_t icc_ctlr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_ctlr_el1_val, 0x40) }
	}

	namespace eoimode
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_ctlr_el1, 1) }
		inline uint32_t is_enabled(uint32_t icc_ctlr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(icc_ctlr_el1_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_ctlr_el1, 1) }
		inline uint32_t is_disabled(uint32_t icc_ctlr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(icc_ctlr_el1_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el1, 0x2) }
		inline uint32_t enable(uint32_t icc_ctlr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_ctlr_el1_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el1, 0x2) }
		inline uint32_t disable(uint32_t icc_ctlr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_ctlr_el1_val, 0x2) }
	}

	namespace cbpr
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_ctlr_el1, 0) }
		inline uint32_t is_enabled(uint32_t icc_ctlr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(icc_ctlr_el1_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_ctlr_el1, 0) }
		inline uint32_t is_disabled(uint32_t icc_ctlr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(icc_ctlr_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el1, 0x1) }
		inline uint32_t enable(uint32_t icc_ctlr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_ctlr_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el1, 0x1) }
		inline uint32_t disable(uint32_t icc_ctlr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_ctlr_el1_val, 0x1) }
	}
}

// ICC_CTLR_EL3 (Interrupt Controller Control Register (EL3))
// Controls aspects of the behavior of the GIC CPU interface and provides information about the features implemented.
namespace icc_ctlr_el3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_ctlr_el3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_ctlr_el3, val) }

	namespace rss
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_ctlr_el3, 18) }
		inline uint32_t is_enabled(uint32_t icc_ctlr_el3_val) noexcept { IS_BIT_ENABLED_FUNC(icc_ctlr_el3_val, 18) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_ctlr_el3, 18) }
		inline uint32_t is_disabled(uint32_t icc_ctlr_el3_val) noexcept { IS_BIT_DISABLED_FUNC(icc_ctlr_el3_val, 18) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el3, 0x40000) }
		inline uint32_t enable(uint32_t icc_ctlr_el3_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_ctlr_el3_val, 0x40000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el3, 0x40000) }
		inline uint32_t disable(uint32_t icc_ctlr_el3_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_ctlr_el3_val, 0x40000) }
	}

	namespace nds
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_ctlr_el3, 17) }
		inline uint32_t is_enabled(uint32_t icc_ctlr_el3_val) noexcept { IS_BIT_ENABLED_FUNC(icc_ctlr_el3_val, 17) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_ctlr_el3, 17) }
		inline uint32_t is_disabled(uint32_t icc_ctlr_el3_val) noexcept { IS_BIT_DISABLED_FUNC(icc_ctlr_el3_val, 17) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el3, 0x20000) }
		inline uint32_t enable(uint32_t icc_ctlr_el3_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_ctlr_el3_val, 0x20000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el3, 0x20000) }
		inline uint32_t disable(uint32_t icc_ctlr_el3_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_ctlr_el3_val, 0x20000) }
	}

	namespace a3v
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_ctlr_el3, 15) }
		inline uint32_t is_enabled(uint32_t icc_ctlr_el3_val) noexcept { IS_BIT_ENABLED_FUNC(icc_ctlr_el3_val, 15) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_ctlr_el3, 15) }
		inline uint32_t is_disabled(uint32_t icc_ctlr_el3_val) noexcept { IS_BIT_DISABLED_FUNC(icc_ctlr_el3_val, 15) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el3, 0x8000) }
		inline uint32_t enable(uint32_t icc_ctlr_el3_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_ctlr_el3_val, 0x8000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el3, 0x8000) }
		inline uint32_t disable(uint32_t icc_ctlr_el3_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_ctlr_el3_val, 0x8000) }
	}

	namespace seis
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_ctlr_el3, 14) }
		inline uint32_t is_enabled(uint32_t icc_ctlr_el3_val) noexcept { IS_BIT_ENABLED_FUNC(icc_ctlr_el3_val, 14) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_ctlr_el3, 14) }
		inline uint32_t is_disabled(uint32_t icc_ctlr_el3_val) noexcept { IS_BIT_DISABLED_FUNC(icc_ctlr_el3_val, 14) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el3, 0x4000) }
		inline uint32_t enable(uint32_t icc_ctlr_el3_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_ctlr_el3_val, 0x4000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el3, 0x4000) }
		inline uint32_t disable(uint32_t icc_ctlr_el3_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_ctlr_el3_val, 0x4000) }
	}

	namespace idbits
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_ctlr_el3, 0x3800, 11) }
		inline uint32_t get(uint32_t icc_ctlr_el3_val) noexcept { GET_BITFIELD_FUNC(icc_ctlr_el3_val, 0x3800, 11) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_ctlr_el3, value, 0x3800, 11) }
		inline uint32_t set(uint32_t icc_ctlr_el3, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_ctlr_el3, value, 0x3800, 11) }
	}

	namespace pribits
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_ctlr_el3, 0x700, 8) }
		inline uint32_t get(uint32_t icc_ctlr_el3_val) noexcept { GET_BITFIELD_FUNC(icc_ctlr_el3_val, 0x700, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_ctlr_el3, value, 0x700, 8) }
		inline uint32_t set(uint32_t icc_ctlr_el3, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_ctlr_el3, value, 0x700, 8) }
	}

	namespace pmhe
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_ctlr_el3, 6) }
		inline uint32_t is_enabled(uint32_t icc_ctlr_el3_val) noexcept { IS_BIT_ENABLED_FUNC(icc_ctlr_el3_val, 6) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_ctlr_el3, 6) }
		inline uint32_t is_disabled(uint32_t icc_ctlr_el3_val) noexcept { IS_BIT_DISABLED_FUNC(icc_ctlr_el3_val, 6) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el3, 0x40) }
		inline uint32_t enable(uint32_t icc_ctlr_el3_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_ctlr_el3_val, 0x40) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el3, 0x40) }
		inline uint32_t disable(uint32_t icc_ctlr_el3_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_ctlr_el3_val, 0x40) }
	}

	namespace rm
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_ctlr_el3, 5) }
		inline uint32_t is_enabled(uint32_t icc_ctlr_el3_val) noexcept { IS_BIT_ENABLED_FUNC(icc_ctlr_el3_val, 5) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_ctlr_el3, 5) }
		inline uint32_t is_disabled(uint32_t icc_ctlr_el3_val) noexcept { IS_BIT_DISABLED_FUNC(icc_ctlr_el3_val, 5) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el3, 0x20) }
		inline uint32_t enable(uint32_t icc_ctlr_el3_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_ctlr_el3_val, 0x20) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el3, 0x20) }
		inline uint32_t disable(uint32_t icc_ctlr_el3_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_ctlr_el3_val, 0x20) }
	}

	namespace eoimode_el1ns
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_ctlr_el3, 4) }
		inline uint32_t is_enabled(uint32_t icc_ctlr_el3_val) noexcept { IS_BIT_ENABLED_FUNC(icc_ctlr_el3_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_ctlr_el3, 4) }
		inline uint32_t is_disabled(uint32_t icc_ctlr_el3_val) noexcept { IS_BIT_DISABLED_FUNC(icc_ctlr_el3_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el3, 0x10) }
		inline uint32_t enable(uint32_t icc_ctlr_el3_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_ctlr_el3_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el3, 0x10) }
		inline uint32_t disable(uint32_t icc_ctlr_el3_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_ctlr_el3_val, 0x10) }
	}

	namespace eoimode_el1s
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_ctlr_el3, 3) }
		inline uint32_t is_enabled(uint32_t icc_ctlr_el3_val) noexcept { IS_BIT_ENABLED_FUNC(icc_ctlr_el3_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_ctlr_el3, 3) }
		inline uint32_t is_disabled(uint32_t icc_ctlr_el3_val) noexcept { IS_BIT_DISABLED_FUNC(icc_ctlr_el3_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el3, 0x8) }
		inline uint32_t enable(uint32_t icc_ctlr_el3_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_ctlr_el3_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el3, 0x8) }
		inline uint32_t disable(uint32_t icc_ctlr_el3_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_ctlr_el3_val, 0x8) }
	}

	namespace eoimode_el3
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_ctlr_el3, 2) }
		inline uint32_t is_enabled(uint32_t icc_ctlr_el3_val) noexcept { IS_BIT_ENABLED_FUNC(icc_ctlr_el3_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_ctlr_el3, 2) }
		inline uint32_t is_disabled(uint32_t icc_ctlr_el3_val) noexcept { IS_BIT_DISABLED_FUNC(icc_ctlr_el3_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el3, 0x4) }
		inline uint32_t enable(uint32_t icc_ctlr_el3_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_ctlr_el3_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el3, 0x4) }
		inline uint32_t disable(uint32_t icc_ctlr_el3_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_ctlr_el3_val, 0x4) }
	}

	namespace cbpr_el1ns
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_ctlr_el3, 1) }
		inline uint32_t is_enabled(uint32_t icc_ctlr_el3_val) noexcept { IS_BIT_ENABLED_FUNC(icc_ctlr_el3_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_ctlr_el3, 1) }
		inline uint32_t is_disabled(uint32_t icc_ctlr_el3_val) noexcept { IS_BIT_DISABLED_FUNC(icc_ctlr_el3_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el3, 0x2) }
		inline uint32_t enable(uint32_t icc_ctlr_el3_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_ctlr_el3_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el3, 0x2) }
		inline uint32_t disable(uint32_t icc_ctlr_el3_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_ctlr_el3_val, 0x2) }
	}

	namespace cbpr_el1s
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_ctlr_el3, 0) }
		inline uint32_t is_enabled(uint32_t icc_ctlr_el3_val) noexcept { IS_BIT_ENABLED_FUNC(icc_ctlr_el3_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_ctlr_el3, 0) }
		inline uint32_t is_disabled(uint32_t icc_ctlr_el3_val) noexcept { IS_BIT_DISABLED_FUNC(icc_ctlr_el3_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el3, 0x1) }
		inline uint32_t enable(uint32_t icc_ctlr_el3_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_ctlr_el3_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_ctlr_el3, 0x1) }
		inline uint32_t disable(uint32_t icc_ctlr_el3_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_ctlr_el3_val, 0x1) }
	}
}

// ICC_DIR_EL1 (Interrupt Controller Deactivate Interrupt Register)
// When interrupt priority drop is separated from interrupt deactivation, a write to this register deactivates the specified interrupt.
namespace icc_dir_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_dir_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_dir_el1, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_dir_el1, 0xffffff, 0) }
		inline uint32_t get(uint32_t icc_dir_el1_val) noexcept { GET_BITFIELD_FUNC(icc_dir_el1_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_dir_el1, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icc_dir_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_dir_el1, value, 0xffffff, 0) }
	}
}

// ICC_EOIR0_EL1 (Interrupt Controller End Of Interrupt Register 0)
// A PE writes to this register to inform the CPU interface that it has completed the processing of the specified Group 0 interrupt.
namespace icc_eoir0_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_eoir0_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_eoir0_el1, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_eoir0_el1, 0xffffff, 0) }
		inline uint32_t get(uint32_t icc_eoir0_el1_val) noexcept { GET_BITFIELD_FUNC(icc_eoir0_el1_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_eoir0_el1, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icc_eoir0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_eoir0_el1, value, 0xffffff, 0) }
	}
}

// ICC_EOIR1_EL1 (Interrupt Controller End Of Interrupt Register 1)
// A PE writes to this register to inform the CPU interface that it has completed the processing of the specified Group 1 interrupt.
namespace icc_eoir1_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_eoir1_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_eoir1_el1, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_eoir1_el1, 0xffffff, 0) }
		inline uint32_t get(uint32_t icc_eoir1_el1_val) noexcept { GET_BITFIELD_FUNC(icc_eoir1_el1_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_eoir1_el1, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icc_eoir1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_eoir1_el1, value, 0xffffff, 0) }
	}
}

// ICC_HPPIR0_EL1 (Interrupt Controller Highest Priority Pending Interrupt Register 0)
// Indicates the highest priority pending Group 0 interrupt on the CPU interface.
namespace icc_hppir0_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_hppir0_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_hppir0_el1, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_hppir0_el1, 0xffffff, 0) }
		inline uint32_t get(uint32_t icc_hppir0_el1_val) noexcept { GET_BITFIELD_FUNC(icc_hppir0_el1_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_hppir0_el1, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icc_hppir0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_hppir0_el1, value, 0xffffff, 0) }
	}
}

// ICC_HPPIR1_EL1 (Interrupt Controller Highest Priority Pending Interrupt Register 1)
// Indicates the highest priority pending Group 1 interrupt on the CPU interface.
namespace icc_hppir1_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_hppir1_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_hppir1_el1, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_hppir1_el1, 0xffffff, 0) }
		inline uint32_t get(uint32_t icc_hppir1_el1_val) noexcept { GET_BITFIELD_FUNC(icc_hppir1_el1_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_hppir1_el1, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icc_hppir1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_hppir1_el1, value, 0xffffff, 0) }
	}
}

// ICC_IAR0_EL1 (Interrupt Controller Interrupt Acknowledge Register 0)
// The PE reads this register to obtain the INTID of the signaled Group 0 interrupt. This read acts as an acknowledge for the interrupt.
namespace icc_iar0_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_iar0_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_iar0_el1, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_iar0_el1, 0xffffff, 0) }
		inline uint32_t get(uint32_t icc_iar0_el1_val) noexcept { GET_BITFIELD_FUNC(icc_iar0_el1_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_iar0_el1, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icc_iar0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_iar0_el1, value, 0xffffff, 0) }
	}
}

// ICC_IAR1_EL1 (Interrupt Controller Interrupt Acknowledge Register 1)
// The PE reads this register to obtain the INTID of the signaled Group 1 interrupt. This read acts as an acknowledge for the interrupt.
namespace icc_iar1_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_iar1_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_iar1_el1, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_iar1_el1, 0xffffff, 0) }
		inline uint32_t get(uint32_t icc_iar1_el1_val) noexcept { GET_BITFIELD_FUNC(icc_iar1_el1_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_iar1_el1, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icc_iar1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_iar1_el1, value, 0xffffff, 0) }
	}
}

// ICC_IGRPEN0_EL1 (Interrupt Controller Interrupt Group 0 Enable register)
// Controls whether Group 0 interrupts are enabled or not.
namespace icc_igrpen0_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_igrpen0_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_igrpen0_el1, val) }

	namespace enable
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_igrpen0_el1, 0) }
		inline uint32_t is_enabled(uint32_t icc_igrpen0_el1_val) noexcept { IS_BIT_ENABLED_FUNC(icc_igrpen0_el1_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_igrpen0_el1, 0) }
		inline uint32_t is_disabled(uint32_t icc_igrpen0_el1_val) noexcept { IS_BIT_DISABLED_FUNC(icc_igrpen0_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_igrpen0_el1, 0x1) }
		inline uint32_t enable(uint32_t icc_igrpen0_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_igrpen0_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_igrpen0_el1, 0x1) }
		inline uint32_t disable(uint32_t icc_igrpen0_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_igrpen0_el1_val, 0x1) }
	}
}

// ICC_IGRPEN1_EL1 (Interrupt Controller Interrupt Group 1 Enable register)
// Controls whether Group 1 interrupts are enabled for the current Security state.
namespace icc_igrpen1_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_igrpen1_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_igrpen1_el1, val) }

	namespace enable
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_igrpen1_el1, 0) }
		inline uint32_t is_enabled(uint32_t icc_igrpen1_el1_val) noexcept { IS_BIT_ENABLED_FUNC(icc_igrpen1_el1_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_igrpen1_el1, 0) }
		inline uint32_t is_disabled(uint32_t icc_igrpen1_el1_val) noexcept { IS_BIT_DISABLED_FUNC(icc_igrpen1_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_igrpen1_el1, 0x1) }
		inline uint32_t enable(uint32_t icc_igrpen1_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_igrpen1_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_igrpen1_el1, 0x1) }
		inline uint32_t disable(uint32_t icc_igrpen1_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_igrpen1_el1_val, 0x1) }
	}
}

// ICC_IGRPEN1_EL3 (Interrupt Controller Interrupt Group 1 Enable register (EL3))
// Controls whether Group 1 interrupts are enabled or not.
namespace icc_igrpen1_el3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_igrpen1_el3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_igrpen1_el3, val) }

	namespace enablegrp1s
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_igrpen1_el3, 1) }
		inline uint32_t is_enabled(uint32_t icc_igrpen1_el3_val) noexcept { IS_BIT_ENABLED_FUNC(icc_igrpen1_el3_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_igrpen1_el3, 1) }
		inline uint32_t is_disabled(uint32_t icc_igrpen1_el3_val) noexcept { IS_BIT_DISABLED_FUNC(icc_igrpen1_el3_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_igrpen1_el3, 0x2) }
		inline uint32_t enable(uint32_t icc_igrpen1_el3_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_igrpen1_el3_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_igrpen1_el3, 0x2) }
		inline uint32_t disable(uint32_t icc_igrpen1_el3_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_igrpen1_el3_val, 0x2) }
	}

	namespace enablegrp1ns
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_igrpen1_el3, 0) }
		inline uint32_t is_enabled(uint32_t icc_igrpen1_el3_val) noexcept { IS_BIT_ENABLED_FUNC(icc_igrpen1_el3_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_igrpen1_el3, 0) }
		inline uint32_t is_disabled(uint32_t icc_igrpen1_el3_val) noexcept { IS_BIT_DISABLED_FUNC(icc_igrpen1_el3_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_igrpen1_el3, 0x1) }
		inline uint32_t enable(uint32_t icc_igrpen1_el3_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_igrpen1_el3_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_igrpen1_el3, 0x1) }
		inline uint32_t disable(uint32_t icc_igrpen1_el3_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_igrpen1_el3_val, 0x1) }
	}
}

// ICC_PMR_EL1 (Interrupt Controller Interrupt Priority Mask Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace icc_pmr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_pmr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_pmr_el1, val) }

	namespace priority
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_pmr_el1, 0xff, 0) }
		inline uint32_t get(uint32_t icc_pmr_el1_val) noexcept { GET_BITFIELD_FUNC(icc_pmr_el1_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_pmr_el1, value, 0xff, 0) }
		inline uint32_t set(uint32_t icc_pmr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_pmr_el1, value, 0xff, 0) }
	}
}

// ICC_RPR_EL1 (Interrupt Controller Running Priority Register)
// Indicates the Running priority of the CPU interface.
namespace icc_rpr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_rpr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_rpr_el1, val) }

	namespace priority
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_rpr_el1, 0xff, 0) }
		inline uint32_t get(uint32_t icc_rpr_el1_val) noexcept { GET_BITFIELD_FUNC(icc_rpr_el1_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_rpr_el1, value, 0xff, 0) }
		inline uint32_t set(uint32_t icc_rpr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_rpr_el1, value, 0xff, 0) }
	}
}

// ICC_SGI0R_EL1 (Interrupt Controller Software Generated Interrupt Group 0 Register)
// Generates Secure Group 0 SGIs.
namespace icc_sgi0r_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(icc_sgi0r_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_sgi0r_el1, val) }

	namespace aff3
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_sgi0r_el1, 0xff000000000000, 48) }
		inline uint64_t get(uint64_t icc_sgi0r_el1_val) noexcept { GET_BITFIELD_FUNC(icc_sgi0r_el1_val, 0xff000000000000, 48) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_sgi0r_el1, value, 0xff000000000000, 48) }
		inline uint64_t set(uint64_t icc_sgi0r_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_sgi0r_el1, value, 0xff000000000000, 48) }
	}

	namespace rs
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_sgi0r_el1, 0xf00000000000, 44) }
		inline uint64_t get(uint64_t icc_sgi0r_el1_val) noexcept { GET_BITFIELD_FUNC(icc_sgi0r_el1_val, 0xf00000000000, 44) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_sgi0r_el1, value, 0xf00000000000, 44) }
		inline uint64_t set(uint64_t icc_sgi0r_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_sgi0r_el1, value, 0xf00000000000, 44) }
	}

	namespace irm
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_sgi0r_el1, 40) }
		inline uint64_t is_enabled(uint64_t icc_sgi0r_el1_val) noexcept { IS_BIT_ENABLED_FUNC(icc_sgi0r_el1_val, 40) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_sgi0r_el1, 40) }
		inline uint64_t is_disabled(uint64_t icc_sgi0r_el1_val) noexcept { IS_BIT_DISABLED_FUNC(icc_sgi0r_el1_val, 40) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_sgi0r_el1, 0x10000000000) }
		inline uint64_t enable(uint64_t icc_sgi0r_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_sgi0r_el1_val, 0x10000000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_sgi0r_el1, 0x10000000000) }
		inline uint64_t disable(uint64_t icc_sgi0r_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_sgi0r_el1_val, 0x10000000000) }
	}

	namespace aff2
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_sgi0r_el1, 0xff00000000, 32) }
		inline uint64_t get(uint64_t icc_sgi0r_el1_val) noexcept { GET_BITFIELD_FUNC(icc_sgi0r_el1_val, 0xff00000000, 32) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_sgi0r_el1, value, 0xff00000000, 32) }
		inline uint64_t set(uint64_t icc_sgi0r_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_sgi0r_el1, value, 0xff00000000, 32) }
	}

	namespace intid
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_sgi0r_el1, 0xf000000, 24) }
		inline uint64_t get(uint64_t icc_sgi0r_el1_val) noexcept { GET_BITFIELD_FUNC(icc_sgi0r_el1_val, 0xf000000, 24) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_sgi0r_el1, value, 0xf000000, 24) }
		inline uint64_t set(uint64_t icc_sgi0r_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_sgi0r_el1, value, 0xf000000, 24) }
	}

	namespace aff1
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_sgi0r_el1, 0xff0000, 16) }
		inline uint64_t get(uint64_t icc_sgi0r_el1_val) noexcept { GET_BITFIELD_FUNC(icc_sgi0r_el1_val, 0xff0000, 16) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_sgi0r_el1, value, 0xff0000, 16) }
		inline uint64_t set(uint64_t icc_sgi0r_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_sgi0r_el1, value, 0xff0000, 16) }
	}

	namespace targetlist
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_sgi0r_el1, 0xffff, 0) }
		inline uint64_t get(uint64_t icc_sgi0r_el1_val) noexcept { GET_BITFIELD_FUNC(icc_sgi0r_el1_val, 0xffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_sgi0r_el1, value, 0xffff, 0) }
		inline uint64_t set(uint64_t icc_sgi0r_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_sgi0r_el1, value, 0xffff, 0) }
	}
}

// ICC_SGI1R_EL1 (Interrupt Controller Software Generated Interrupt Group 1 Register)
// Generates Group 1 SGIs for the current Security state.
namespace icc_sgi1r_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(icc_sgi1r_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_sgi1r_el1, val) }

	namespace aff3
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_sgi1r_el1, 0xff000000000000, 48) }
		inline uint64_t get(uint64_t icc_sgi1r_el1_val) noexcept { GET_BITFIELD_FUNC(icc_sgi1r_el1_val, 0xff000000000000, 48) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_sgi1r_el1, value, 0xff000000000000, 48) }
		inline uint64_t set(uint64_t icc_sgi1r_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_sgi1r_el1, value, 0xff000000000000, 48) }
	}

	namespace rs
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_sgi1r_el1, 0xf00000000000, 44) }
		inline uint64_t get(uint64_t icc_sgi1r_el1_val) noexcept { GET_BITFIELD_FUNC(icc_sgi1r_el1_val, 0xf00000000000, 44) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_sgi1r_el1, value, 0xf00000000000, 44) }
		inline uint64_t set(uint64_t icc_sgi1r_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_sgi1r_el1, value, 0xf00000000000, 44) }
	}

	namespace irm
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_sgi1r_el1, 40) }
		inline uint64_t is_enabled(uint64_t icc_sgi1r_el1_val) noexcept { IS_BIT_ENABLED_FUNC(icc_sgi1r_el1_val, 40) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_sgi1r_el1, 40) }
		inline uint64_t is_disabled(uint64_t icc_sgi1r_el1_val) noexcept { IS_BIT_DISABLED_FUNC(icc_sgi1r_el1_val, 40) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_sgi1r_el1, 0x10000000000) }
		inline uint64_t enable(uint64_t icc_sgi1r_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_sgi1r_el1_val, 0x10000000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_sgi1r_el1, 0x10000000000) }
		inline uint64_t disable(uint64_t icc_sgi1r_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_sgi1r_el1_val, 0x10000000000) }
	}

	namespace aff2
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_sgi1r_el1, 0xff00000000, 32) }
		inline uint64_t get(uint64_t icc_sgi1r_el1_val) noexcept { GET_BITFIELD_FUNC(icc_sgi1r_el1_val, 0xff00000000, 32) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_sgi1r_el1, value, 0xff00000000, 32) }
		inline uint64_t set(uint64_t icc_sgi1r_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_sgi1r_el1, value, 0xff00000000, 32) }
	}

	namespace intid
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_sgi1r_el1, 0xf000000, 24) }
		inline uint64_t get(uint64_t icc_sgi1r_el1_val) noexcept { GET_BITFIELD_FUNC(icc_sgi1r_el1_val, 0xf000000, 24) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_sgi1r_el1, value, 0xf000000, 24) }
		inline uint64_t set(uint64_t icc_sgi1r_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_sgi1r_el1, value, 0xf000000, 24) }
	}

	namespace aff1
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_sgi1r_el1, 0xff0000, 16) }
		inline uint64_t get(uint64_t icc_sgi1r_el1_val) noexcept { GET_BITFIELD_FUNC(icc_sgi1r_el1_val, 0xff0000, 16) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_sgi1r_el1, value, 0xff0000, 16) }
		inline uint64_t set(uint64_t icc_sgi1r_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_sgi1r_el1, value, 0xff0000, 16) }
	}

	namespace targetlist
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(icc_sgi1r_el1, 0xffff, 0) }
		inline uint64_t get(uint64_t icc_sgi1r_el1_val) noexcept { GET_BITFIELD_FUNC(icc_sgi1r_el1_val, 0xffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icc_sgi1r_el1, value, 0xffff, 0) }
		inline uint64_t set(uint64_t icc_sgi1r_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icc_sgi1r_el1, value, 0xffff, 0) }
	}
}

// ICC_SRE_EL1 (Interrupt Controller System Register Enable register (EL1))
// Controls whether the System register interface or the memory-mapped interface to the GIC CPU interface is used for EL1.
namespace icc_sre_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_sre_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_sre_el1, val) }

	namespace dib
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_sre_el1, 2) }
		inline uint32_t is_enabled(uint32_t icc_sre_el1_val) noexcept { IS_BIT_ENABLED_FUNC(icc_sre_el1_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_sre_el1, 2) }
		inline uint32_t is_disabled(uint32_t icc_sre_el1_val) noexcept { IS_BIT_DISABLED_FUNC(icc_sre_el1_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_sre_el1, 0x4) }
		inline uint32_t enable(uint32_t icc_sre_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_sre_el1_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_sre_el1, 0x4) }
		inline uint32_t disable(uint32_t icc_sre_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_sre_el1_val, 0x4) }
	}

	namespace dfb
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_sre_el1, 1) }
		inline uint32_t is_enabled(uint32_t icc_sre_el1_val) noexcept { IS_BIT_ENABLED_FUNC(icc_sre_el1_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_sre_el1, 1) }
		inline uint32_t is_disabled(uint32_t icc_sre_el1_val) noexcept { IS_BIT_DISABLED_FUNC(icc_sre_el1_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_sre_el1, 0x2) }
		inline uint32_t enable(uint32_t icc_sre_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_sre_el1_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_sre_el1, 0x2) }
		inline uint32_t disable(uint32_t icc_sre_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_sre_el1_val, 0x2) }
	}

	namespace sre
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_sre_el1, 0) }
		inline uint32_t is_enabled(uint32_t icc_sre_el1_val) noexcept { IS_BIT_ENABLED_FUNC(icc_sre_el1_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_sre_el1, 0) }
		inline uint32_t is_disabled(uint32_t icc_sre_el1_val) noexcept { IS_BIT_DISABLED_FUNC(icc_sre_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_sre_el1, 0x1) }
		inline uint32_t enable(uint32_t icc_sre_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_sre_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_sre_el1, 0x1) }
		inline uint32_t disable(uint32_t icc_sre_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_sre_el1_val, 0x1) }
	}
}

// ICC_SRE_EL2 (Interrupt Controller System Register Enable register (EL2))
// Controls whether the System register interface or the memory-mapped interface to the GIC CPU interface is used for EL2.
namespace icc_sre_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_sre_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_sre_el2, val) }

	namespace enable
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_sre_el2, 3) }
		inline uint32_t is_enabled(uint32_t icc_sre_el2_val) noexcept { IS_BIT_ENABLED_FUNC(icc_sre_el2_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_sre_el2, 3) }
		inline uint32_t is_disabled(uint32_t icc_sre_el2_val) noexcept { IS_BIT_DISABLED_FUNC(icc_sre_el2_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_sre_el2, 0x8) }
		inline uint32_t enable(uint32_t icc_sre_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_sre_el2_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_sre_el2, 0x8) }
		inline uint32_t disable(uint32_t icc_sre_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_sre_el2_val, 0x8) }
	}

	namespace dib
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_sre_el2, 2) }
		inline uint32_t is_enabled(uint32_t icc_sre_el2_val) noexcept { IS_BIT_ENABLED_FUNC(icc_sre_el2_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_sre_el2, 2) }
		inline uint32_t is_disabled(uint32_t icc_sre_el2_val) noexcept { IS_BIT_DISABLED_FUNC(icc_sre_el2_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_sre_el2, 0x4) }
		inline uint32_t enable(uint32_t icc_sre_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_sre_el2_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_sre_el2, 0x4) }
		inline uint32_t disable(uint32_t icc_sre_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_sre_el2_val, 0x4) }
	}

	namespace dfb
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_sre_el2, 1) }
		inline uint32_t is_enabled(uint32_t icc_sre_el2_val) noexcept { IS_BIT_ENABLED_FUNC(icc_sre_el2_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_sre_el2, 1) }
		inline uint32_t is_disabled(uint32_t icc_sre_el2_val) noexcept { IS_BIT_DISABLED_FUNC(icc_sre_el2_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_sre_el2, 0x2) }
		inline uint32_t enable(uint32_t icc_sre_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_sre_el2_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_sre_el2, 0x2) }
		inline uint32_t disable(uint32_t icc_sre_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_sre_el2_val, 0x2) }
	}

	namespace sre
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_sre_el2, 0) }
		inline uint32_t is_enabled(uint32_t icc_sre_el2_val) noexcept { IS_BIT_ENABLED_FUNC(icc_sre_el2_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_sre_el2, 0) }
		inline uint32_t is_disabled(uint32_t icc_sre_el2_val) noexcept { IS_BIT_DISABLED_FUNC(icc_sre_el2_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_sre_el2, 0x1) }
		inline uint32_t enable(uint32_t icc_sre_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_sre_el2_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_sre_el2, 0x1) }
		inline uint32_t disable(uint32_t icc_sre_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_sre_el2_val, 0x1) }
	}
}

// ICC_SRE_EL3 (Interrupt Controller System Register Enable register (EL3))
// Controls whether the System register interface or the memory-mapped interface to the GIC CPU interface is used for EL3.
namespace icc_sre_el3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icc_sre_el3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icc_sre_el3, val) }

	namespace enable
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_sre_el3, 3) }
		inline uint32_t is_enabled(uint32_t icc_sre_el3_val) noexcept { IS_BIT_ENABLED_FUNC(icc_sre_el3_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_sre_el3, 3) }
		inline uint32_t is_disabled(uint32_t icc_sre_el3_val) noexcept { IS_BIT_DISABLED_FUNC(icc_sre_el3_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_sre_el3, 0x8) }
		inline uint32_t enable(uint32_t icc_sre_el3_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_sre_el3_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_sre_el3, 0x8) }
		inline uint32_t disable(uint32_t icc_sre_el3_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_sre_el3_val, 0x8) }
	}

	namespace dib
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_sre_el3, 2) }
		inline uint32_t is_enabled(uint32_t icc_sre_el3_val) noexcept { IS_BIT_ENABLED_FUNC(icc_sre_el3_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_sre_el3, 2) }
		inline uint32_t is_disabled(uint32_t icc_sre_el3_val) noexcept { IS_BIT_DISABLED_FUNC(icc_sre_el3_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_sre_el3, 0x4) }
		inline uint32_t enable(uint32_t icc_sre_el3_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_sre_el3_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_sre_el3, 0x4) }
		inline uint32_t disable(uint32_t icc_sre_el3_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_sre_el3_val, 0x4) }
	}

	namespace dfb
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_sre_el3, 1) }
		inline uint32_t is_enabled(uint32_t icc_sre_el3_val) noexcept { IS_BIT_ENABLED_FUNC(icc_sre_el3_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_sre_el3, 1) }
		inline uint32_t is_disabled(uint32_t icc_sre_el3_val) noexcept { IS_BIT_DISABLED_FUNC(icc_sre_el3_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_sre_el3, 0x2) }
		inline uint32_t enable(uint32_t icc_sre_el3_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_sre_el3_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_sre_el3, 0x2) }
		inline uint32_t disable(uint32_t icc_sre_el3_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_sre_el3_val, 0x2) }
	}

	namespace sre
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icc_sre_el3, 0) }
		inline uint32_t is_enabled(uint32_t icc_sre_el3_val) noexcept { IS_BIT_ENABLED_FUNC(icc_sre_el3_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icc_sre_el3, 0) }
		inline uint32_t is_disabled(uint32_t icc_sre_el3_val) noexcept { IS_BIT_DISABLED_FUNC(icc_sre_el3_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icc_sre_el3, 0x1) }
		inline uint32_t enable(uint32_t icc_sre_el3_val) noexcept { SET_BITS_BY_MASK_FUNC(icc_sre_el3_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icc_sre_el3, 0x1) }
		inline uint32_t disable(uint32_t icc_sre_el3_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icc_sre_el3_val, 0x1) }
	}
}

// ICH_AP0R<n>_EL2 (Interrupt Controller Hyp Active Priorities Group 0 Registers)
// Provides information about Group 0 virtual active priorities for EL2.
namespace ich_ap0r<n>_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ich_ap0r<n>_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ich_ap0r<n>_el2, val) }

	namespace p_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_ap0r<n>_el2, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ich_ap0r<n>_el2_val) noexcept { GET_BITFIELD_FUNC(ich_ap0r<n>_el2_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_ap0r<n>_el2, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ich_ap0r<n>_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_ap0r<n>_el2, value, 0xffffffff, 0) }
	}
}

// ICH_AP1R<n>_EL2 (Interrupt Controller Hyp Active Priorities Group 1 Registers)
// Provides information about Group 1 virtual active priorities for EL2.
namespace ich_ap1r<n>_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ich_ap1r<n>_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ich_ap1r<n>_el2, val) }

	namespace p_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_ap1r<n>_el2, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ich_ap1r<n>_el2_val) noexcept { GET_BITFIELD_FUNC(ich_ap1r<n>_el2_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_ap1r<n>_el2, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ich_ap1r<n>_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_ap1r<n>_el2, value, 0xffffffff, 0) }
	}
}

// ICH_EISR_EL2 (Interrupt Controller End of Interrupt Status Register)
// Indicates which List registers have outstanding EOI maintenance interrupts.
namespace ich_eisr_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ich_eisr_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ich_eisr_el2, val) }

	namespace status_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_eisr_el2, 0xffff, 0) }
		inline uint32_t get(uint32_t ich_eisr_el2_val) noexcept { GET_BITFIELD_FUNC(ich_eisr_el2_val, 0xffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_eisr_el2, value, 0xffff, 0) }
		inline uint32_t set(uint32_t ich_eisr_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_eisr_el2, value, 0xffff, 0) }
	}
}

// ICH_ELRSR_EL2 (Interrupt Controller Empty List Register Status Register)
// These registers can be used to locate a usable List register when the hypervisor is delivering an interrupt to a VM.
namespace ich_elrsr_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ich_elrsr_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ich_elrsr_el2, val) }

	namespace status_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_elrsr_el2, 0xffff, 0) }
		inline uint32_t get(uint32_t ich_elrsr_el2_val) noexcept { GET_BITFIELD_FUNC(ich_elrsr_el2_val, 0xffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_elrsr_el2, value, 0xffff, 0) }
		inline uint32_t set(uint32_t ich_elrsr_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_elrsr_el2, value, 0xffff, 0) }
	}
}

// ICH_HCR_EL2 (Interrupt Controller Hyp Control Register)
// Controls the environment for VMs.
namespace ich_hcr_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ich_hcr_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ich_hcr_el2, val) }

	namespace eoicount
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_hcr_el2, 0xf8000000, 27) }
		inline uint32_t get(uint32_t ich_hcr_el2_val) noexcept { GET_BITFIELD_FUNC(ich_hcr_el2_val, 0xf8000000, 27) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_hcr_el2, value, 0xf8000000, 27) }
		inline uint32_t set(uint32_t ich_hcr_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_hcr_el2, value, 0xf8000000, 27) }
	}

	namespace tdir
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr_el2, 14) }
		inline uint32_t is_enabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_el2_val, 14) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr_el2, 14) }
		inline uint32_t is_disabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_el2_val, 14) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x4000) }
		inline uint32_t enable(uint32_t ich_hcr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x4000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x4000) }
		inline uint32_t disable(uint32_t ich_hcr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x4000) }
	}

	namespace tsei
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr_el2, 13) }
		inline uint32_t is_enabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_el2_val, 13) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr_el2, 13) }
		inline uint32_t is_disabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_el2_val, 13) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x2000) }
		inline uint32_t enable(uint32_t ich_hcr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x2000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x2000) }
		inline uint32_t disable(uint32_t ich_hcr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x2000) }
	}

	namespace tall1
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr_el2, 12) }
		inline uint32_t is_enabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_el2_val, 12) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr_el2, 12) }
		inline uint32_t is_disabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_el2_val, 12) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x1000) }
		inline uint32_t enable(uint32_t ich_hcr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x1000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x1000) }
		inline uint32_t disable(uint32_t ich_hcr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x1000) }
	}

	namespace tall0
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr_el2, 11) }
		inline uint32_t is_enabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_el2_val, 11) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr_el2, 11) }
		inline uint32_t is_disabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_el2_val, 11) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x800) }
		inline uint32_t enable(uint32_t ich_hcr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x800) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x800) }
		inline uint32_t disable(uint32_t ich_hcr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x800) }
	}

	namespace tc
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr_el2, 10) }
		inline uint32_t is_enabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_el2_val, 10) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr_el2, 10) }
		inline uint32_t is_disabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_el2_val, 10) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x400) }
		inline uint32_t enable(uint32_t ich_hcr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x400) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x400) }
		inline uint32_t disable(uint32_t ich_hcr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x400) }
	}

	namespace vgrp1die
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr_el2, 7) }
		inline uint32_t is_enabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_el2_val, 7) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr_el2, 7) }
		inline uint32_t is_disabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_el2_val, 7) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x80) }
		inline uint32_t enable(uint32_t ich_hcr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x80) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x80) }
		inline uint32_t disable(uint32_t ich_hcr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x80) }
	}

	namespace vgrp1eie
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr_el2, 6) }
		inline uint32_t is_enabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_el2_val, 6) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr_el2, 6) }
		inline uint32_t is_disabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_el2_val, 6) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x40) }
		inline uint32_t enable(uint32_t ich_hcr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x40) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x40) }
		inline uint32_t disable(uint32_t ich_hcr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x40) }
	}

	namespace vgrp0die
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr_el2, 5) }
		inline uint32_t is_enabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_el2_val, 5) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr_el2, 5) }
		inline uint32_t is_disabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_el2_val, 5) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x20) }
		inline uint32_t enable(uint32_t ich_hcr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x20) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x20) }
		inline uint32_t disable(uint32_t ich_hcr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x20) }
	}

	namespace vgrp0eie
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr_el2, 4) }
		inline uint32_t is_enabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_el2_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr_el2, 4) }
		inline uint32_t is_disabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_el2_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x10) }
		inline uint32_t enable(uint32_t ich_hcr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x10) }
		inline uint32_t disable(uint32_t ich_hcr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x10) }
	}

	namespace npie
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr_el2, 3) }
		inline uint32_t is_enabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_el2_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr_el2, 3) }
		inline uint32_t is_disabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_el2_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x8) }
		inline uint32_t enable(uint32_t ich_hcr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x8) }
		inline uint32_t disable(uint32_t ich_hcr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x8) }
	}

	namespace lrenpie
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr_el2, 2) }
		inline uint32_t is_enabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_el2_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr_el2, 2) }
		inline uint32_t is_disabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_el2_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x4) }
		inline uint32_t enable(uint32_t ich_hcr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x4) }
		inline uint32_t disable(uint32_t ich_hcr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x4) }
	}

	namespace uie
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr_el2, 1) }
		inline uint32_t is_enabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_el2_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr_el2, 1) }
		inline uint32_t is_disabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_el2_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x2) }
		inline uint32_t enable(uint32_t ich_hcr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x2) }
		inline uint32_t disable(uint32_t ich_hcr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x2) }
	}

	namespace en
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_hcr_el2, 0) }
		inline uint32_t is_enabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_hcr_el2_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_hcr_el2, 0) }
		inline uint32_t is_disabled(uint32_t ich_hcr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_hcr_el2_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x1) }
		inline uint32_t enable(uint32_t ich_hcr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_hcr_el2, 0x1) }
		inline uint32_t disable(uint32_t ich_hcr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_hcr_el2_val, 0x1) }
	}
}

// ICH_LR<n>_EL2 (Interrupt Controller List Registers)
// Provides interrupt context information for the virtual CPU interface.
namespace ich_lr<n>_el2
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(ich_lr<n>_el2) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ich_lr<n>_el2, val) }

	namespace state
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_lr<n>_el2, 0xc000000000000000, 62) }
		inline uint64_t get(uint64_t ich_lr<n>_el2_val) noexcept { GET_BITFIELD_FUNC(ich_lr<n>_el2_val, 0xc000000000000000, 62) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_lr<n>_el2, value, 0xc000000000000000, 62) }
		inline uint64_t set(uint64_t ich_lr<n>_el2, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_lr<n>_el2, value, 0xc000000000000000, 62) }
	}

	namespace hw
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_lr<n>_el2, 61) }
		inline uint64_t is_enabled(uint64_t ich_lr<n>_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_lr<n>_el2_val, 61) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_lr<n>_el2, 61) }
		inline uint64_t is_disabled(uint64_t ich_lr<n>_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_lr<n>_el2_val, 61) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_lr<n>_el2, 0x2000000000000000) }
		inline uint64_t enable(uint64_t ich_lr<n>_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_lr<n>_el2_val, 0x2000000000000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_lr<n>_el2, 0x2000000000000000) }
		inline uint64_t disable(uint64_t ich_lr<n>_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_lr<n>_el2_val, 0x2000000000000000) }
	}

	namespace group
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_lr<n>_el2, 60) }
		inline uint64_t is_enabled(uint64_t ich_lr<n>_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_lr<n>_el2_val, 60) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_lr<n>_el2, 60) }
		inline uint64_t is_disabled(uint64_t ich_lr<n>_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_lr<n>_el2_val, 60) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_lr<n>_el2, 0x1000000000000000) }
		inline uint64_t enable(uint64_t ich_lr<n>_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_lr<n>_el2_val, 0x1000000000000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_lr<n>_el2, 0x1000000000000000) }
		inline uint64_t disable(uint64_t ich_lr<n>_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_lr<n>_el2_val, 0x1000000000000000) }
	}

	namespace priority
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_lr<n>_el2, 0xff000000000000, 48) }
		inline uint64_t get(uint64_t ich_lr<n>_el2_val) noexcept { GET_BITFIELD_FUNC(ich_lr<n>_el2_val, 0xff000000000000, 48) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_lr<n>_el2, value, 0xff000000000000, 48) }
		inline uint64_t set(uint64_t ich_lr<n>_el2, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_lr<n>_el2, value, 0xff000000000000, 48) }
	}

	namespace pintid
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_lr<n>_el2, 0x3ff00000000, 32) }
		inline uint64_t get(uint64_t ich_lr<n>_el2_val) noexcept { GET_BITFIELD_FUNC(ich_lr<n>_el2_val, 0x3ff00000000, 32) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_lr<n>_el2, value, 0x3ff00000000, 32) }
		inline uint64_t set(uint64_t ich_lr<n>_el2, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_lr<n>_el2, value, 0x3ff00000000, 32) }
	}

	namespace vintid
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_lr<n>_el2, 0xffffffff, 0) }
		inline uint64_t get(uint64_t ich_lr<n>_el2_val) noexcept { GET_BITFIELD_FUNC(ich_lr<n>_el2_val, 0xffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_lr<n>_el2, value, 0xffffffff, 0) }
		inline uint64_t set(uint64_t ich_lr<n>_el2, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_lr<n>_el2, value, 0xffffffff, 0) }
	}
}

// ICH_MISR_EL2 (Interrupt Controller Maintenance Interrupt State Register)
// Indicates which maintenance interrupts are asserted.
namespace ich_misr_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ich_misr_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ich_misr_el2, val) }

	namespace vgrp1d
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_misr_el2, 7) }
		inline uint32_t is_enabled(uint32_t ich_misr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_misr_el2_val, 7) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_misr_el2, 7) }
		inline uint32_t is_disabled(uint32_t ich_misr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_misr_el2_val, 7) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_misr_el2, 0x80) }
		inline uint32_t enable(uint32_t ich_misr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_misr_el2_val, 0x80) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_misr_el2, 0x80) }
		inline uint32_t disable(uint32_t ich_misr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_misr_el2_val, 0x80) }
	}

	namespace vgrp1e
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_misr_el2, 6) }
		inline uint32_t is_enabled(uint32_t ich_misr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_misr_el2_val, 6) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_misr_el2, 6) }
		inline uint32_t is_disabled(uint32_t ich_misr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_misr_el2_val, 6) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_misr_el2, 0x40) }
		inline uint32_t enable(uint32_t ich_misr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_misr_el2_val, 0x40) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_misr_el2, 0x40) }
		inline uint32_t disable(uint32_t ich_misr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_misr_el2_val, 0x40) }
	}

	namespace vgrp0d
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_misr_el2, 5) }
		inline uint32_t is_enabled(uint32_t ich_misr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_misr_el2_val, 5) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_misr_el2, 5) }
		inline uint32_t is_disabled(uint32_t ich_misr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_misr_el2_val, 5) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_misr_el2, 0x20) }
		inline uint32_t enable(uint32_t ich_misr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_misr_el2_val, 0x20) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_misr_el2, 0x20) }
		inline uint32_t disable(uint32_t ich_misr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_misr_el2_val, 0x20) }
	}

	namespace vgrp0e
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_misr_el2, 4) }
		inline uint32_t is_enabled(uint32_t ich_misr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_misr_el2_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_misr_el2, 4) }
		inline uint32_t is_disabled(uint32_t ich_misr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_misr_el2_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_misr_el2, 0x10) }
		inline uint32_t enable(uint32_t ich_misr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_misr_el2_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_misr_el2, 0x10) }
		inline uint32_t disable(uint32_t ich_misr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_misr_el2_val, 0x10) }
	}

	namespace np
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_misr_el2, 3) }
		inline uint32_t is_enabled(uint32_t ich_misr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_misr_el2_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_misr_el2, 3) }
		inline uint32_t is_disabled(uint32_t ich_misr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_misr_el2_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_misr_el2, 0x8) }
		inline uint32_t enable(uint32_t ich_misr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_misr_el2_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_misr_el2, 0x8) }
		inline uint32_t disable(uint32_t ich_misr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_misr_el2_val, 0x8) }
	}

	namespace lrenp
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_misr_el2, 2) }
		inline uint32_t is_enabled(uint32_t ich_misr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_misr_el2_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_misr_el2, 2) }
		inline uint32_t is_disabled(uint32_t ich_misr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_misr_el2_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_misr_el2, 0x4) }
		inline uint32_t enable(uint32_t ich_misr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_misr_el2_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_misr_el2, 0x4) }
		inline uint32_t disable(uint32_t ich_misr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_misr_el2_val, 0x4) }
	}

	namespace u
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_misr_el2, 1) }
		inline uint32_t is_enabled(uint32_t ich_misr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_misr_el2_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_misr_el2, 1) }
		inline uint32_t is_disabled(uint32_t ich_misr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_misr_el2_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_misr_el2, 0x2) }
		inline uint32_t enable(uint32_t ich_misr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_misr_el2_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_misr_el2, 0x2) }
		inline uint32_t disable(uint32_t ich_misr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_misr_el2_val, 0x2) }
	}

	namespace eoi
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_misr_el2, 0) }
		inline uint32_t is_enabled(uint32_t ich_misr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_misr_el2_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_misr_el2, 0) }
		inline uint32_t is_disabled(uint32_t ich_misr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_misr_el2_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_misr_el2, 0x1) }
		inline uint32_t enable(uint32_t ich_misr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_misr_el2_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_misr_el2, 0x1) }
		inline uint32_t disable(uint32_t ich_misr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_misr_el2_val, 0x1) }
	}
}

// ICH_VMCR_EL2 (Interrupt Controller Virtual Machine Control Register)
// Enables the hypervisor to save and restore the virtual machine view of the GIC state.
namespace ich_vmcr_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ich_vmcr_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ich_vmcr_el2, val) }

	namespace vpmr
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_vmcr_el2, 0xff000000, 24) }
		inline uint32_t get(uint32_t ich_vmcr_el2_val) noexcept { GET_BITFIELD_FUNC(ich_vmcr_el2_val, 0xff000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_vmcr_el2, value, 0xff000000, 24) }
		inline uint32_t set(uint32_t ich_vmcr_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_vmcr_el2, value, 0xff000000, 24) }
	}

	namespace vbpr0
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_vmcr_el2, 0xe00000, 21) }
		inline uint32_t get(uint32_t ich_vmcr_el2_val) noexcept { GET_BITFIELD_FUNC(ich_vmcr_el2_val, 0xe00000, 21) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_vmcr_el2, value, 0xe00000, 21) }
		inline uint32_t set(uint32_t ich_vmcr_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_vmcr_el2, value, 0xe00000, 21) }
	}

	namespace vbpr1
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_vmcr_el2, 0x1c0000, 18) }
		inline uint32_t get(uint32_t ich_vmcr_el2_val) noexcept { GET_BITFIELD_FUNC(ich_vmcr_el2_val, 0x1c0000, 18) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_vmcr_el2, value, 0x1c0000, 18) }
		inline uint32_t set(uint32_t ich_vmcr_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_vmcr_el2, value, 0x1c0000, 18) }
	}

	namespace veoim
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_vmcr_el2, 9) }
		inline uint32_t is_enabled(uint32_t ich_vmcr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_vmcr_el2_val, 9) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_vmcr_el2, 9) }
		inline uint32_t is_disabled(uint32_t ich_vmcr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_vmcr_el2_val, 9) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_vmcr_el2, 0x200) }
		inline uint32_t enable(uint32_t ich_vmcr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_vmcr_el2_val, 0x200) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_vmcr_el2, 0x200) }
		inline uint32_t disable(uint32_t ich_vmcr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_vmcr_el2_val, 0x200) }
	}

	namespace vcbpr
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_vmcr_el2, 4) }
		inline uint32_t is_enabled(uint32_t ich_vmcr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_vmcr_el2_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_vmcr_el2, 4) }
		inline uint32_t is_disabled(uint32_t ich_vmcr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_vmcr_el2_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_vmcr_el2, 0x10) }
		inline uint32_t enable(uint32_t ich_vmcr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_vmcr_el2_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_vmcr_el2, 0x10) }
		inline uint32_t disable(uint32_t ich_vmcr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_vmcr_el2_val, 0x10) }
	}

	namespace vfiqen
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_vmcr_el2, 3) }
		inline uint32_t is_enabled(uint32_t ich_vmcr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_vmcr_el2_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_vmcr_el2, 3) }
		inline uint32_t is_disabled(uint32_t ich_vmcr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_vmcr_el2_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_vmcr_el2, 0x8) }
		inline uint32_t enable(uint32_t ich_vmcr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_vmcr_el2_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_vmcr_el2, 0x8) }
		inline uint32_t disable(uint32_t ich_vmcr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_vmcr_el2_val, 0x8) }
	}

	namespace vackctl
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_vmcr_el2, 2) }
		inline uint32_t is_enabled(uint32_t ich_vmcr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_vmcr_el2_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_vmcr_el2, 2) }
		inline uint32_t is_disabled(uint32_t ich_vmcr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_vmcr_el2_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_vmcr_el2, 0x4) }
		inline uint32_t enable(uint32_t ich_vmcr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_vmcr_el2_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_vmcr_el2, 0x4) }
		inline uint32_t disable(uint32_t ich_vmcr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_vmcr_el2_val, 0x4) }
	}

	namespace veng1
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_vmcr_el2, 1) }
		inline uint32_t is_enabled(uint32_t ich_vmcr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_vmcr_el2_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_vmcr_el2, 1) }
		inline uint32_t is_disabled(uint32_t ich_vmcr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_vmcr_el2_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_vmcr_el2, 0x2) }
		inline uint32_t enable(uint32_t ich_vmcr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_vmcr_el2_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_vmcr_el2, 0x2) }
		inline uint32_t disable(uint32_t ich_vmcr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_vmcr_el2_val, 0x2) }
	}

	namespace veng0
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_vmcr_el2, 0) }
		inline uint32_t is_enabled(uint32_t ich_vmcr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_vmcr_el2_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_vmcr_el2, 0) }
		inline uint32_t is_disabled(uint32_t ich_vmcr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_vmcr_el2_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_vmcr_el2, 0x1) }
		inline uint32_t enable(uint32_t ich_vmcr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_vmcr_el2_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_vmcr_el2, 0x1) }
		inline uint32_t disable(uint32_t ich_vmcr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_vmcr_el2_val, 0x1) }
	}
}

// ICH_VTR_EL2 (Interrupt Controller VGIC Type Register)
// Reports supported GIC virtualisartion features.
namespace ich_vtr_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ich_vtr_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ich_vtr_el2, val) }

	namespace pribits
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_vtr_el2, 0xe0000000, 29) }
		inline uint32_t get(uint32_t ich_vtr_el2_val) noexcept { GET_BITFIELD_FUNC(ich_vtr_el2_val, 0xe0000000, 29) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_vtr_el2, value, 0xe0000000, 29) }
		inline uint32_t set(uint32_t ich_vtr_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_vtr_el2, value, 0xe0000000, 29) }
	}

	namespace prebits
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_vtr_el2, 0x1c000000, 26) }
		inline uint32_t get(uint32_t ich_vtr_el2_val) noexcept { GET_BITFIELD_FUNC(ich_vtr_el2_val, 0x1c000000, 26) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_vtr_el2, value, 0x1c000000, 26) }
		inline uint32_t set(uint32_t ich_vtr_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_vtr_el2, value, 0x1c000000, 26) }
	}

	namespace idbits
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_vtr_el2, 0x3800000, 23) }
		inline uint32_t get(uint32_t ich_vtr_el2_val) noexcept { GET_BITFIELD_FUNC(ich_vtr_el2_val, 0x3800000, 23) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_vtr_el2, value, 0x3800000, 23) }
		inline uint32_t set(uint32_t ich_vtr_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_vtr_el2, value, 0x3800000, 23) }
	}

	namespace seis
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_vtr_el2, 22) }
		inline uint32_t is_enabled(uint32_t ich_vtr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_vtr_el2_val, 22) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_vtr_el2, 22) }
		inline uint32_t is_disabled(uint32_t ich_vtr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_vtr_el2_val, 22) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_vtr_el2, 0x400000) }
		inline uint32_t enable(uint32_t ich_vtr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_vtr_el2_val, 0x400000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_vtr_el2, 0x400000) }
		inline uint32_t disable(uint32_t ich_vtr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_vtr_el2_val, 0x400000) }
	}

	namespace a3v
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_vtr_el2, 21) }
		inline uint32_t is_enabled(uint32_t ich_vtr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_vtr_el2_val, 21) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_vtr_el2, 21) }
		inline uint32_t is_disabled(uint32_t ich_vtr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_vtr_el2_val, 21) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_vtr_el2, 0x200000) }
		inline uint32_t enable(uint32_t ich_vtr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_vtr_el2_val, 0x200000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_vtr_el2, 0x200000) }
		inline uint32_t disable(uint32_t ich_vtr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_vtr_el2_val, 0x200000) }
	}

	namespace nv4
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_vtr_el2, 20) }
		inline uint32_t is_enabled(uint32_t ich_vtr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_vtr_el2_val, 20) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_vtr_el2, 20) }
		inline uint32_t is_disabled(uint32_t ich_vtr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_vtr_el2_val, 20) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_vtr_el2, 0x100000) }
		inline uint32_t enable(uint32_t ich_vtr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_vtr_el2_val, 0x100000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_vtr_el2, 0x100000) }
		inline uint32_t disable(uint32_t ich_vtr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_vtr_el2_val, 0x100000) }
	}

	namespace tds
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ich_vtr_el2, 19) }
		inline uint32_t is_enabled(uint32_t ich_vtr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ich_vtr_el2_val, 19) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ich_vtr_el2, 19) }
		inline uint32_t is_disabled(uint32_t ich_vtr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ich_vtr_el2_val, 19) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ich_vtr_el2, 0x80000) }
		inline uint32_t enable(uint32_t ich_vtr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ich_vtr_el2_val, 0x80000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ich_vtr_el2, 0x80000) }
		inline uint32_t disable(uint32_t ich_vtr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ich_vtr_el2_val, 0x80000) }
	}

	namespace listregs
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ich_vtr_el2, 0x1f, 0) }
		inline uint32_t get(uint32_t ich_vtr_el2_val) noexcept { GET_BITFIELD_FUNC(ich_vtr_el2_val, 0x1f, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ich_vtr_el2, value, 0x1f, 0) }
		inline uint32_t set(uint32_t ich_vtr_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ich_vtr_el2, value, 0x1f, 0) }
	}
}

// ICV_AP0R<n>_EL1 (Interrupt Controller Virtual Active Priorities Group 0 Registers)
// Provides information about virtual Group 0 active priorities.
namespace icv_ap0r<n>_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_ap0r<n>_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_ap0r<n>_el1, val) }
}

// ICV_AP1R<n>_EL1 (Interrupt Controller Virtual Active Priorities Group 1 Registers)
// Provides information about virtual Group 1 active priorities.
namespace icv_ap1r<n>_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_ap1r<n>_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_ap1r<n>_el1, val) }
}

// ICV_BPR0_EL1 (Interrupt Controller Virtual Binary Point Register 0)
// Defines the point at which the priority value fields split into two parts, the group priority field and the subpriority field. The group priority field determines virtual Group 0 interrupt preemption.
namespace icv_bpr0_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_bpr0_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_bpr0_el1, val) }

	namespace binarypoint
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_bpr0_el1, 0x7, 0) }
		inline uint32_t get(uint32_t icv_bpr0_el1_val) noexcept { GET_BITFIELD_FUNC(icv_bpr0_el1_val, 0x7, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_bpr0_el1, value, 0x7, 0) }
		inline uint32_t set(uint32_t icv_bpr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_bpr0_el1, value, 0x7, 0) }
	}
}

// ICV_BPR1_EL1 (Interrupt Controller Virtual Binary Point Register 1)
// Defines the point at which the priority value fields split into two parts, the group priority field and the subpriority field. The group priority field determines virtual Group 1 interrupt preemption.
namespace icv_bpr1_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_bpr1_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_bpr1_el1, val) }

	namespace binarypoint
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_bpr1_el1, 0x7, 0) }
		inline uint32_t get(uint32_t icv_bpr1_el1_val) noexcept { GET_BITFIELD_FUNC(icv_bpr1_el1_val, 0x7, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_bpr1_el1, value, 0x7, 0) }
		inline uint32_t set(uint32_t icv_bpr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_bpr1_el1, value, 0x7, 0) }
	}
}

// ICV_CTLR_EL1 (Interrupt Controller Virtual Control Register)
// Controls aspects of the behavior of the GIC virtual CPU interface and provides information about the features implemented.
namespace icv_ctlr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_ctlr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_ctlr_el1, val) }

	namespace rss
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icv_ctlr_el1, 18) }
		inline uint32_t is_enabled(uint32_t icv_ctlr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(icv_ctlr_el1_val, 18) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icv_ctlr_el1, 18) }
		inline uint32_t is_disabled(uint32_t icv_ctlr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(icv_ctlr_el1_val, 18) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icv_ctlr_el1, 0x40000) }
		inline uint32_t enable(uint32_t icv_ctlr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(icv_ctlr_el1_val, 0x40000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icv_ctlr_el1, 0x40000) }
		inline uint32_t disable(uint32_t icv_ctlr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icv_ctlr_el1_val, 0x40000) }
	}

	namespace a3v
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icv_ctlr_el1, 15) }
		inline uint32_t is_enabled(uint32_t icv_ctlr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(icv_ctlr_el1_val, 15) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icv_ctlr_el1, 15) }
		inline uint32_t is_disabled(uint32_t icv_ctlr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(icv_ctlr_el1_val, 15) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icv_ctlr_el1, 0x8000) }
		inline uint32_t enable(uint32_t icv_ctlr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(icv_ctlr_el1_val, 0x8000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icv_ctlr_el1, 0x8000) }
		inline uint32_t disable(uint32_t icv_ctlr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icv_ctlr_el1_val, 0x8000) }
	}

	namespace seis
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icv_ctlr_el1, 14) }
		inline uint32_t is_enabled(uint32_t icv_ctlr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(icv_ctlr_el1_val, 14) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icv_ctlr_el1, 14) }
		inline uint32_t is_disabled(uint32_t icv_ctlr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(icv_ctlr_el1_val, 14) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icv_ctlr_el1, 0x4000) }
		inline uint32_t enable(uint32_t icv_ctlr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(icv_ctlr_el1_val, 0x4000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icv_ctlr_el1, 0x4000) }
		inline uint32_t disable(uint32_t icv_ctlr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icv_ctlr_el1_val, 0x4000) }
	}

	namespace idbits
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_ctlr_el1, 0x3800, 11) }
		inline uint32_t get(uint32_t icv_ctlr_el1_val) noexcept { GET_BITFIELD_FUNC(icv_ctlr_el1_val, 0x3800, 11) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_ctlr_el1, value, 0x3800, 11) }
		inline uint32_t set(uint32_t icv_ctlr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_ctlr_el1, value, 0x3800, 11) }
	}

	namespace pribits
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_ctlr_el1, 0x700, 8) }
		inline uint32_t get(uint32_t icv_ctlr_el1_val) noexcept { GET_BITFIELD_FUNC(icv_ctlr_el1_val, 0x700, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_ctlr_el1, value, 0x700, 8) }
		inline uint32_t set(uint32_t icv_ctlr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_ctlr_el1, value, 0x700, 8) }
	}

	namespace eoimode
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icv_ctlr_el1, 1) }
		inline uint32_t is_enabled(uint32_t icv_ctlr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(icv_ctlr_el1_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icv_ctlr_el1, 1) }
		inline uint32_t is_disabled(uint32_t icv_ctlr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(icv_ctlr_el1_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icv_ctlr_el1, 0x2) }
		inline uint32_t enable(uint32_t icv_ctlr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(icv_ctlr_el1_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icv_ctlr_el1, 0x2) }
		inline uint32_t disable(uint32_t icv_ctlr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icv_ctlr_el1_val, 0x2) }
	}

	namespace cbpr
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icv_ctlr_el1, 0) }
		inline uint32_t is_enabled(uint32_t icv_ctlr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(icv_ctlr_el1_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icv_ctlr_el1, 0) }
		inline uint32_t is_disabled(uint32_t icv_ctlr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(icv_ctlr_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icv_ctlr_el1, 0x1) }
		inline uint32_t enable(uint32_t icv_ctlr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(icv_ctlr_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icv_ctlr_el1, 0x1) }
		inline uint32_t disable(uint32_t icv_ctlr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icv_ctlr_el1_val, 0x1) }
	}
}

// ICV_DIR_EL1 (Interrupt Controller Deactivate Virtual Interrupt Register)
// When interrupt priority drop is separated from interrupt deactivation, a write to this register deactivates the specified virtual interrupt.
namespace icv_dir_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_dir_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_dir_el1, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_dir_el1, 0xffffff, 0) }
		inline uint32_t get(uint32_t icv_dir_el1_val) noexcept { GET_BITFIELD_FUNC(icv_dir_el1_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_dir_el1, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icv_dir_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_dir_el1, value, 0xffffff, 0) }
	}
}

// ICV_EOIR0_EL1 (Interrupt Controller Virtual End Of Interrupt Register 0)
// A PE writes to this register to inform the CPU interface that it has completed the processing of the specified virtual Group 0 interrupt.
namespace icv_eoir0_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_eoir0_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_eoir0_el1, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_eoir0_el1, 0xffffff, 0) }
		inline uint32_t get(uint32_t icv_eoir0_el1_val) noexcept { GET_BITFIELD_FUNC(icv_eoir0_el1_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_eoir0_el1, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icv_eoir0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_eoir0_el1, value, 0xffffff, 0) }
	}
}

// ICV_EOIR1_EL1 (Interrupt Controller Virtual End Of Interrupt Register 1)
// A PE writes to this register to inform the CPU interface that it has completed the processing of the specified virtual Group 1 interrupt.
namespace icv_eoir1_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_eoir1_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_eoir1_el1, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_eoir1_el1, 0xffffff, 0) }
		inline uint32_t get(uint32_t icv_eoir1_el1_val) noexcept { GET_BITFIELD_FUNC(icv_eoir1_el1_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_eoir1_el1, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icv_eoir1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_eoir1_el1, value, 0xffffff, 0) }
	}
}

// ICV_HPPIR0_EL1 (Interrupt Controller Virtual Highest Priority Pending Interrupt Register 0)
// Indicates the highest priority pending virtual Group 0 interrupt on the virtual CPU interface.
namespace icv_hppir0_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_hppir0_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_hppir0_el1, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_hppir0_el1, 0xffffff, 0) }
		inline uint32_t get(uint32_t icv_hppir0_el1_val) noexcept { GET_BITFIELD_FUNC(icv_hppir0_el1_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_hppir0_el1, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icv_hppir0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_hppir0_el1, value, 0xffffff, 0) }
	}
}

// ICV_HPPIR1_EL1 (Interrupt Controller Virtual Highest Priority Pending Interrupt Register 1)
// Indicates the highest priority pending virtual Group 1 interrupt on the virtual CPU interface.
namespace icv_hppir1_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_hppir1_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_hppir1_el1, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_hppir1_el1, 0xffffff, 0) }
		inline uint32_t get(uint32_t icv_hppir1_el1_val) noexcept { GET_BITFIELD_FUNC(icv_hppir1_el1_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_hppir1_el1, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icv_hppir1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_hppir1_el1, value, 0xffffff, 0) }
	}
}

// ICV_IAR0_EL1 (Interrupt Controller Virtual Interrupt Acknowledge Register 0)
// The PE reads this register to obtain the INTID of the signaled virtual Group 0 interrupt. This read acts as an acknowledge for the interrupt.
namespace icv_iar0_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_iar0_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_iar0_el1, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_iar0_el1, 0xffffff, 0) }
		inline uint32_t get(uint32_t icv_iar0_el1_val) noexcept { GET_BITFIELD_FUNC(icv_iar0_el1_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_iar0_el1, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icv_iar0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_iar0_el1, value, 0xffffff, 0) }
	}
}

// ICV_IAR1_EL1 (Interrupt Controller Virtual Interrupt Acknowledge Register 1)
// The PE reads this register to obtain the INTID of the signaled virtual Group 1 interrupt. This read acts as an acknowledge for the interrupt.
namespace icv_iar1_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_iar1_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_iar1_el1, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_iar1_el1, 0xffffff, 0) }
		inline uint32_t get(uint32_t icv_iar1_el1_val) noexcept { GET_BITFIELD_FUNC(icv_iar1_el1_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_iar1_el1, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t icv_iar1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_iar1_el1, value, 0xffffff, 0) }
	}
}

// ICV_IGRPEN0_EL1 (Interrupt Controller Virtual Interrupt Group 0 Enable register)
// Controls whether virtual Group 0 interrupts are enabled or not.
namespace icv_igrpen0_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_igrpen0_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_igrpen0_el1, val) }

	namespace enable
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icv_igrpen0_el1, 0) }
		inline uint32_t is_enabled(uint32_t icv_igrpen0_el1_val) noexcept { IS_BIT_ENABLED_FUNC(icv_igrpen0_el1_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icv_igrpen0_el1, 0) }
		inline uint32_t is_disabled(uint32_t icv_igrpen0_el1_val) noexcept { IS_BIT_DISABLED_FUNC(icv_igrpen0_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icv_igrpen0_el1, 0x1) }
		inline uint32_t enable(uint32_t icv_igrpen0_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(icv_igrpen0_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icv_igrpen0_el1, 0x1) }
		inline uint32_t disable(uint32_t icv_igrpen0_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icv_igrpen0_el1_val, 0x1) }
	}
}

// ICV_IGRPEN1_EL1 (Interrupt Controller Virtual Interrupt Group 1 Enable register)
// Controls whether virtual Group 1 interrupts are enabled for the current Security state.
namespace icv_igrpen1_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_igrpen1_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_igrpen1_el1, val) }

	namespace enable
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(icv_igrpen1_el1, 0) }
		inline uint32_t is_enabled(uint32_t icv_igrpen1_el1_val) noexcept { IS_BIT_ENABLED_FUNC(icv_igrpen1_el1_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(icv_igrpen1_el1, 0) }
		inline uint32_t is_disabled(uint32_t icv_igrpen1_el1_val) noexcept { IS_BIT_DISABLED_FUNC(icv_igrpen1_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(icv_igrpen1_el1, 0x1) }
		inline uint32_t enable(uint32_t icv_igrpen1_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(icv_igrpen1_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(icv_igrpen1_el1, 0x1) }
		inline uint32_t disable(uint32_t icv_igrpen1_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(icv_igrpen1_el1_val, 0x1) }
	}
}

// ICV_PMR_EL1 (Interrupt Controller Virtual Interrupt Priority Mask Register)
// Provides a virtual interrupt priority filter. Only virtual interrupts with a higher priority than the value in this register are signaled to the PE.
namespace icv_pmr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_pmr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_pmr_el1, val) }

	namespace priority
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_pmr_el1, 0xff, 0) }
		inline uint32_t get(uint32_t icv_pmr_el1_val) noexcept { GET_BITFIELD_FUNC(icv_pmr_el1_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_pmr_el1, value, 0xff, 0) }
		inline uint32_t set(uint32_t icv_pmr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_pmr_el1, value, 0xff, 0) }
	}
}

// ICV_RPR_EL1 (Interrupt Controller Virtual Running Priority Register)
// Indicates the Running priority of the virtual CPU interface.
namespace icv_rpr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(icv_rpr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(icv_rpr_el1, val) }

	namespace priority
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(icv_rpr_el1, 0xff, 0) }
		inline uint32_t get(uint32_t icv_rpr_el1_val) noexcept { GET_BITFIELD_FUNC(icv_rpr_el1_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(icv_rpr_el1, value, 0xff, 0) }
		inline uint32_t set(uint32_t icv_rpr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(icv_rpr_el1, value, 0xff, 0) }
	}
}

// ID_AA64AFR0_EL1 (AArch64 Auxiliary Feature Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_aa64afr0_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(id_aa64afr0_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_aa64afr0_el1, val) }
}

// ID_AA64AFR1_EL1 (AArch64 Auxiliary Feature Register 1)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_aa64afr1_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(id_aa64afr1_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_aa64afr1_el1, val) }
}

// ID_AA64DFR0_EL1 (AArch64 Debug Feature Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_aa64dfr0_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(id_aa64dfr0_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_aa64dfr0_el1, val) }
}

// ID_AA64DFR1_EL1 (AArch64 Debug Feature Register 1)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_aa64dfr1_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(id_aa64dfr1_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_aa64dfr1_el1, val) }
}

// ID_AA64ISAR0_EL1 (AArch64 Instruction Set Attribute Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_aa64isar0_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(id_aa64isar0_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_aa64isar0_el1, val) }
}

// ID_AA64ISAR1_EL1 (AArch64 Instruction Set Attribute Register 1)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_aa64isar1_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(id_aa64isar1_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_aa64isar1_el1, val) }
}

// ID_AA64MMFR0_EL1 (AArch64 Memory Model Feature Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_aa64mmfr0_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(id_aa64mmfr0_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_aa64mmfr0_el1, val) }

	namespace tgran4
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_aa64mmfr0_el1, 0xf0000000, 28) }
		inline uint64_t get(uint64_t id_aa64mmfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_aa64mmfr0_el1_val, 0xf0000000, 28) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_aa64mmfr0_el1, value, 0xf0000000, 28) }
		inline uint64_t set(uint64_t id_aa64mmfr0_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_aa64mmfr0_el1, value, 0xf0000000, 28) }
	}

	namespace tgran64
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_aa64mmfr0_el1, 0xf000000, 24) }
		inline uint64_t get(uint64_t id_aa64mmfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_aa64mmfr0_el1_val, 0xf000000, 24) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_aa64mmfr0_el1, value, 0xf000000, 24) }
		inline uint64_t set(uint64_t id_aa64mmfr0_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_aa64mmfr0_el1, value, 0xf000000, 24) }
	}

	namespace tgran16
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_aa64mmfr0_el1, 0xf00000, 20) }
		inline uint64_t get(uint64_t id_aa64mmfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_aa64mmfr0_el1_val, 0xf00000, 20) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_aa64mmfr0_el1, value, 0xf00000, 20) }
		inline uint64_t set(uint64_t id_aa64mmfr0_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_aa64mmfr0_el1, value, 0xf00000, 20) }
	}

	namespace bigendel0
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_aa64mmfr0_el1, 0xf0000, 16) }
		inline uint64_t get(uint64_t id_aa64mmfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_aa64mmfr0_el1_val, 0xf0000, 16) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_aa64mmfr0_el1, value, 0xf0000, 16) }
		inline uint64_t set(uint64_t id_aa64mmfr0_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_aa64mmfr0_el1, value, 0xf0000, 16) }
	}

	namespace snsmem
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_aa64mmfr0_el1, 0xf000, 12) }
		inline uint64_t get(uint64_t id_aa64mmfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_aa64mmfr0_el1_val, 0xf000, 12) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_aa64mmfr0_el1, value, 0xf000, 12) }
		inline uint64_t set(uint64_t id_aa64mmfr0_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_aa64mmfr0_el1, value, 0xf000, 12) }
	}

	namespace bigend
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_aa64mmfr0_el1, 0xf00, 8) }
		inline uint64_t get(uint64_t id_aa64mmfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_aa64mmfr0_el1_val, 0xf00, 8) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_aa64mmfr0_el1, value, 0xf00, 8) }
		inline uint64_t set(uint64_t id_aa64mmfr0_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_aa64mmfr0_el1, value, 0xf00, 8) }
	}

	namespace asidbits
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_aa64mmfr0_el1, 0xf0, 4) }
		inline uint64_t get(uint64_t id_aa64mmfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_aa64mmfr0_el1_val, 0xf0, 4) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_aa64mmfr0_el1, value, 0xf0, 4) }
		inline uint64_t set(uint64_t id_aa64mmfr0_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_aa64mmfr0_el1, value, 0xf0, 4) }
	}

	namespace parange
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_aa64mmfr0_el1, 0xf, 0) }
		inline uint64_t get(uint64_t id_aa64mmfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_aa64mmfr0_el1_val, 0xf, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_aa64mmfr0_el1, value, 0xf, 0) }
		inline uint64_t set(uint64_t id_aa64mmfr0_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_aa64mmfr0_el1, value, 0xf, 0) }
	}
}

// ID_AA64MMFR1_EL1 (AArch64 Memory Model Feature Register 1)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_aa64mmfr1_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(id_aa64mmfr1_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_aa64mmfr1_el1, val) }
}

// ID_AA64MMFR2_EL1 (AArch64 Memory Model Feature Register 2)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_aa64mmfr2_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(id_aa64mmfr2_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_aa64mmfr2_el1, val) }
}

// ID_AA64PFR0_EL1 (AArch64 Processor Feature Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_aa64pfr0_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(id_aa64pfr0_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_aa64pfr0_el1, val) }
}

// ID_AA64PFR1_EL1 (AArch64 Processor Feature Register 1)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_aa64pfr1_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(id_aa64pfr1_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_aa64pfr1_el1, val) }
}

// ID_AFR0_EL1 (AArch32 Auxiliary Feature Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_afr0_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_afr0_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_afr0_el1, val) }
}

// ID_DFR0_EL1 (AArch32 Debug Feature Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_dfr0_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_dfr0_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_dfr0_el1, val) }

	namespace perfmon
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_dfr0_el1, 0xf000000, 24) }
		inline uint32_t get(uint32_t id_dfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_dfr0_el1_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_dfr0_el1, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t id_dfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_dfr0_el1, value, 0xf000000, 24) }
	}

	namespace mprofdbg
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_dfr0_el1, 0xf00000, 20) }
		inline uint32_t get(uint32_t id_dfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_dfr0_el1_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_dfr0_el1, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t id_dfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_dfr0_el1, value, 0xf00000, 20) }
	}

	namespace mmaptrc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_dfr0_el1, 0xf0000, 16) }
		inline uint32_t get(uint32_t id_dfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_dfr0_el1_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_dfr0_el1, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t id_dfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_dfr0_el1, value, 0xf0000, 16) }
	}

	namespace coptrc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_dfr0_el1, 0xf000, 12) }
		inline uint32_t get(uint32_t id_dfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_dfr0_el1_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_dfr0_el1, value, 0xf000, 12) }
		inline uint32_t set(uint32_t id_dfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_dfr0_el1, value, 0xf000, 12) }
	}

	namespace mmapdbg
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_dfr0_el1, 0xf00, 8) }
		inline uint32_t get(uint32_t id_dfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_dfr0_el1_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_dfr0_el1, value, 0xf00, 8) }
		inline uint32_t set(uint32_t id_dfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_dfr0_el1, value, 0xf00, 8) }
	}

	namespace copsdbg
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_dfr0_el1, 0xf0, 4) }
		inline uint32_t get(uint32_t id_dfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_dfr0_el1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_dfr0_el1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t id_dfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_dfr0_el1, value, 0xf0, 4) }
	}

	namespace copdbg
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_dfr0_el1, 0xf, 0) }
		inline uint32_t get(uint32_t id_dfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_dfr0_el1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_dfr0_el1, value, 0xf, 0) }
		inline uint32_t set(uint32_t id_dfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_dfr0_el1, value, 0xf, 0) }
	}
}

// ID_ISAR0_EL1 (AArch32 Instruction Set Attribute Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_isar0_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_isar0_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_isar0_el1, val) }

	namespace divide
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar0_el1, 0xf000000, 24) }
		inline uint32_t get(uint32_t id_isar0_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar0_el1_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar0_el1, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t id_isar0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar0_el1, value, 0xf000000, 24) }
	}

	namespace debug
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar0_el1, 0xf00000, 20) }
		inline uint32_t get(uint32_t id_isar0_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar0_el1_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar0_el1, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t id_isar0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar0_el1, value, 0xf00000, 20) }
	}

	namespace coproc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar0_el1, 0xf0000, 16) }
		inline uint32_t get(uint32_t id_isar0_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar0_el1_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar0_el1, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t id_isar0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar0_el1, value, 0xf0000, 16) }
	}

	namespace cmpbranch
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar0_el1, 0xf000, 12) }
		inline uint32_t get(uint32_t id_isar0_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar0_el1_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar0_el1, value, 0xf000, 12) }
		inline uint32_t set(uint32_t id_isar0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar0_el1, value, 0xf000, 12) }
	}

	namespace bitfield
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar0_el1, 0xf00, 8) }
		inline uint32_t get(uint32_t id_isar0_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar0_el1_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar0_el1, value, 0xf00, 8) }
		inline uint32_t set(uint32_t id_isar0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar0_el1, value, 0xf00, 8) }
	}

	namespace bitcount
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar0_el1, 0xf0, 4) }
		inline uint32_t get(uint32_t id_isar0_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar0_el1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar0_el1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t id_isar0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar0_el1, value, 0xf0, 4) }
	}

	namespace swap
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar0_el1, 0xf, 0) }
		inline uint32_t get(uint32_t id_isar0_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar0_el1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar0_el1, value, 0xf, 0) }
		inline uint32_t set(uint32_t id_isar0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar0_el1, value, 0xf, 0) }
	}
}

// ID_ISAR1_EL1 (AArch32 Instruction Set Attribute Register 1)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_isar1_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_isar1_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_isar1_el1, val) }

	namespace jazelle
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar1_el1, 0xf0000000, 28) }
		inline uint32_t get(uint32_t id_isar1_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar1_el1_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar1_el1, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t id_isar1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar1_el1, value, 0xf0000000, 28) }
	}

	namespace interwork
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar1_el1, 0xf000000, 24) }
		inline uint32_t get(uint32_t id_isar1_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar1_el1_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar1_el1, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t id_isar1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar1_el1, value, 0xf000000, 24) }
	}

	namespace immediate
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar1_el1, 0xf00000, 20) }
		inline uint32_t get(uint32_t id_isar1_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar1_el1_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar1_el1, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t id_isar1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar1_el1, value, 0xf00000, 20) }
	}

	namespace ifthen
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar1_el1, 0xf0000, 16) }
		inline uint32_t get(uint32_t id_isar1_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar1_el1_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar1_el1, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t id_isar1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar1_el1, value, 0xf0000, 16) }
	}

	namespace extend
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar1_el1, 0xf000, 12) }
		inline uint32_t get(uint32_t id_isar1_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar1_el1_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar1_el1, value, 0xf000, 12) }
		inline uint32_t set(uint32_t id_isar1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar1_el1, value, 0xf000, 12) }
	}

	namespace except_ar
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar1_el1, 0xf00, 8) }
		inline uint32_t get(uint32_t id_isar1_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar1_el1_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar1_el1, value, 0xf00, 8) }
		inline uint32_t set(uint32_t id_isar1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar1_el1, value, 0xf00, 8) }
	}

	namespace except
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar1_el1, 0xf0, 4) }
		inline uint32_t get(uint32_t id_isar1_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar1_el1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar1_el1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t id_isar1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar1_el1, value, 0xf0, 4) }
	}

	namespace endian
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar1_el1, 0xf, 0) }
		inline uint32_t get(uint32_t id_isar1_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar1_el1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar1_el1, value, 0xf, 0) }
		inline uint32_t set(uint32_t id_isar1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar1_el1, value, 0xf, 0) }
	}
}

// ID_ISAR2_EL1 (AArch32 Instruction Set Attribute Register 2)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_isar2_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_isar2_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_isar2_el1, val) }

	namespace reversal
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar2_el1, 0xf0000000, 28) }
		inline uint32_t get(uint32_t id_isar2_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar2_el1_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar2_el1, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t id_isar2_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar2_el1, value, 0xf0000000, 28) }
	}

	namespace psr_ar
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar2_el1, 0xf000000, 24) }
		inline uint32_t get(uint32_t id_isar2_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar2_el1_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar2_el1, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t id_isar2_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar2_el1, value, 0xf000000, 24) }
	}

	namespace multu
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar2_el1, 0xf00000, 20) }
		inline uint32_t get(uint32_t id_isar2_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar2_el1_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar2_el1, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t id_isar2_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar2_el1, value, 0xf00000, 20) }
	}

	namespace mults
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar2_el1, 0xf0000, 16) }
		inline uint32_t get(uint32_t id_isar2_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar2_el1_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar2_el1, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t id_isar2_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar2_el1, value, 0xf0000, 16) }
	}

	namespace mult
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar2_el1, 0xf000, 12) }
		inline uint32_t get(uint32_t id_isar2_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar2_el1_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar2_el1, value, 0xf000, 12) }
		inline uint32_t set(uint32_t id_isar2_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar2_el1, value, 0xf000, 12) }
	}

	namespace multiaccessint
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar2_el1, 0xf00, 8) }
		inline uint32_t get(uint32_t id_isar2_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar2_el1_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar2_el1, value, 0xf00, 8) }
		inline uint32_t set(uint32_t id_isar2_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar2_el1, value, 0xf00, 8) }
	}

	namespace memhint
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar2_el1, 0xf0, 4) }
		inline uint32_t get(uint32_t id_isar2_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar2_el1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar2_el1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t id_isar2_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar2_el1, value, 0xf0, 4) }
	}

	namespace loadstore
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar2_el1, 0xf, 0) }
		inline uint32_t get(uint32_t id_isar2_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar2_el1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar2_el1, value, 0xf, 0) }
		inline uint32_t set(uint32_t id_isar2_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar2_el1, value, 0xf, 0) }
	}
}

// ID_ISAR3_EL1 (AArch32 Instruction Set Attribute Register 3)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_isar3_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_isar3_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_isar3_el1, val) }

	namespace t32ee
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar3_el1, 0xf0000000, 28) }
		inline uint32_t get(uint32_t id_isar3_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar3_el1_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar3_el1, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t id_isar3_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar3_el1, value, 0xf0000000, 28) }
	}

	namespace truenop
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar3_el1, 0xf000000, 24) }
		inline uint32_t get(uint32_t id_isar3_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar3_el1_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar3_el1, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t id_isar3_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar3_el1, value, 0xf000000, 24) }
	}

	namespace t32copy
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar3_el1, 0xf00000, 20) }
		inline uint32_t get(uint32_t id_isar3_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar3_el1_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar3_el1, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t id_isar3_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar3_el1, value, 0xf00000, 20) }
	}

	namespace tabbranch
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar3_el1, 0xf0000, 16) }
		inline uint32_t get(uint32_t id_isar3_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar3_el1_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar3_el1, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t id_isar3_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar3_el1, value, 0xf0000, 16) }
	}

	namespace synchprim
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar3_el1, 0xf000, 12) }
		inline uint32_t get(uint32_t id_isar3_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar3_el1_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar3_el1, value, 0xf000, 12) }
		inline uint32_t set(uint32_t id_isar3_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar3_el1, value, 0xf000, 12) }
	}

	namespace svc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar3_el1, 0xf00, 8) }
		inline uint32_t get(uint32_t id_isar3_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar3_el1_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar3_el1, value, 0xf00, 8) }
		inline uint32_t set(uint32_t id_isar3_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar3_el1, value, 0xf00, 8) }
	}

	namespace simd
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar3_el1, 0xf0, 4) }
		inline uint32_t get(uint32_t id_isar3_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar3_el1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar3_el1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t id_isar3_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar3_el1, value, 0xf0, 4) }
	}

	namespace saturate
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar3_el1, 0xf, 0) }
		inline uint32_t get(uint32_t id_isar3_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar3_el1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar3_el1, value, 0xf, 0) }
		inline uint32_t set(uint32_t id_isar3_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar3_el1, value, 0xf, 0) }
	}
}

// ID_ISAR4_EL1 (AArch32 Instruction Set Attribute Register 4)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_isar4_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_isar4_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_isar4_el1, val) }

	namespace swp_frac
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar4_el1, 0xf0000000, 28) }
		inline uint32_t get(uint32_t id_isar4_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar4_el1_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar4_el1, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t id_isar4_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar4_el1, value, 0xf0000000, 28) }
	}

	namespace psr_m
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar4_el1, 0xf000000, 24) }
		inline uint32_t get(uint32_t id_isar4_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar4_el1_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar4_el1, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t id_isar4_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar4_el1, value, 0xf000000, 24) }
	}

	namespace synchprim_frac
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar4_el1, 0xf00000, 20) }
		inline uint32_t get(uint32_t id_isar4_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar4_el1_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar4_el1, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t id_isar4_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar4_el1, value, 0xf00000, 20) }
	}

	namespace barrier
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar4_el1, 0xf0000, 16) }
		inline uint32_t get(uint32_t id_isar4_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar4_el1_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar4_el1, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t id_isar4_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar4_el1, value, 0xf0000, 16) }
	}

	namespace smc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar4_el1, 0xf000, 12) }
		inline uint32_t get(uint32_t id_isar4_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar4_el1_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar4_el1, value, 0xf000, 12) }
		inline uint32_t set(uint32_t id_isar4_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar4_el1, value, 0xf000, 12) }
	}

	namespace writeback
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar4_el1, 0xf00, 8) }
		inline uint32_t get(uint32_t id_isar4_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar4_el1_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar4_el1, value, 0xf00, 8) }
		inline uint32_t set(uint32_t id_isar4_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar4_el1, value, 0xf00, 8) }
	}

	namespace withshifts
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar4_el1, 0xf0, 4) }
		inline uint32_t get(uint32_t id_isar4_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar4_el1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar4_el1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t id_isar4_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar4_el1, value, 0xf0, 4) }
	}

	namespace unpriv
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_isar4_el1, 0xf, 0) }
		inline uint32_t get(uint32_t id_isar4_el1_val) noexcept { GET_BITFIELD_FUNC(id_isar4_el1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_isar4_el1, value, 0xf, 0) }
		inline uint32_t set(uint32_t id_isar4_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_isar4_el1, value, 0xf, 0) }
	}
}

// ID_ISAR5_EL1 (AArch32 Instruction Set Attribute Register 5)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_isar5_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_isar5_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_isar5_el1, val) }
}

// ID_ISAR6_EL1 (AArch32 Instruction Set Attribute Register 6)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_isar6_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_isar6_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_isar6_el1, val) }
}

// ID_MMFR0_EL1 (AArch32 Memory Model Feature Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_mmfr0_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_mmfr0_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_mmfr0_el1, val) }

	namespace innershr
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr0_el1, 0xf0000000, 28) }
		inline uint32_t get(uint32_t id_mmfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr0_el1_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr0_el1, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t id_mmfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr0_el1, value, 0xf0000000, 28) }
	}

	namespace fcse
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr0_el1, 0xf000000, 24) }
		inline uint32_t get(uint32_t id_mmfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr0_el1_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr0_el1, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t id_mmfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr0_el1, value, 0xf000000, 24) }
	}

	namespace auxreg
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr0_el1, 0xf00000, 20) }
		inline uint32_t get(uint32_t id_mmfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr0_el1_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr0_el1, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t id_mmfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr0_el1, value, 0xf00000, 20) }
	}

	namespace tcm
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr0_el1, 0xf0000, 16) }
		inline uint32_t get(uint32_t id_mmfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr0_el1_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr0_el1, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t id_mmfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr0_el1, value, 0xf0000, 16) }
	}

	namespace sharelvl
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr0_el1, 0xf000, 12) }
		inline uint32_t get(uint32_t id_mmfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr0_el1_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr0_el1, value, 0xf000, 12) }
		inline uint32_t set(uint32_t id_mmfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr0_el1, value, 0xf000, 12) }
	}

	namespace outershr
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr0_el1, 0xf00, 8) }
		inline uint32_t get(uint32_t id_mmfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr0_el1_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr0_el1, value, 0xf00, 8) }
		inline uint32_t set(uint32_t id_mmfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr0_el1, value, 0xf00, 8) }
	}

	namespace pmsa
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr0_el1, 0xf0, 4) }
		inline uint32_t get(uint32_t id_mmfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr0_el1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr0_el1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t id_mmfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr0_el1, value, 0xf0, 4) }
	}

	namespace vmsa
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr0_el1, 0xf, 0) }
		inline uint32_t get(uint32_t id_mmfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr0_el1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr0_el1, value, 0xf, 0) }
		inline uint32_t set(uint32_t id_mmfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr0_el1, value, 0xf, 0) }
	}
}

// ID_MMFR1_EL1 (AArch32 Memory Model Feature Register 1)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_mmfr1_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_mmfr1_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_mmfr1_el1, val) }

	namespace bpred
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr1_el1, 0xf0000000, 28) }
		inline uint32_t get(uint32_t id_mmfr1_el1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr1_el1_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr1_el1, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t id_mmfr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr1_el1, value, 0xf0000000, 28) }
	}

	namespace l1tstcln
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr1_el1, 0xf000000, 24) }
		inline uint32_t get(uint32_t id_mmfr1_el1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr1_el1_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr1_el1, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t id_mmfr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr1_el1, value, 0xf000000, 24) }
	}

	namespace l1uni
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr1_el1, 0xf00000, 20) }
		inline uint32_t get(uint32_t id_mmfr1_el1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr1_el1_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr1_el1, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t id_mmfr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr1_el1, value, 0xf00000, 20) }
	}

	namespace l1hvd
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr1_el1, 0xf0000, 16) }
		inline uint32_t get(uint32_t id_mmfr1_el1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr1_el1_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr1_el1, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t id_mmfr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr1_el1, value, 0xf0000, 16) }
	}

	namespace l1unisw
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr1_el1, 0xf000, 12) }
		inline uint32_t get(uint32_t id_mmfr1_el1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr1_el1_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr1_el1, value, 0xf000, 12) }
		inline uint32_t set(uint32_t id_mmfr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr1_el1, value, 0xf000, 12) }
	}

	namespace l1hvdsw
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr1_el1, 0xf00, 8) }
		inline uint32_t get(uint32_t id_mmfr1_el1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr1_el1_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr1_el1, value, 0xf00, 8) }
		inline uint32_t set(uint32_t id_mmfr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr1_el1, value, 0xf00, 8) }
	}

	namespace l1univa
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr1_el1, 0xf0, 4) }
		inline uint32_t get(uint32_t id_mmfr1_el1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr1_el1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr1_el1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t id_mmfr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr1_el1, value, 0xf0, 4) }
	}

	namespace l1hvdva
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr1_el1, 0xf, 0) }
		inline uint32_t get(uint32_t id_mmfr1_el1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr1_el1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr1_el1, value, 0xf, 0) }
		inline uint32_t set(uint32_t id_mmfr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr1_el1, value, 0xf, 0) }
	}
}

// ID_MMFR2_EL1 (AArch32 Memory Model Feature Register 2)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_mmfr2_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_mmfr2_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_mmfr2_el1, val) }

	namespace hwaccflg
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr2_el1, 0xf0000000, 28) }
		inline uint32_t get(uint32_t id_mmfr2_el1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr2_el1_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr2_el1, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t id_mmfr2_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr2_el1, value, 0xf0000000, 28) }
	}

	namespace wfistall
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr2_el1, 0xf000000, 24) }
		inline uint32_t get(uint32_t id_mmfr2_el1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr2_el1_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr2_el1, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t id_mmfr2_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr2_el1, value, 0xf000000, 24) }
	}

	namespace membarr
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr2_el1, 0xf00000, 20) }
		inline uint32_t get(uint32_t id_mmfr2_el1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr2_el1_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr2_el1, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t id_mmfr2_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr2_el1, value, 0xf00000, 20) }
	}

	namespace unitlb
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr2_el1, 0xf0000, 16) }
		inline uint32_t get(uint32_t id_mmfr2_el1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr2_el1_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr2_el1, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t id_mmfr2_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr2_el1, value, 0xf0000, 16) }
	}

	namespace hvdtlb
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr2_el1, 0xf000, 12) }
		inline uint32_t get(uint32_t id_mmfr2_el1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr2_el1_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr2_el1, value, 0xf000, 12) }
		inline uint32_t set(uint32_t id_mmfr2_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr2_el1, value, 0xf000, 12) }
	}

	namespace l1hvdrng
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr2_el1, 0xf00, 8) }
		inline uint32_t get(uint32_t id_mmfr2_el1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr2_el1_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr2_el1, value, 0xf00, 8) }
		inline uint32_t set(uint32_t id_mmfr2_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr2_el1, value, 0xf00, 8) }
	}

	namespace l1hvdbg
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr2_el1, 0xf0, 4) }
		inline uint32_t get(uint32_t id_mmfr2_el1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr2_el1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr2_el1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t id_mmfr2_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr2_el1, value, 0xf0, 4) }
	}

	namespace l1hvdfg
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_mmfr2_el1, 0xf, 0) }
		inline uint32_t get(uint32_t id_mmfr2_el1_val) noexcept { GET_BITFIELD_FUNC(id_mmfr2_el1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_mmfr2_el1, value, 0xf, 0) }
		inline uint32_t set(uint32_t id_mmfr2_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_mmfr2_el1, value, 0xf, 0) }
	}
}

// ID_MMFR3_EL1 (AArch32 Memory Model Feature Register 3)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_mmfr3_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_mmfr3_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_mmfr3_el1, val) }
}

// ID_MMFR4_EL1 (AArch32 Memory Model Feature Register 4)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_mmfr4_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_mmfr4_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_mmfr4_el1, val) }
}

// ID_PFR0_EL1 (AArch32 Processor Feature Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_pfr0_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_pfr0_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_pfr0_el1, val) }

	namespace ras
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr0_el1, 0xf0000000, 28) }
		inline uint32_t get(uint32_t id_pfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_pfr0_el1_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr0_el1, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t id_pfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr0_el1, value, 0xf0000000, 28) }
	}

	namespace state3
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr0_el1, 0xf000, 12) }
		inline uint32_t get(uint32_t id_pfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_pfr0_el1_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr0_el1, value, 0xf000, 12) }
		inline uint32_t set(uint32_t id_pfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr0_el1, value, 0xf000, 12) }
	}

	namespace state2
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr0_el1, 0xf00, 8) }
		inline uint32_t get(uint32_t id_pfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_pfr0_el1_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr0_el1, value, 0xf00, 8) }
		inline uint32_t set(uint32_t id_pfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr0_el1, value, 0xf00, 8) }
	}

	namespace state1
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr0_el1, 0xf0, 4) }
		inline uint32_t get(uint32_t id_pfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_pfr0_el1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr0_el1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t id_pfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr0_el1, value, 0xf0, 4) }
	}

	namespace state0
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr0_el1, 0xf, 0) }
		inline uint32_t get(uint32_t id_pfr0_el1_val) noexcept { GET_BITFIELD_FUNC(id_pfr0_el1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr0_el1, value, 0xf, 0) }
		inline uint32_t set(uint32_t id_pfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr0_el1, value, 0xf, 0) }
	}
}

// ID_PFR1_EL1 (AArch32 Processor Feature Register 1)
// See the ARMv8 architecture reference manual for a description of this register
namespace id_pfr1_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(id_pfr1_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(id_pfr1_el1, val) }

	namespace gic
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr1_el1, 0xf0000000, 28) }
		inline uint32_t get(uint32_t id_pfr1_el1_val) noexcept { GET_BITFIELD_FUNC(id_pfr1_el1_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr1_el1, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t id_pfr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr1_el1, value, 0xf0000000, 28) }
	}

	namespace virt_frac
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr1_el1, 0xf000000, 24) }
		inline uint32_t get(uint32_t id_pfr1_el1_val) noexcept { GET_BITFIELD_FUNC(id_pfr1_el1_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr1_el1, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t id_pfr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr1_el1, value, 0xf000000, 24) }
	}

	namespace sec_frac
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr1_el1, 0xf00000, 20) }
		inline uint32_t get(uint32_t id_pfr1_el1_val) noexcept { GET_BITFIELD_FUNC(id_pfr1_el1_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr1_el1, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t id_pfr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr1_el1, value, 0xf00000, 20) }
	}

	namespace gentimer
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr1_el1, 0xf0000, 16) }
		inline uint32_t get(uint32_t id_pfr1_el1_val) noexcept { GET_BITFIELD_FUNC(id_pfr1_el1_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr1_el1, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t id_pfr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr1_el1, value, 0xf0000, 16) }
	}

	namespace virtualization
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr1_el1, 0xf000, 12) }
		inline uint32_t get(uint32_t id_pfr1_el1_val) noexcept { GET_BITFIELD_FUNC(id_pfr1_el1_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr1_el1, value, 0xf000, 12) }
		inline uint32_t set(uint32_t id_pfr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr1_el1, value, 0xf000, 12) }
	}

	namespace mprogmod
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr1_el1, 0xf00, 8) }
		inline uint32_t get(uint32_t id_pfr1_el1_val) noexcept { GET_BITFIELD_FUNC(id_pfr1_el1_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr1_el1, value, 0xf00, 8) }
		inline uint32_t set(uint32_t id_pfr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr1_el1, value, 0xf00, 8) }
	}

	namespace security
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr1_el1, 0xf0, 4) }
		inline uint32_t get(uint32_t id_pfr1_el1_val) noexcept { GET_BITFIELD_FUNC(id_pfr1_el1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr1_el1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t id_pfr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr1_el1, value, 0xf0, 4) }
	}

	namespace progmod
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(id_pfr1_el1, 0xf, 0) }
		inline uint32_t get(uint32_t id_pfr1_el1_val) noexcept { GET_BITFIELD_FUNC(id_pfr1_el1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(id_pfr1_el1, value, 0xf, 0) }
		inline uint32_t set(uint32_t id_pfr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(id_pfr1_el1, value, 0xf, 0) }
	}
}

// IFSR32_EL2 (Instruction Fault Status Register (EL2))
// Allows access to the AArch32 IFSR register from AArch64 state only. Its value has no effect on execution in AArch64 state.
namespace ifsr32_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ifsr32_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ifsr32_el2, val) }

	// Fieldset valid when: TTBCR.EAE==0
	namespace fieldset_1
	{
		namespace fnv
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ifsr32_el2, 16) }
			inline uint32_t is_enabled(uint32_t ifsr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ifsr32_el2_val, 16) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ifsr32_el2, 16) }
			inline uint32_t is_disabled(uint32_t ifsr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ifsr32_el2_val, 16) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ifsr32_el2, 0x10000) }
			inline uint32_t enable(uint32_t ifsr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ifsr32_el2_val, 0x10000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ifsr32_el2, 0x10000) }
			inline uint32_t disable(uint32_t ifsr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ifsr32_el2_val, 0x10000) }
		}

		namespace ext
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ifsr32_el2, 12) }
			inline uint32_t is_enabled(uint32_t ifsr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ifsr32_el2_val, 12) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ifsr32_el2, 12) }
			inline uint32_t is_disabled(uint32_t ifsr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ifsr32_el2_val, 12) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ifsr32_el2, 0x1000) }
			inline uint32_t enable(uint32_t ifsr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ifsr32_el2_val, 0x1000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ifsr32_el2, 0x1000) }
			inline uint32_t disable(uint32_t ifsr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ifsr32_el2_val, 0x1000) }
		}

		namespace fs_4_
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ifsr32_el2, 10) }
			inline uint32_t is_enabled(uint32_t ifsr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ifsr32_el2_val, 10) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ifsr32_el2, 10) }
			inline uint32_t is_disabled(uint32_t ifsr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ifsr32_el2_val, 10) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ifsr32_el2, 0x400) }
			inline uint32_t enable(uint32_t ifsr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ifsr32_el2_val, 0x400) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ifsr32_el2, 0x400) }
			inline uint32_t disable(uint32_t ifsr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ifsr32_el2_val, 0x400) }
		}

		namespace lpae
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ifsr32_el2, 9) }
			inline uint32_t is_enabled(uint32_t ifsr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ifsr32_el2_val, 9) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ifsr32_el2, 9) }
			inline uint32_t is_disabled(uint32_t ifsr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ifsr32_el2_val, 9) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ifsr32_el2, 0x200) }
			inline uint32_t enable(uint32_t ifsr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ifsr32_el2_val, 0x200) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ifsr32_el2, 0x200) }
			inline uint32_t disable(uint32_t ifsr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ifsr32_el2_val, 0x200) }
		}

		namespace fs_3:0_
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ifsr32_el2, 0xf, 0) }
			inline uint32_t get(uint32_t ifsr32_el2_val) noexcept { GET_BITFIELD_FUNC(ifsr32_el2_val, 0xf, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ifsr32_el2, value, 0xf, 0) }
			inline uint32_t set(uint32_t ifsr32_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ifsr32_el2, value, 0xf, 0) }
		}
	}

	// Fieldset valid when: TTBCR.EAE==1
	namespace fieldset_2
	{
		namespace fnv
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ifsr32_el2, 16) }
			inline uint32_t is_enabled(uint32_t ifsr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ifsr32_el2_val, 16) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ifsr32_el2, 16) }
			inline uint32_t is_disabled(uint32_t ifsr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ifsr32_el2_val, 16) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ifsr32_el2, 0x10000) }
			inline uint32_t enable(uint32_t ifsr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ifsr32_el2_val, 0x10000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ifsr32_el2, 0x10000) }
			inline uint32_t disable(uint32_t ifsr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ifsr32_el2_val, 0x10000) }
		}

		namespace ext
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ifsr32_el2, 12) }
			inline uint32_t is_enabled(uint32_t ifsr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ifsr32_el2_val, 12) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ifsr32_el2, 12) }
			inline uint32_t is_disabled(uint32_t ifsr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ifsr32_el2_val, 12) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ifsr32_el2, 0x1000) }
			inline uint32_t enable(uint32_t ifsr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ifsr32_el2_val, 0x1000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ifsr32_el2, 0x1000) }
			inline uint32_t disable(uint32_t ifsr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ifsr32_el2_val, 0x1000) }
		}

		namespace lpae
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ifsr32_el2, 9) }
			inline uint32_t is_enabled(uint32_t ifsr32_el2_val) noexcept { IS_BIT_ENABLED_FUNC(ifsr32_el2_val, 9) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ifsr32_el2, 9) }
			inline uint32_t is_disabled(uint32_t ifsr32_el2_val) noexcept { IS_BIT_DISABLED_FUNC(ifsr32_el2_val, 9) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ifsr32_el2, 0x200) }
			inline uint32_t enable(uint32_t ifsr32_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(ifsr32_el2_val, 0x200) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ifsr32_el2, 0x200) }
			inline uint32_t disable(uint32_t ifsr32_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ifsr32_el2_val, 0x200) }
		}

		namespace status
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ifsr32_el2, 0x3f, 0) }
			inline uint32_t get(uint32_t ifsr32_el2_val) noexcept { GET_BITFIELD_FUNC(ifsr32_el2_val, 0x3f, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ifsr32_el2, value, 0x3f, 0) }
			inline uint32_t set(uint32_t ifsr32_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ifsr32_el2, value, 0x3f, 0) }
		}
	}
}

// ISR_EL1 (Interrupt Status Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace isr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(isr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(isr_el1, val) }

	namespace a
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(isr_el1, 8) }
		inline uint32_t is_enabled(uint32_t isr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(isr_el1_val, 8) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(isr_el1, 8) }
		inline uint32_t is_disabled(uint32_t isr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(isr_el1_val, 8) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(isr_el1, 0x100) }
		inline uint32_t enable(uint32_t isr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(isr_el1_val, 0x100) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(isr_el1, 0x100) }
		inline uint32_t disable(uint32_t isr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(isr_el1_val, 0x100) }
	}

	namespace i
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(isr_el1, 7) }
		inline uint32_t is_enabled(uint32_t isr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(isr_el1_val, 7) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(isr_el1, 7) }
		inline uint32_t is_disabled(uint32_t isr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(isr_el1_val, 7) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(isr_el1, 0x80) }
		inline uint32_t enable(uint32_t isr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(isr_el1_val, 0x80) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(isr_el1, 0x80) }
		inline uint32_t disable(uint32_t isr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(isr_el1_val, 0x80) }
	}

	namespace f
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(isr_el1, 6) }
		inline uint32_t is_enabled(uint32_t isr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(isr_el1_val, 6) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(isr_el1, 6) }
		inline uint32_t is_disabled(uint32_t isr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(isr_el1_val, 6) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(isr_el1, 0x40) }
		inline uint32_t enable(uint32_t isr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(isr_el1_val, 0x40) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(isr_el1, 0x40) }
		inline uint32_t disable(uint32_t isr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(isr_el1_val, 0x40) }
	}
}

// LORC_EL1 (LORegion Control (EL1))
// Enables and disables LORegions, and selects the current LORegion descriptor.
namespace lorc_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(lorc_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(lorc_el1, val) }

	namespace ds
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(lorc_el1, 0x3fc, 2) }
		inline uint64_t get(uint64_t lorc_el1_val) noexcept { GET_BITFIELD_FUNC(lorc_el1_val, 0x3fc, 2) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(lorc_el1, value, 0x3fc, 2) }
		inline uint64_t set(uint64_t lorc_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(lorc_el1, value, 0x3fc, 2) }
	}

	namespace en
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(lorc_el1, 0) }
		inline uint64_t is_enabled(uint64_t lorc_el1_val) noexcept { IS_BIT_ENABLED_FUNC(lorc_el1_val, 0) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(lorc_el1, 0) }
		inline uint64_t is_disabled(uint64_t lorc_el1_val) noexcept { IS_BIT_DISABLED_FUNC(lorc_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(lorc_el1, 0x1) }
		inline uint64_t enable(uint64_t lorc_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(lorc_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(lorc_el1, 0x1) }
		inline uint64_t disable(uint64_t lorc_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(lorc_el1_val, 0x1) }
	}
}

// LOREA_EL1 (LORegion End Address (EL1))
// Holds the physical address of the end of the LORegion described in the current LORegion descriptor selected by LORC_EL1.DS.
namespace lorea_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(lorea_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(lorea_el1, val) }
}

// LORID_EL1 (LORegionID (EL1))
// Indicates the number of LORegions and LORegion descriptors supported by the PE.
namespace lorid_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(lorid_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(lorid_el1, val) }

	namespace ld
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(lorid_el1, 0xff0000, 16) }
		inline uint64_t get(uint64_t lorid_el1_val) noexcept { GET_BITFIELD_FUNC(lorid_el1_val, 0xff0000, 16) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(lorid_el1, value, 0xff0000, 16) }
		inline uint64_t set(uint64_t lorid_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(lorid_el1, value, 0xff0000, 16) }
	}

	namespace lr
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(lorid_el1, 0xff, 0) }
		inline uint64_t get(uint64_t lorid_el1_val) noexcept { GET_BITFIELD_FUNC(lorid_el1_val, 0xff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(lorid_el1, value, 0xff, 0) }
		inline uint64_t set(uint64_t lorid_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(lorid_el1, value, 0xff, 0) }
	}
}

// LORN_EL1 (LORegion Number (EL1))
// Holds the number of the LORegion described in the current LORegion descriptor selected by LORC_EL1.DS.
namespace lorn_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(lorn_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(lorn_el1, val) }

	namespace num
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(lorn_el1, 0xff, 0) }
		inline uint64_t get(uint64_t lorn_el1_val) noexcept { GET_BITFIELD_FUNC(lorn_el1_val, 0xff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(lorn_el1, value, 0xff, 0) }
		inline uint64_t set(uint64_t lorn_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(lorn_el1, value, 0xff, 0) }
	}
}

// LORSA_EL1 (LORegion Start Address (EL1))
// Indicates whether the current LORegion descriptor selected by LORC_EL1.DS is enabled, and holds the physical address of the start of the LORegion.
namespace lorsa_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(lorsa_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(lorsa_el1, val) }
}

// MAIR_EL1 (Memory Attribute Indirection Register (EL1))
// Provides the memory attribute encodings corresponding to the possible AttrIndx values in a Long-descriptor format translation table entry for stage 1 translations at EL1.
namespace mair_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(mair_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(mair_el1, val) }

	namespace attr_n_
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(mair_el1, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t mair_el1_val) noexcept { GET_BITFIELD_FUNC(mair_el1_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mair_el1, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t mair_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mair_el1, value, 0xffffffffffffffff, 0) }
	}
}

// MAIR_EL2 (Memory Attribute Indirection Register (EL2))
// Provides the memory attribute encodings corresponding to the possible AttrIndx values in a Long-descriptor format translation table entry for stage 1 translations at EL2.
namespace mair_el2
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(mair_el2) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(mair_el2, val) }

	namespace attr_n_
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(mair_el2, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t mair_el2_val) noexcept { GET_BITFIELD_FUNC(mair_el2_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mair_el2, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t mair_el2, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mair_el2, value, 0xffffffffffffffff, 0) }
	}
}

// MAIR_EL3 (Memory Attribute Indirection Register (EL3))
// Provides the memory attribute encodings corresponding to the possible AttrIndx values in a Long-descriptor format translation table entry for stage 1 translations at EL3.
namespace mair_el3
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(mair_el3) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(mair_el3, val) }

	namespace attr_n_
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(mair_el3, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t mair_el3_val) noexcept { GET_BITFIELD_FUNC(mair_el3_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mair_el3, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t mair_el3, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mair_el3, value, 0xffffffffffffffff, 0) }
	}
}

// MDCCINT_EL1 (Monitor DCC Interrupt Enable Register)
// Enables interrupt requests to be signaled based on the DCC status flags.
namespace mdccint_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(mdccint_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(mdccint_el1, val) }

	namespace rx
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(mdccint_el1, 30) }
		inline uint32_t is_enabled(uint32_t mdccint_el1_val) noexcept { IS_BIT_ENABLED_FUNC(mdccint_el1_val, 30) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(mdccint_el1, 30) }
		inline uint32_t is_disabled(uint32_t mdccint_el1_val) noexcept { IS_BIT_DISABLED_FUNC(mdccint_el1_val, 30) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(mdccint_el1, 0x40000000) }
		inline uint32_t enable(uint32_t mdccint_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(mdccint_el1_val, 0x40000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(mdccint_el1, 0x40000000) }
		inline uint32_t disable(uint32_t mdccint_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(mdccint_el1_val, 0x40000000) }
	}

	namespace tx
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(mdccint_el1, 29) }
		inline uint32_t is_enabled(uint32_t mdccint_el1_val) noexcept { IS_BIT_ENABLED_FUNC(mdccint_el1_val, 29) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(mdccint_el1, 29) }
		inline uint32_t is_disabled(uint32_t mdccint_el1_val) noexcept { IS_BIT_DISABLED_FUNC(mdccint_el1_val, 29) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(mdccint_el1, 0x20000000) }
		inline uint32_t enable(uint32_t mdccint_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(mdccint_el1_val, 0x20000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(mdccint_el1, 0x20000000) }
		inline uint32_t disable(uint32_t mdccint_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(mdccint_el1_val, 0x20000000) }
	}
}

// MDCCSR_EL0 (Monitor DCC Status Register)
// Main control register for the debug implementation, containing flow-control flags for the DCC. This is an internal, read-only view.
namespace mdccsr_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(mdccsr_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(mdccsr_el0, val) }

	namespace rxfull
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(mdccsr_el0, 30) }
		inline uint32_t is_enabled(uint32_t mdccsr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(mdccsr_el0_val, 30) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(mdccsr_el0, 30) }
		inline uint32_t is_disabled(uint32_t mdccsr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(mdccsr_el0_val, 30) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(mdccsr_el0, 0x40000000) }
		inline uint32_t enable(uint32_t mdccsr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(mdccsr_el0_val, 0x40000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(mdccsr_el0, 0x40000000) }
		inline uint32_t disable(uint32_t mdccsr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(mdccsr_el0_val, 0x40000000) }
	}

	namespace txfull
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(mdccsr_el0, 29) }
		inline uint32_t is_enabled(uint32_t mdccsr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(mdccsr_el0_val, 29) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(mdccsr_el0, 29) }
		inline uint32_t is_disabled(uint32_t mdccsr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(mdccsr_el0_val, 29) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(mdccsr_el0, 0x20000000) }
		inline uint32_t enable(uint32_t mdccsr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(mdccsr_el0_val, 0x20000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(mdccsr_el0, 0x20000000) }
		inline uint32_t disable(uint32_t mdccsr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(mdccsr_el0_val, 0x20000000) }
	}
}

// MDCR_EL2 (Monitor Debug Configuration Register (EL2))
// Provides EL2 configuration options for self-hosted debug and the Performance Monitors Extension.
namespace mdcr_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(mdcr_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(mdcr_el2, val) }
}

// MDCR_EL3 (Monitor Debug Configuration Register (EL3))
// Provides EL3 configuration options for self-hosted debug and the Performance Monitors Extension.
namespace mdcr_el3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(mdcr_el3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(mdcr_el3, val) }
}

// MDRAR_EL1 (Monitor Debug ROM Address Register)
// Defines the base physical address of a 4KB-aligned memory-mapped debug component, usually a ROM table that locates and describes the memory-mapped debug components in the system. ARMv8 deprecates any use of this register.
namespace mdrar_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(mdrar_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(mdrar_el1, val) }
}

// MDSCR_EL1 (Monitor Debug System Control Register)
// Main control register for the debug implementation.
namespace mdscr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(mdscr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(mdscr_el1, val) }
}

// MIDR_EL1 (Main ID Register)
// Provides identification information for the PE, including an implementer code for the device and a device ID number.
namespace midr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(midr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(midr_el1, val) }

	namespace implementer
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(midr_el1, 0xff000000, 24) }
		inline uint32_t get(uint32_t midr_el1_val) noexcept { GET_BITFIELD_FUNC(midr_el1_val, 0xff000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(midr_el1, value, 0xff000000, 24) }
		inline uint32_t set(uint32_t midr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(midr_el1, value, 0xff000000, 24) }
	}

	namespace variant
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(midr_el1, 0xf00000, 20) }
		inline uint32_t get(uint32_t midr_el1_val) noexcept { GET_BITFIELD_FUNC(midr_el1_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(midr_el1, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t midr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(midr_el1, value, 0xf00000, 20) }
	}

	namespace architecture
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(midr_el1, 0xf0000, 16) }
		inline uint32_t get(uint32_t midr_el1_val) noexcept { GET_BITFIELD_FUNC(midr_el1_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(midr_el1, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t midr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(midr_el1, value, 0xf0000, 16) }
	}

	namespace partnum
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(midr_el1, 0xfff0, 4) }
		inline uint32_t get(uint32_t midr_el1_val) noexcept { GET_BITFIELD_FUNC(midr_el1_val, 0xfff0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(midr_el1, value, 0xfff0, 4) }
		inline uint32_t set(uint32_t midr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(midr_el1, value, 0xfff0, 4) }
	}

	namespace revision
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(midr_el1, 0xf, 0) }
		inline uint32_t get(uint32_t midr_el1_val) noexcept { GET_BITFIELD_FUNC(midr_el1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(midr_el1, value, 0xf, 0) }
		inline uint32_t set(uint32_t midr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(midr_el1, value, 0xf, 0) }
	}
}

// MPIDR_EL1 (Multiprocessor Affinity Register)
// In a multiprocessor system, provides an additional PE identification mechanism for scheduling purposes.
namespace mpidr_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(mpidr_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(mpidr_el1, val) }

	namespace aff3
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(mpidr_el1, 0xff00000000, 32) }
		inline uint64_t get(uint64_t mpidr_el1_val) noexcept { GET_BITFIELD_FUNC(mpidr_el1_val, 0xff00000000, 32) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mpidr_el1, value, 0xff00000000, 32) }
		inline uint64_t set(uint64_t mpidr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mpidr_el1, value, 0xff00000000, 32) }
	}

	namespace u
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(mpidr_el1, 30) }
		inline uint64_t is_enabled(uint64_t mpidr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(mpidr_el1_val, 30) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(mpidr_el1, 30) }
		inline uint64_t is_disabled(uint64_t mpidr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(mpidr_el1_val, 30) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(mpidr_el1, 0x40000000) }
		inline uint64_t enable(uint64_t mpidr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(mpidr_el1_val, 0x40000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(mpidr_el1, 0x40000000) }
		inline uint64_t disable(uint64_t mpidr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(mpidr_el1_val, 0x40000000) }
	}

	namespace mt
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(mpidr_el1, 24) }
		inline uint64_t is_enabled(uint64_t mpidr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(mpidr_el1_val, 24) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(mpidr_el1, 24) }
		inline uint64_t is_disabled(uint64_t mpidr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(mpidr_el1_val, 24) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(mpidr_el1, 0x1000000) }
		inline uint64_t enable(uint64_t mpidr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(mpidr_el1_val, 0x1000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(mpidr_el1, 0x1000000) }
		inline uint64_t disable(uint64_t mpidr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(mpidr_el1_val, 0x1000000) }
	}

	namespace aff2
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(mpidr_el1, 0xff0000, 16) }
		inline uint64_t get(uint64_t mpidr_el1_val) noexcept { GET_BITFIELD_FUNC(mpidr_el1_val, 0xff0000, 16) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mpidr_el1, value, 0xff0000, 16) }
		inline uint64_t set(uint64_t mpidr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mpidr_el1, value, 0xff0000, 16) }
	}

	namespace aff1
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(mpidr_el1, 0xff00, 8) }
		inline uint64_t get(uint64_t mpidr_el1_val) noexcept { GET_BITFIELD_FUNC(mpidr_el1_val, 0xff00, 8) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mpidr_el1, value, 0xff00, 8) }
		inline uint64_t set(uint64_t mpidr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mpidr_el1, value, 0xff00, 8) }
	}

	namespace aff0
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(mpidr_el1, 0xff, 0) }
		inline uint64_t get(uint64_t mpidr_el1_val) noexcept { GET_BITFIELD_FUNC(mpidr_el1_val, 0xff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mpidr_el1, value, 0xff, 0) }
		inline uint64_t set(uint64_t mpidr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mpidr_el1, value, 0xff, 0) }
	}
}

// MVFR0_EL1 (AArch32 Media and VFP Feature Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace mvfr0_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(mvfr0_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(mvfr0_el1, val) }

	namespace fpround
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr0_el1, 0xf0000000, 28) }
		inline uint32_t get(uint32_t mvfr0_el1_val) noexcept { GET_BITFIELD_FUNC(mvfr0_el1_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr0_el1, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t mvfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr0_el1, value, 0xf0000000, 28) }
	}

	namespace fpshvec
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr0_el1, 0xf000000, 24) }
		inline uint32_t get(uint32_t mvfr0_el1_val) noexcept { GET_BITFIELD_FUNC(mvfr0_el1_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr0_el1, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t mvfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr0_el1, value, 0xf000000, 24) }
	}

	namespace fpsqrt
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr0_el1, 0xf00000, 20) }
		inline uint32_t get(uint32_t mvfr0_el1_val) noexcept { GET_BITFIELD_FUNC(mvfr0_el1_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr0_el1, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t mvfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr0_el1, value, 0xf00000, 20) }
	}

	namespace fpdivide
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr0_el1, 0xf0000, 16) }
		inline uint32_t get(uint32_t mvfr0_el1_val) noexcept { GET_BITFIELD_FUNC(mvfr0_el1_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr0_el1, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t mvfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr0_el1, value, 0xf0000, 16) }
	}

	namespace fptrap
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr0_el1, 0xf000, 12) }
		inline uint32_t get(uint32_t mvfr0_el1_val) noexcept { GET_BITFIELD_FUNC(mvfr0_el1_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr0_el1, value, 0xf000, 12) }
		inline uint32_t set(uint32_t mvfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr0_el1, value, 0xf000, 12) }
	}

	namespace fpdp
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr0_el1, 0xf00, 8) }
		inline uint32_t get(uint32_t mvfr0_el1_val) noexcept { GET_BITFIELD_FUNC(mvfr0_el1_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr0_el1, value, 0xf00, 8) }
		inline uint32_t set(uint32_t mvfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr0_el1, value, 0xf00, 8) }
	}

	namespace fpsp
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr0_el1, 0xf0, 4) }
		inline uint32_t get(uint32_t mvfr0_el1_val) noexcept { GET_BITFIELD_FUNC(mvfr0_el1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr0_el1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t mvfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr0_el1, value, 0xf0, 4) }
	}

	namespace simdreg
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr0_el1, 0xf, 0) }
		inline uint32_t get(uint32_t mvfr0_el1_val) noexcept { GET_BITFIELD_FUNC(mvfr0_el1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr0_el1, value, 0xf, 0) }
		inline uint32_t set(uint32_t mvfr0_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr0_el1, value, 0xf, 0) }
	}
}

// MVFR1_EL1 (AArch32 Media and VFP Feature Register 1)
// See the ARMv8 architecture reference manual for a description of this register
namespace mvfr1_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(mvfr1_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(mvfr1_el1, val) }

	namespace simdfmac
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr1_el1, 0xf0000000, 28) }
		inline uint32_t get(uint32_t mvfr1_el1_val) noexcept { GET_BITFIELD_FUNC(mvfr1_el1_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr1_el1, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t mvfr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr1_el1, value, 0xf0000000, 28) }
	}

	namespace fphp
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr1_el1, 0xf000000, 24) }
		inline uint32_t get(uint32_t mvfr1_el1_val) noexcept { GET_BITFIELD_FUNC(mvfr1_el1_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr1_el1, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t mvfr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr1_el1, value, 0xf000000, 24) }
	}

	namespace simdhp
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr1_el1, 0xf00000, 20) }
		inline uint32_t get(uint32_t mvfr1_el1_val) noexcept { GET_BITFIELD_FUNC(mvfr1_el1_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr1_el1, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t mvfr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr1_el1, value, 0xf00000, 20) }
	}

	namespace simdsp
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr1_el1, 0xf0000, 16) }
		inline uint32_t get(uint32_t mvfr1_el1_val) noexcept { GET_BITFIELD_FUNC(mvfr1_el1_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr1_el1, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t mvfr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr1_el1, value, 0xf0000, 16) }
	}

	namespace simdint
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr1_el1, 0xf000, 12) }
		inline uint32_t get(uint32_t mvfr1_el1_val) noexcept { GET_BITFIELD_FUNC(mvfr1_el1_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr1_el1, value, 0xf000, 12) }
		inline uint32_t set(uint32_t mvfr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr1_el1, value, 0xf000, 12) }
	}

	namespace simdls
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr1_el1, 0xf00, 8) }
		inline uint32_t get(uint32_t mvfr1_el1_val) noexcept { GET_BITFIELD_FUNC(mvfr1_el1_val, 0xf00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr1_el1, value, 0xf00, 8) }
		inline uint32_t set(uint32_t mvfr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr1_el1, value, 0xf00, 8) }
	}

	namespace fpdnan
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr1_el1, 0xf0, 4) }
		inline uint32_t get(uint32_t mvfr1_el1_val) noexcept { GET_BITFIELD_FUNC(mvfr1_el1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr1_el1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t mvfr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr1_el1, value, 0xf0, 4) }
	}

	namespace fpftz
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr1_el1, 0xf, 0) }
		inline uint32_t get(uint32_t mvfr1_el1_val) noexcept { GET_BITFIELD_FUNC(mvfr1_el1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr1_el1, value, 0xf, 0) }
		inline uint32_t set(uint32_t mvfr1_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr1_el1, value, 0xf, 0) }
	}
}

// MVFR2_EL1 (AArch32 Media and VFP Feature Register 2)
// See the ARMv8 architecture reference manual for a description of this register
namespace mvfr2_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(mvfr2_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(mvfr2_el1, val) }

	namespace fpmisc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr2_el1, 0xf0, 4) }
		inline uint32_t get(uint32_t mvfr2_el1_val) noexcept { GET_BITFIELD_FUNC(mvfr2_el1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr2_el1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t mvfr2_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr2_el1, value, 0xf0, 4) }
	}

	namespace simdmisc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(mvfr2_el1, 0xf, 0) }
		inline uint32_t get(uint32_t mvfr2_el1_val) noexcept { GET_BITFIELD_FUNC(mvfr2_el1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(mvfr2_el1, value, 0xf, 0) }
		inline uint32_t set(uint32_t mvfr2_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(mvfr2_el1, value, 0xf, 0) }
	}
}

// NZCV (Condition Flags)
// Allows access to the condition flags.
namespace nzcv
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(nzcv) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(nzcv, val) }

	namespace n
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(nzcv, 31) }
		inline uint32_t is_enabled(uint32_t nzcv_val) noexcept { IS_BIT_ENABLED_FUNC(nzcv_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(nzcv, 31) }
		inline uint32_t is_disabled(uint32_t nzcv_val) noexcept { IS_BIT_DISABLED_FUNC(nzcv_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(nzcv, 0x80000000) }
		inline uint32_t enable(uint32_t nzcv_val) noexcept { SET_BITS_BY_MASK_FUNC(nzcv_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(nzcv, 0x80000000) }
		inline uint32_t disable(uint32_t nzcv_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(nzcv_val, 0x80000000) }
	}

	namespace z
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(nzcv, 30) }
		inline uint32_t is_enabled(uint32_t nzcv_val) noexcept { IS_BIT_ENABLED_FUNC(nzcv_val, 30) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(nzcv, 30) }
		inline uint32_t is_disabled(uint32_t nzcv_val) noexcept { IS_BIT_DISABLED_FUNC(nzcv_val, 30) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(nzcv, 0x40000000) }
		inline uint32_t enable(uint32_t nzcv_val) noexcept { SET_BITS_BY_MASK_FUNC(nzcv_val, 0x40000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(nzcv, 0x40000000) }
		inline uint32_t disable(uint32_t nzcv_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(nzcv_val, 0x40000000) }
	}

	namespace c
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(nzcv, 29) }
		inline uint32_t is_enabled(uint32_t nzcv_val) noexcept { IS_BIT_ENABLED_FUNC(nzcv_val, 29) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(nzcv, 29) }
		inline uint32_t is_disabled(uint32_t nzcv_val) noexcept { IS_BIT_DISABLED_FUNC(nzcv_val, 29) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(nzcv, 0x20000000) }
		inline uint32_t enable(uint32_t nzcv_val) noexcept { SET_BITS_BY_MASK_FUNC(nzcv_val, 0x20000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(nzcv, 0x20000000) }
		inline uint32_t disable(uint32_t nzcv_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(nzcv_val, 0x20000000) }
	}

	namespace v
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(nzcv, 28) }
		inline uint32_t is_enabled(uint32_t nzcv_val) noexcept { IS_BIT_ENABLED_FUNC(nzcv_val, 28) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(nzcv, 28) }
		inline uint32_t is_disabled(uint32_t nzcv_val) noexcept { IS_BIT_DISABLED_FUNC(nzcv_val, 28) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(nzcv, 0x10000000) }
		inline uint32_t enable(uint32_t nzcv_val) noexcept { SET_BITS_BY_MASK_FUNC(nzcv_val, 0x10000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(nzcv, 0x10000000) }
		inline uint32_t disable(uint32_t nzcv_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(nzcv_val, 0x10000000) }
	}
}

// OSDLR_EL1 (OS Double Lock Register)
// Used to control the OS Double Lock.
namespace osdlr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(osdlr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(osdlr_el1, val) }

	namespace dlk
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(osdlr_el1, 0) }
		inline uint32_t is_enabled(uint32_t osdlr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(osdlr_el1_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(osdlr_el1, 0) }
		inline uint32_t is_disabled(uint32_t osdlr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(osdlr_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(osdlr_el1, 0x1) }
		inline uint32_t enable(uint32_t osdlr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(osdlr_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(osdlr_el1, 0x1) }
		inline uint32_t disable(uint32_t osdlr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(osdlr_el1_val, 0x1) }
	}
}

// OSDTRRX_EL1 (OS Lock Data Transfer Register, Receive)
// Used for save/restore of DBGDTRRX_EL0. It is a component of the Debug Communications Channel.
namespace osdtrrx_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(osdtrrx_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(osdtrrx_el1, val) }

	namespace update_dtrrx_without_side-effect
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(osdtrrx_el1, 0xffffffff, 0) }
		inline uint32_t get(uint32_t osdtrrx_el1_val) noexcept { GET_BITFIELD_FUNC(osdtrrx_el1_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(osdtrrx_el1, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t osdtrrx_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(osdtrrx_el1, value, 0xffffffff, 0) }
	}
}

// OSDTRTX_EL1 (OS Lock Data Transfer Register, Transmit)
// Used for save/restore of DBGDTRTX_EL0. It is a component of the Debug Communications Channel.
namespace osdtrtx_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(osdtrtx_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(osdtrtx_el1, val) }

	namespace return_dtrtx_without_side-effect
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(osdtrtx_el1, 0xffffffff, 0) }
		inline uint32_t get(uint32_t osdtrtx_el1_val) noexcept { GET_BITFIELD_FUNC(osdtrtx_el1_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(osdtrtx_el1, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t osdtrtx_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(osdtrtx_el1, value, 0xffffffff, 0) }
	}
}

// OSECCR_EL1 (OS Lock Exception Catch Control Register)
// Provides a mechanism for an operating system to access the contents of EDECCR that are otherwise invisible to software, so it can save/restore the contents of EDECCR over powerdown on behalf of the external debugger.
namespace oseccr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(oseccr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(oseccr_el1, val) }

	namespace edeccr
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(oseccr_el1, 0xffffffff, 0) }
		inline uint32_t get(uint32_t oseccr_el1_val) noexcept { GET_BITFIELD_FUNC(oseccr_el1_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(oseccr_el1, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t oseccr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(oseccr_el1, value, 0xffffffff, 0) }
	}
}

// OSLAR_EL1 (OS Lock Access Register)
// Used to lock or unlock the OS lock.
namespace oslar_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(oslar_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(oslar_el1, val) }

	namespace oslk
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(oslar_el1, 0) }
		inline uint32_t is_enabled(uint32_t oslar_el1_val) noexcept { IS_BIT_ENABLED_FUNC(oslar_el1_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(oslar_el1, 0) }
		inline uint32_t is_disabled(uint32_t oslar_el1_val) noexcept { IS_BIT_DISABLED_FUNC(oslar_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(oslar_el1, 0x1) }
		inline uint32_t enable(uint32_t oslar_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(oslar_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(oslar_el1, 0x1) }
		inline uint32_t disable(uint32_t oslar_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(oslar_el1_val, 0x1) }
	}
}

// OSLSR_EL1 (OS Lock Status Register)
// Provides the status of the OS lock.
namespace oslsr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(oslsr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(oslsr_el1, val) }

	namespace oslm_1_
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(oslsr_el1, 3) }
		inline uint32_t is_enabled(uint32_t oslsr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(oslsr_el1_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(oslsr_el1, 3) }
		inline uint32_t is_disabled(uint32_t oslsr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(oslsr_el1_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(oslsr_el1, 0x8) }
		inline uint32_t enable(uint32_t oslsr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(oslsr_el1_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(oslsr_el1, 0x8) }
		inline uint32_t disable(uint32_t oslsr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(oslsr_el1_val, 0x8) }
	}

	namespace ntt
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(oslsr_el1, 2) }
		inline uint32_t is_enabled(uint32_t oslsr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(oslsr_el1_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(oslsr_el1, 2) }
		inline uint32_t is_disabled(uint32_t oslsr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(oslsr_el1_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(oslsr_el1, 0x4) }
		inline uint32_t enable(uint32_t oslsr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(oslsr_el1_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(oslsr_el1, 0x4) }
		inline uint32_t disable(uint32_t oslsr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(oslsr_el1_val, 0x4) }
	}

	namespace oslk
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(oslsr_el1, 1) }
		inline uint32_t is_enabled(uint32_t oslsr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(oslsr_el1_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(oslsr_el1, 1) }
		inline uint32_t is_disabled(uint32_t oslsr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(oslsr_el1_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(oslsr_el1, 0x2) }
		inline uint32_t enable(uint32_t oslsr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(oslsr_el1_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(oslsr_el1, 0x2) }
		inline uint32_t disable(uint32_t oslsr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(oslsr_el1_val, 0x2) }
	}

	namespace oslm_0_
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(oslsr_el1, 0) }
		inline uint32_t is_enabled(uint32_t oslsr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(oslsr_el1_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(oslsr_el1, 0) }
		inline uint32_t is_disabled(uint32_t oslsr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(oslsr_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(oslsr_el1, 0x1) }
		inline uint32_t enable(uint32_t oslsr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(oslsr_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(oslsr_el1, 0x1) }
		inline uint32_t disable(uint32_t oslsr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(oslsr_el1_val, 0x1) }
	}
}

// PAN (Privileged Access Never)
// See the ARMv8 architecture reference manual for a description of this register
namespace pan
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pan) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pan, val) }

	namespace pan
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pan, 22) }
		inline uint32_t is_enabled(uint32_t pan_val) noexcept { IS_BIT_ENABLED_FUNC(pan_val, 22) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pan, 22) }
		inline uint32_t is_disabled(uint32_t pan_val) noexcept { IS_BIT_DISABLED_FUNC(pan_val, 22) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pan, 0x400000) }
		inline uint32_t enable(uint32_t pan_val) noexcept { SET_BITS_BY_MASK_FUNC(pan_val, 0x400000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pan, 0x400000) }
		inline uint32_t disable(uint32_t pan_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pan_val, 0x400000) }
	}
}

// PAR_EL1 (Physical Address Register)
// Returns the output address (OA) from an Address translation instruction that executed successfully, or fault information if the instruction did not execute successfully.
namespace par_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(par_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(par_el1, val) }

	// Fieldset valid when: PAR_EL1.F==0
	namespace fieldset_1
	{	}

	// Fieldset valid when: PAR_EL1.F==1
	namespace fieldset_2
	{
		namespace imp_def
		{
			inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(par_el1, 0xff00000000000000, 56) }
			inline uint64_t get(uint64_t par_el1_val) noexcept { GET_BITFIELD_FUNC(par_el1_val, 0xff00000000000000, 56) }
			inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(par_el1, value, 0xff00000000000000, 56) }
			inline uint64_t set(uint64_t par_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(par_el1, value, 0xff00000000000000, 56) }
		}

		namespace imp_def
		{
			inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(par_el1, 0xf0000000000000, 52) }
			inline uint64_t get(uint64_t par_el1_val) noexcept { GET_BITFIELD_FUNC(par_el1_val, 0xf0000000000000, 52) }
			inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(par_el1, value, 0xf0000000000000, 52) }
			inline uint64_t set(uint64_t par_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(par_el1, value, 0xf0000000000000, 52) }
		}

		namespace imp_def
		{
			inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(par_el1, 0xf000000000000, 48) }
			inline uint64_t get(uint64_t par_el1_val) noexcept { GET_BITFIELD_FUNC(par_el1_val, 0xf000000000000, 48) }
			inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(par_el1, value, 0xf000000000000, 48) }
			inline uint64_t set(uint64_t par_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(par_el1, value, 0xf000000000000, 48) }
		}

		namespace s
		{
			inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(par_el1, 9) }
			inline uint64_t is_enabled(uint64_t par_el1_val) noexcept { IS_BIT_ENABLED_FUNC(par_el1_val, 9) }
			inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(par_el1, 9) }
			inline uint64_t is_disabled(uint64_t par_el1_val) noexcept { IS_BIT_DISABLED_FUNC(par_el1_val, 9) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(par_el1, 0x200) }
			inline uint64_t enable(uint64_t par_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(par_el1_val, 0x200) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(par_el1, 0x200) }
			inline uint64_t disable(uint64_t par_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(par_el1_val, 0x200) }
		}

		namespace ptw
		{
			inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(par_el1, 8) }
			inline uint64_t is_enabled(uint64_t par_el1_val) noexcept { IS_BIT_ENABLED_FUNC(par_el1_val, 8) }
			inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(par_el1, 8) }
			inline uint64_t is_disabled(uint64_t par_el1_val) noexcept { IS_BIT_DISABLED_FUNC(par_el1_val, 8) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(par_el1, 0x100) }
			inline uint64_t enable(uint64_t par_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(par_el1_val, 0x100) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(par_el1, 0x100) }
			inline uint64_t disable(uint64_t par_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(par_el1_val, 0x100) }
		}

		namespace fst
		{
			inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(par_el1, 0x7e, 1) }
			inline uint64_t get(uint64_t par_el1_val) noexcept { GET_BITFIELD_FUNC(par_el1_val, 0x7e, 1) }
			inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(par_el1, value, 0x7e, 1) }
			inline uint64_t set(uint64_t par_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(par_el1, value, 0x7e, 1) }
		}

		namespace f
		{
			inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(par_el1, 0) }
			inline uint64_t is_enabled(uint64_t par_el1_val) noexcept { IS_BIT_ENABLED_FUNC(par_el1_val, 0) }
			inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(par_el1, 0) }
			inline uint64_t is_disabled(uint64_t par_el1_val) noexcept { IS_BIT_DISABLED_FUNC(par_el1_val, 0) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(par_el1, 0x1) }
			inline uint64_t enable(uint64_t par_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(par_el1_val, 0x1) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(par_el1, 0x1) }
			inline uint64_t disable(uint64_t par_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(par_el1_val, 0x1) }
		}
	}
}

// PMBIDR_EL1 (Profiling Buffer ID Register)
// Provides information to software as to whether the buffer can be programmed at the current Exception level.
namespace pmbidr_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(pmbidr_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmbidr_el1, val) }

	namespace f
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmbidr_el1, 5) }
		inline uint64_t is_enabled(uint64_t pmbidr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmbidr_el1_val, 5) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmbidr_el1, 5) }
		inline uint64_t is_disabled(uint64_t pmbidr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmbidr_el1_val, 5) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmbidr_el1, 0x20) }
		inline uint64_t enable(uint64_t pmbidr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmbidr_el1_val, 0x20) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmbidr_el1, 0x20) }
		inline uint64_t disable(uint64_t pmbidr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmbidr_el1_val, 0x20) }
	}

	namespace p
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmbidr_el1, 4) }
		inline uint64_t is_enabled(uint64_t pmbidr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmbidr_el1_val, 4) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmbidr_el1, 4) }
		inline uint64_t is_disabled(uint64_t pmbidr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmbidr_el1_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmbidr_el1, 0x10) }
		inline uint64_t enable(uint64_t pmbidr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmbidr_el1_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmbidr_el1, 0x10) }
		inline uint64_t disable(uint64_t pmbidr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmbidr_el1_val, 0x10) }
	}

	namespace align
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmbidr_el1, 0xf, 0) }
		inline uint64_t get(uint64_t pmbidr_el1_val) noexcept { GET_BITFIELD_FUNC(pmbidr_el1_val, 0xf, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmbidr_el1, value, 0xf, 0) }
		inline uint64_t set(uint64_t pmbidr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmbidr_el1, value, 0xf, 0) }
	}
}

// PMBLIMITR_EL1 (Profiling Buffer Limit Address Register)
// Defines the upper limit for the profiling buffer, and enables the profiling buffer
namespace pmblimitr_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(pmblimitr_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmblimitr_el1, val) }

	namespace limit
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmblimitr_el1, 0xfffffffffffff000, 12) }
		inline uint64_t get(uint64_t pmblimitr_el1_val) noexcept { GET_BITFIELD_FUNC(pmblimitr_el1_val, 0xfffffffffffff000, 12) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmblimitr_el1, value, 0xfffffffffffff000, 12) }
		inline uint64_t set(uint64_t pmblimitr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmblimitr_el1, value, 0xfffffffffffff000, 12) }
	}

	namespace fm
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmblimitr_el1, 0x6, 1) }
		inline uint64_t get(uint64_t pmblimitr_el1_val) noexcept { GET_BITFIELD_FUNC(pmblimitr_el1_val, 0x6, 1) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmblimitr_el1, value, 0x6, 1) }
		inline uint64_t set(uint64_t pmblimitr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmblimitr_el1, value, 0x6, 1) }
	}

	namespace e
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmblimitr_el1, 0) }
		inline uint64_t is_enabled(uint64_t pmblimitr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmblimitr_el1_val, 0) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmblimitr_el1, 0) }
		inline uint64_t is_disabled(uint64_t pmblimitr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmblimitr_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmblimitr_el1, 0x1) }
		inline uint64_t enable(uint64_t pmblimitr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmblimitr_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmblimitr_el1, 0x1) }
		inline uint64_t disable(uint64_t pmblimitr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmblimitr_el1_val, 0x1) }
	}
}

// PMBPTR_EL1 (Profiling Buffer Write Pointer Register)
// Defines the current write pointer for the profiling buffer.
namespace pmbptr_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(pmbptr_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmbptr_el1, val) }

	namespace ptr
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmbptr_el1, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t pmbptr_el1_val) noexcept { GET_BITFIELD_FUNC(pmbptr_el1_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmbptr_el1, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t pmbptr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmbptr_el1, value, 0xffffffffffffffff, 0) }
	}
}

// PMBSR_EL1 (Profiling Buffer Status/syndrome Register)
// Provides syndrome information to software when the buffer is disabled because the management interrupt has been raised.
namespace pmbsr_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(pmbsr_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmbsr_el1, val) }

	namespace ec
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmbsr_el1, 0xfc000000, 26) }
		inline uint64_t get(uint64_t pmbsr_el1_val) noexcept { GET_BITFIELD_FUNC(pmbsr_el1_val, 0xfc000000, 26) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmbsr_el1, value, 0xfc000000, 26) }
		inline uint64_t set(uint64_t pmbsr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmbsr_el1, value, 0xfc000000, 26) }
	}

	namespace dl
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmbsr_el1, 19) }
		inline uint64_t is_enabled(uint64_t pmbsr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmbsr_el1_val, 19) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmbsr_el1, 19) }
		inline uint64_t is_disabled(uint64_t pmbsr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmbsr_el1_val, 19) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmbsr_el1, 0x80000) }
		inline uint64_t enable(uint64_t pmbsr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmbsr_el1_val, 0x80000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmbsr_el1, 0x80000) }
		inline uint64_t disable(uint64_t pmbsr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmbsr_el1_val, 0x80000) }
	}

	namespace ea
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmbsr_el1, 18) }
		inline uint64_t is_enabled(uint64_t pmbsr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmbsr_el1_val, 18) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmbsr_el1, 18) }
		inline uint64_t is_disabled(uint64_t pmbsr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmbsr_el1_val, 18) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmbsr_el1, 0x40000) }
		inline uint64_t enable(uint64_t pmbsr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmbsr_el1_val, 0x40000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmbsr_el1, 0x40000) }
		inline uint64_t disable(uint64_t pmbsr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmbsr_el1_val, 0x40000) }
	}

	namespace s
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmbsr_el1, 17) }
		inline uint64_t is_enabled(uint64_t pmbsr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmbsr_el1_val, 17) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmbsr_el1, 17) }
		inline uint64_t is_disabled(uint64_t pmbsr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmbsr_el1_val, 17) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmbsr_el1, 0x20000) }
		inline uint64_t enable(uint64_t pmbsr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmbsr_el1_val, 0x20000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmbsr_el1, 0x20000) }
		inline uint64_t disable(uint64_t pmbsr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmbsr_el1_val, 0x20000) }
	}

	namespace coll
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmbsr_el1, 16) }
		inline uint64_t is_enabled(uint64_t pmbsr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmbsr_el1_val, 16) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmbsr_el1, 16) }
		inline uint64_t is_disabled(uint64_t pmbsr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmbsr_el1_val, 16) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmbsr_el1, 0x10000) }
		inline uint64_t enable(uint64_t pmbsr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmbsr_el1_val, 0x10000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmbsr_el1, 0x10000) }
		inline uint64_t disable(uint64_t pmbsr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmbsr_el1_val, 0x10000) }
	}

	namespace mss
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmbsr_el1, 0xffff, 0) }
		inline uint64_t get(uint64_t pmbsr_el1_val) noexcept { GET_BITFIELD_FUNC(pmbsr_el1_val, 0xffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmbsr_el1, value, 0xffff, 0) }
		inline uint64_t set(uint64_t pmbsr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmbsr_el1, value, 0xffff, 0) }
	}
}

// PMCCFILTR_EL0 (Performance Monitors Cycle Count Filter Register)
// Determines the modes in which the Cycle Counter, PMCCNTR_EL0, increments.
namespace pmccfiltr_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmccfiltr_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmccfiltr_el0, val) }

	namespace p
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmccfiltr_el0, 31) }
		inline uint32_t is_enabled(uint32_t pmccfiltr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmccfiltr_el0_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmccfiltr_el0, 31) }
		inline uint32_t is_disabled(uint32_t pmccfiltr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmccfiltr_el0_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr_el0, 0x80000000) }
		inline uint32_t enable(uint32_t pmccfiltr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmccfiltr_el0_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr_el0, 0x80000000) }
		inline uint32_t disable(uint32_t pmccfiltr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmccfiltr_el0_val, 0x80000000) }
	}

	namespace u
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmccfiltr_el0, 30) }
		inline uint32_t is_enabled(uint32_t pmccfiltr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmccfiltr_el0_val, 30) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmccfiltr_el0, 30) }
		inline uint32_t is_disabled(uint32_t pmccfiltr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmccfiltr_el0_val, 30) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr_el0, 0x40000000) }
		inline uint32_t enable(uint32_t pmccfiltr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmccfiltr_el0_val, 0x40000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr_el0, 0x40000000) }
		inline uint32_t disable(uint32_t pmccfiltr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmccfiltr_el0_val, 0x40000000) }
	}

	namespace nsk
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmccfiltr_el0, 29) }
		inline uint32_t is_enabled(uint32_t pmccfiltr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmccfiltr_el0_val, 29) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmccfiltr_el0, 29) }
		inline uint32_t is_disabled(uint32_t pmccfiltr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmccfiltr_el0_val, 29) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr_el0, 0x20000000) }
		inline uint32_t enable(uint32_t pmccfiltr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmccfiltr_el0_val, 0x20000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr_el0, 0x20000000) }
		inline uint32_t disable(uint32_t pmccfiltr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmccfiltr_el0_val, 0x20000000) }
	}

	namespace nsu
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmccfiltr_el0, 28) }
		inline uint32_t is_enabled(uint32_t pmccfiltr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmccfiltr_el0_val, 28) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmccfiltr_el0, 28) }
		inline uint32_t is_disabled(uint32_t pmccfiltr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmccfiltr_el0_val, 28) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr_el0, 0x10000000) }
		inline uint32_t enable(uint32_t pmccfiltr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmccfiltr_el0_val, 0x10000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr_el0, 0x10000000) }
		inline uint32_t disable(uint32_t pmccfiltr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmccfiltr_el0_val, 0x10000000) }
	}

	namespace nsh
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmccfiltr_el0, 27) }
		inline uint32_t is_enabled(uint32_t pmccfiltr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmccfiltr_el0_val, 27) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmccfiltr_el0, 27) }
		inline uint32_t is_disabled(uint32_t pmccfiltr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmccfiltr_el0_val, 27) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr_el0, 0x8000000) }
		inline uint32_t enable(uint32_t pmccfiltr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmccfiltr_el0_val, 0x8000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr_el0, 0x8000000) }
		inline uint32_t disable(uint32_t pmccfiltr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmccfiltr_el0_val, 0x8000000) }
	}

	namespace m
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmccfiltr_el0, 26) }
		inline uint32_t is_enabled(uint32_t pmccfiltr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmccfiltr_el0_val, 26) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmccfiltr_el0, 26) }
		inline uint32_t is_disabled(uint32_t pmccfiltr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmccfiltr_el0_val, 26) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr_el0, 0x4000000) }
		inline uint32_t enable(uint32_t pmccfiltr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmccfiltr_el0_val, 0x4000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr_el0, 0x4000000) }
		inline uint32_t disable(uint32_t pmccfiltr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmccfiltr_el0_val, 0x4000000) }
	}
}

// PMCCNTR_EL0 (Performance Monitors Cycle Count Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmccntr_el0
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(pmccntr_el0) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmccntr_el0, val) }

	namespace ccnt
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmccntr_el0, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t pmccntr_el0_val) noexcept { GET_BITFIELD_FUNC(pmccntr_el0_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmccntr_el0, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t pmccntr_el0, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmccntr_el0, value, 0xffffffffffffffff, 0) }
	}
}

// PMCEID0_EL0 (Performance Monitors Common Event Identification register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmceid0_el0
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(pmceid0_el0) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmceid0_el0, val) }
}

// PMCEID1_EL0 (Performance Monitors Common Event Identification register 1)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmceid1_el0
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(pmceid1_el0) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmceid1_el0, val) }
}

// PMCNTENCLR_EL0 (Performance Monitors Count Enable Clear register)
// Disables the Cycle Count Register, PMCCNTR_EL0, and any implemented event counters PMEVCNTR<n>. Reading this register shows which counters are enabled.
namespace pmcntenclr_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmcntenclr_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmcntenclr_el0, val) }

	namespace c
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcntenclr_el0, 31) }
		inline uint32_t is_enabled(uint32_t pmcntenclr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmcntenclr_el0_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcntenclr_el0, 31) }
		inline uint32_t is_disabled(uint32_t pmcntenclr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmcntenclr_el0_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcntenclr_el0, 0x80000000) }
		inline uint32_t enable(uint32_t pmcntenclr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcntenclr_el0_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcntenclr_el0, 0x80000000) }
		inline uint32_t disable(uint32_t pmcntenclr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcntenclr_el0_val, 0x80000000) }
	}

	namespace p_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmcntenclr_el0, 0x7fffffff, 0) }
		inline uint32_t get(uint32_t pmcntenclr_el0_val) noexcept { GET_BITFIELD_FUNC(pmcntenclr_el0_val, 0x7fffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmcntenclr_el0, value, 0x7fffffff, 0) }
		inline uint32_t set(uint32_t pmcntenclr_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmcntenclr_el0, value, 0x7fffffff, 0) }
	}
}

// PMCNTENSET_EL0 (Performance Monitors Count Enable Set register)
// Enables the Cycle Count Register, PMCCNTR_EL0, and any implemented event counters PMEVCNTR<n>. Reading this register shows which counters are enabled.
namespace pmcntenset_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmcntenset_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmcntenset_el0, val) }

	namespace c
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcntenset_el0, 31) }
		inline uint32_t is_enabled(uint32_t pmcntenset_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmcntenset_el0_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcntenset_el0, 31) }
		inline uint32_t is_disabled(uint32_t pmcntenset_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmcntenset_el0_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcntenset_el0, 0x80000000) }
		inline uint32_t enable(uint32_t pmcntenset_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcntenset_el0_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcntenset_el0, 0x80000000) }
		inline uint32_t disable(uint32_t pmcntenset_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcntenset_el0_val, 0x80000000) }
	}

	namespace p_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmcntenset_el0, 0x7fffffff, 0) }
		inline uint32_t get(uint32_t pmcntenset_el0_val) noexcept { GET_BITFIELD_FUNC(pmcntenset_el0_val, 0x7fffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmcntenset_el0, value, 0x7fffffff, 0) }
		inline uint32_t set(uint32_t pmcntenset_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmcntenset_el0, value, 0x7fffffff, 0) }
	}
}

// PMCR_EL0 (Performance Monitors Control Register)
// Provides details of the Performance Monitors implementation, including the number of counters implemented, and configures and controls the counters.
namespace pmcr_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmcr_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmcr_el0, val) }

	namespace imp
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmcr_el0, 0xff000000, 24) }
		inline uint32_t get(uint32_t pmcr_el0_val) noexcept { GET_BITFIELD_FUNC(pmcr_el0_val, 0xff000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmcr_el0, value, 0xff000000, 24) }
		inline uint32_t set(uint32_t pmcr_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmcr_el0, value, 0xff000000, 24) }
	}

	namespace idcode
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmcr_el0, 0xff0000, 16) }
		inline uint32_t get(uint32_t pmcr_el0_val) noexcept { GET_BITFIELD_FUNC(pmcr_el0_val, 0xff0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmcr_el0, value, 0xff0000, 16) }
		inline uint32_t set(uint32_t pmcr_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmcr_el0, value, 0xff0000, 16) }
	}

	namespace n
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmcr_el0, 0xf800, 11) }
		inline uint32_t get(uint32_t pmcr_el0_val) noexcept { GET_BITFIELD_FUNC(pmcr_el0_val, 0xf800, 11) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmcr_el0, value, 0xf800, 11) }
		inline uint32_t set(uint32_t pmcr_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmcr_el0, value, 0xf800, 11) }
	}

	namespace lc
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcr_el0, 6) }
		inline uint32_t is_enabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmcr_el0_val, 6) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcr_el0, 6) }
		inline uint32_t is_disabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmcr_el0_val, 6) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x40) }
		inline uint32_t enable(uint32_t pmcr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x40) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x40) }
		inline uint32_t disable(uint32_t pmcr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x40) }
	}

	namespace dp
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcr_el0, 5) }
		inline uint32_t is_enabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmcr_el0_val, 5) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcr_el0, 5) }
		inline uint32_t is_disabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmcr_el0_val, 5) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x20) }
		inline uint32_t enable(uint32_t pmcr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x20) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x20) }
		inline uint32_t disable(uint32_t pmcr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x20) }
	}

	namespace x
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcr_el0, 4) }
		inline uint32_t is_enabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmcr_el0_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcr_el0, 4) }
		inline uint32_t is_disabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmcr_el0_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x10) }
		inline uint32_t enable(uint32_t pmcr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x10) }
		inline uint32_t disable(uint32_t pmcr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x10) }
	}

	namespace d
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcr_el0, 3) }
		inline uint32_t is_enabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmcr_el0_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcr_el0, 3) }
		inline uint32_t is_disabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmcr_el0_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x8) }
		inline uint32_t enable(uint32_t pmcr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x8) }
		inline uint32_t disable(uint32_t pmcr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x8) }
	}

	namespace c
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcr_el0, 2) }
		inline uint32_t is_enabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmcr_el0_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcr_el0, 2) }
		inline uint32_t is_disabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmcr_el0_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x4) }
		inline uint32_t enable(uint32_t pmcr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x4) }
		inline uint32_t disable(uint32_t pmcr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x4) }
	}

	namespace p
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcr_el0, 1) }
		inline uint32_t is_enabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmcr_el0_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcr_el0, 1) }
		inline uint32_t is_disabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmcr_el0_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x2) }
		inline uint32_t enable(uint32_t pmcr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x2) }
		inline uint32_t disable(uint32_t pmcr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x2) }
	}

	namespace e
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcr_el0, 0) }
		inline uint32_t is_enabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmcr_el0_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcr_el0, 0) }
		inline uint32_t is_disabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmcr_el0_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x1) }
		inline uint32_t enable(uint32_t pmcr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x1) }
		inline uint32_t disable(uint32_t pmcr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x1) }
	}
}

// PMEVCNTR<n>_EL0 (Performance Monitors Event Count Registers)
// Holds event counter n, which counts events, where n is 0 to 30.
namespace pmevcntr<n>_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmevcntr<n>_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmevcntr<n>_el0, val) }

	namespace event_counter_n
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmevcntr<n>_el0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t pmevcntr<n>_el0_val) noexcept { GET_BITFIELD_FUNC(pmevcntr<n>_el0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmevcntr<n>_el0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t pmevcntr<n>_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmevcntr<n>_el0, value, 0xffffffff, 0) }
	}
}

// PMEVTYPER<n>_EL0 (Performance Monitors Event Type Registers)
// Configures event counter n, where n is 0 to 30.
namespace pmevtyper<n>_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmevtyper<n>_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmevtyper<n>_el0, val) }
}

// PMINTENCLR_EL1 (Performance Monitors Interrupt Enable Clear register)
// Disables the generation of interrupt requests on overflows from the Cycle Count Register, PMCCNTR_EL0, and the event counters PMEVCNTR<n>_EL0. Reading the register shows which overflow interrupt requests are enabled.
namespace pmintenclr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmintenclr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmintenclr_el1, val) }

	namespace c
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmintenclr_el1, 31) }
		inline uint32_t is_enabled(uint32_t pmintenclr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmintenclr_el1_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmintenclr_el1, 31) }
		inline uint32_t is_disabled(uint32_t pmintenclr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmintenclr_el1_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmintenclr_el1, 0x80000000) }
		inline uint32_t enable(uint32_t pmintenclr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmintenclr_el1_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmintenclr_el1, 0x80000000) }
		inline uint32_t disable(uint32_t pmintenclr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmintenclr_el1_val, 0x80000000) }
	}

	namespace p_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmintenclr_el1, 0x7fffffff, 0) }
		inline uint32_t get(uint32_t pmintenclr_el1_val) noexcept { GET_BITFIELD_FUNC(pmintenclr_el1_val, 0x7fffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmintenclr_el1, value, 0x7fffffff, 0) }
		inline uint32_t set(uint32_t pmintenclr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmintenclr_el1, value, 0x7fffffff, 0) }
	}
}

// PMINTENSET_EL1 (Performance Monitors Interrupt Enable Set register)
// Enables the generation of interrupt requests on overflows from the Cycle Count Register, PMCCNTR_EL0, and the event counters PMEVCNTR<n>_EL0. Reading the register shows which overflow interrupt requests are enabled.
namespace pmintenset_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmintenset_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmintenset_el1, val) }

	namespace c
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmintenset_el1, 31) }
		inline uint32_t is_enabled(uint32_t pmintenset_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmintenset_el1_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmintenset_el1, 31) }
		inline uint32_t is_disabled(uint32_t pmintenset_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmintenset_el1_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmintenset_el1, 0x80000000) }
		inline uint32_t enable(uint32_t pmintenset_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmintenset_el1_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmintenset_el1, 0x80000000) }
		inline uint32_t disable(uint32_t pmintenset_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmintenset_el1_val, 0x80000000) }
	}

	namespace p_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmintenset_el1, 0x7fffffff, 0) }
		inline uint32_t get(uint32_t pmintenset_el1_val) noexcept { GET_BITFIELD_FUNC(pmintenset_el1_val, 0x7fffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmintenset_el1, value, 0x7fffffff, 0) }
		inline uint32_t set(uint32_t pmintenset_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmintenset_el1, value, 0x7fffffff, 0) }
	}
}

// PMOVSCLR_EL0 (Performance Monitors Overflow Flag Status Clear Register)
// Contains the state of the overflow bit for the Cycle Count Register, PMCCNTR_EL0, and each of the implemented event counters PMEVCNTR<n>. Writing to this register clears these bits.
namespace pmovsclr_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmovsclr_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmovsclr_el0, val) }

	namespace c
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmovsclr_el0, 31) }
		inline uint32_t is_enabled(uint32_t pmovsclr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmovsclr_el0_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmovsclr_el0, 31) }
		inline uint32_t is_disabled(uint32_t pmovsclr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmovsclr_el0_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmovsclr_el0, 0x80000000) }
		inline uint32_t enable(uint32_t pmovsclr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmovsclr_el0_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmovsclr_el0, 0x80000000) }
		inline uint32_t disable(uint32_t pmovsclr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmovsclr_el0_val, 0x80000000) }
	}

	namespace p_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmovsclr_el0, 0x7fffffff, 0) }
		inline uint32_t get(uint32_t pmovsclr_el0_val) noexcept { GET_BITFIELD_FUNC(pmovsclr_el0_val, 0x7fffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmovsclr_el0, value, 0x7fffffff, 0) }
		inline uint32_t set(uint32_t pmovsclr_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmovsclr_el0, value, 0x7fffffff, 0) }
	}
}

// PMOVSSET_EL0 (Performance Monitors Overflow Flag Status Set register)
// Sets the state of the overflow bit for the Cycle Count Register, PMCCNTR_EL0, and each of the implemented event counters PMEVCNTR<n>.
namespace pmovsset_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmovsset_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmovsset_el0, val) }

	namespace c
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmovsset_el0, 31) }
		inline uint32_t is_enabled(uint32_t pmovsset_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmovsset_el0_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmovsset_el0, 31) }
		inline uint32_t is_disabled(uint32_t pmovsset_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmovsset_el0_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmovsset_el0, 0x80000000) }
		inline uint32_t enable(uint32_t pmovsset_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmovsset_el0_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmovsset_el0, 0x80000000) }
		inline uint32_t disable(uint32_t pmovsset_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmovsset_el0_val, 0x80000000) }
	}

	namespace p_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmovsset_el0, 0x7fffffff, 0) }
		inline uint32_t get(uint32_t pmovsset_el0_val) noexcept { GET_BITFIELD_FUNC(pmovsset_el0_val, 0x7fffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmovsset_el0, value, 0x7fffffff, 0) }
		inline uint32_t set(uint32_t pmovsset_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmovsset_el0, value, 0x7fffffff, 0) }
	}
}

// PMSCR_EL1 (Statistical Profiling Control Register (EL1))
// Provides EL1 controls for Statistical Profiling
namespace pmscr_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(pmscr_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmscr_el1, val) }

	namespace pct
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmscr_el1, 6) }
		inline uint64_t is_enabled(uint64_t pmscr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmscr_el1_val, 6) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmscr_el1, 6) }
		inline uint64_t is_disabled(uint64_t pmscr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmscr_el1_val, 6) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmscr_el1, 0x40) }
		inline uint64_t enable(uint64_t pmscr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmscr_el1_val, 0x40) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmscr_el1, 0x40) }
		inline uint64_t disable(uint64_t pmscr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmscr_el1_val, 0x40) }
	}

	namespace ts
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmscr_el1, 5) }
		inline uint64_t is_enabled(uint64_t pmscr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmscr_el1_val, 5) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmscr_el1, 5) }
		inline uint64_t is_disabled(uint64_t pmscr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmscr_el1_val, 5) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmscr_el1, 0x20) }
		inline uint64_t enable(uint64_t pmscr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmscr_el1_val, 0x20) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmscr_el1, 0x20) }
		inline uint64_t disable(uint64_t pmscr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmscr_el1_val, 0x20) }
	}

	namespace pa
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmscr_el1, 4) }
		inline uint64_t is_enabled(uint64_t pmscr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmscr_el1_val, 4) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmscr_el1, 4) }
		inline uint64_t is_disabled(uint64_t pmscr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmscr_el1_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmscr_el1, 0x10) }
		inline uint64_t enable(uint64_t pmscr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmscr_el1_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmscr_el1, 0x10) }
		inline uint64_t disable(uint64_t pmscr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmscr_el1_val, 0x10) }
	}

	namespace cx
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmscr_el1, 3) }
		inline uint64_t is_enabled(uint64_t pmscr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmscr_el1_val, 3) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmscr_el1, 3) }
		inline uint64_t is_disabled(uint64_t pmscr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmscr_el1_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmscr_el1, 0x8) }
		inline uint64_t enable(uint64_t pmscr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmscr_el1_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmscr_el1, 0x8) }
		inline uint64_t disable(uint64_t pmscr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmscr_el1_val, 0x8) }
	}

	namespace e1spe
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmscr_el1, 1) }
		inline uint64_t is_enabled(uint64_t pmscr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmscr_el1_val, 1) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmscr_el1, 1) }
		inline uint64_t is_disabled(uint64_t pmscr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmscr_el1_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmscr_el1, 0x2) }
		inline uint64_t enable(uint64_t pmscr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmscr_el1_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmscr_el1, 0x2) }
		inline uint64_t disable(uint64_t pmscr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmscr_el1_val, 0x2) }
	}

	namespace e0spe
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmscr_el1, 0) }
		inline uint64_t is_enabled(uint64_t pmscr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmscr_el1_val, 0) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmscr_el1, 0) }
		inline uint64_t is_disabled(uint64_t pmscr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmscr_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmscr_el1, 0x1) }
		inline uint64_t enable(uint64_t pmscr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmscr_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmscr_el1, 0x1) }
		inline uint64_t disable(uint64_t pmscr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmscr_el1_val, 0x1) }
	}
}

// PMSCR_EL2 (Statistical Profiling Control Register (EL2))
// Provides EL2 controls for Statistical Profiling
namespace pmscr_el2
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(pmscr_el2) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmscr_el2, val) }

	namespace pct
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmscr_el2, 6) }
		inline uint64_t is_enabled(uint64_t pmscr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(pmscr_el2_val, 6) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmscr_el2, 6) }
		inline uint64_t is_disabled(uint64_t pmscr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(pmscr_el2_val, 6) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmscr_el2, 0x40) }
		inline uint64_t enable(uint64_t pmscr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(pmscr_el2_val, 0x40) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmscr_el2, 0x40) }
		inline uint64_t disable(uint64_t pmscr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmscr_el2_val, 0x40) }
	}

	namespace ts
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmscr_el2, 5) }
		inline uint64_t is_enabled(uint64_t pmscr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(pmscr_el2_val, 5) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmscr_el2, 5) }
		inline uint64_t is_disabled(uint64_t pmscr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(pmscr_el2_val, 5) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmscr_el2, 0x20) }
		inline uint64_t enable(uint64_t pmscr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(pmscr_el2_val, 0x20) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmscr_el2, 0x20) }
		inline uint64_t disable(uint64_t pmscr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmscr_el2_val, 0x20) }
	}

	namespace pa
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmscr_el2, 4) }
		inline uint64_t is_enabled(uint64_t pmscr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(pmscr_el2_val, 4) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmscr_el2, 4) }
		inline uint64_t is_disabled(uint64_t pmscr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(pmscr_el2_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmscr_el2, 0x10) }
		inline uint64_t enable(uint64_t pmscr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(pmscr_el2_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmscr_el2, 0x10) }
		inline uint64_t disable(uint64_t pmscr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmscr_el2_val, 0x10) }
	}

	namespace cx
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmscr_el2, 3) }
		inline uint64_t is_enabled(uint64_t pmscr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(pmscr_el2_val, 3) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmscr_el2, 3) }
		inline uint64_t is_disabled(uint64_t pmscr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(pmscr_el2_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmscr_el2, 0x8) }
		inline uint64_t enable(uint64_t pmscr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(pmscr_el2_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmscr_el2, 0x8) }
		inline uint64_t disable(uint64_t pmscr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmscr_el2_val, 0x8) }
	}

	namespace e2spe
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmscr_el2, 1) }
		inline uint64_t is_enabled(uint64_t pmscr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(pmscr_el2_val, 1) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmscr_el2, 1) }
		inline uint64_t is_disabled(uint64_t pmscr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(pmscr_el2_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmscr_el2, 0x2) }
		inline uint64_t enable(uint64_t pmscr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(pmscr_el2_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmscr_el2, 0x2) }
		inline uint64_t disable(uint64_t pmscr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmscr_el2_val, 0x2) }
	}

	namespace e0hspe
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmscr_el2, 0) }
		inline uint64_t is_enabled(uint64_t pmscr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(pmscr_el2_val, 0) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmscr_el2, 0) }
		inline uint64_t is_disabled(uint64_t pmscr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(pmscr_el2_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmscr_el2, 0x1) }
		inline uint64_t enable(uint64_t pmscr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(pmscr_el2_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmscr_el2, 0x1) }
		inline uint64_t disable(uint64_t pmscr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmscr_el2_val, 0x1) }
	}
}

// PMSELR_EL0 (Performance Monitors Event Counter Selection Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmselr_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmselr_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmselr_el0, val) }

	namespace sel
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmselr_el0, 0x1f, 0) }
		inline uint32_t get(uint32_t pmselr_el0_val) noexcept { GET_BITFIELD_FUNC(pmselr_el0_val, 0x1f, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmselr_el0, value, 0x1f, 0) }
		inline uint32_t set(uint32_t pmselr_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmselr_el0, value, 0x1f, 0) }
	}
}

// PMSEVFR_EL1 (Sampling Event Filter Register)
// Controls sample filtering by events. The overall filter is the logical AND of these filters. For example, if E[3] and E[5] are both set to 1, only samples that have both event 3 (Level 1 unified or data cache refill) and event 5 set (TLB walk) are recorded
namespace pmsevfr_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(pmsevfr_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmsevfr_el1, val) }

	namespace e
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmsevfr_el1, 0xffff000000000000, 48) }
		inline uint64_t get(uint64_t pmsevfr_el1_val) noexcept { GET_BITFIELD_FUNC(pmsevfr_el1_val, 0xffff000000000000, 48) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmsevfr_el1, value, 0xffff000000000000, 48) }
		inline uint64_t set(uint64_t pmsevfr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmsevfr_el1, value, 0xffff000000000000, 48) }
	}

	namespace e
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmsevfr_el1, 0xff000000, 24) }
		inline uint64_t get(uint64_t pmsevfr_el1_val) noexcept { GET_BITFIELD_FUNC(pmsevfr_el1_val, 0xff000000, 24) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmsevfr_el1, value, 0xff000000, 24) }
		inline uint64_t set(uint64_t pmsevfr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmsevfr_el1, value, 0xff000000, 24) }
	}

	namespace e
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmsevfr_el1, 0xf000, 12) }
		inline uint64_t get(uint64_t pmsevfr_el1_val) noexcept { GET_BITFIELD_FUNC(pmsevfr_el1_val, 0xf000, 12) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmsevfr_el1, value, 0xf000, 12) }
		inline uint64_t set(uint64_t pmsevfr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmsevfr_el1, value, 0xf000, 12) }
	}

	namespace e_7_
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmsevfr_el1, 7) }
		inline uint64_t is_enabled(uint64_t pmsevfr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmsevfr_el1_val, 7) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmsevfr_el1, 7) }
		inline uint64_t is_disabled(uint64_t pmsevfr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmsevfr_el1_val, 7) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmsevfr_el1, 0x80) }
		inline uint64_t enable(uint64_t pmsevfr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmsevfr_el1_val, 0x80) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmsevfr_el1, 0x80) }
		inline uint64_t disable(uint64_t pmsevfr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmsevfr_el1_val, 0x80) }
	}

	namespace e_5_
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmsevfr_el1, 5) }
		inline uint64_t is_enabled(uint64_t pmsevfr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmsevfr_el1_val, 5) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmsevfr_el1, 5) }
		inline uint64_t is_disabled(uint64_t pmsevfr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmsevfr_el1_val, 5) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmsevfr_el1, 0x20) }
		inline uint64_t enable(uint64_t pmsevfr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmsevfr_el1_val, 0x20) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmsevfr_el1, 0x20) }
		inline uint64_t disable(uint64_t pmsevfr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmsevfr_el1_val, 0x20) }
	}

	namespace e_3_
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmsevfr_el1, 3) }
		inline uint64_t is_enabled(uint64_t pmsevfr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmsevfr_el1_val, 3) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmsevfr_el1, 3) }
		inline uint64_t is_disabled(uint64_t pmsevfr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmsevfr_el1_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmsevfr_el1, 0x8) }
		inline uint64_t enable(uint64_t pmsevfr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmsevfr_el1_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmsevfr_el1, 0x8) }
		inline uint64_t disable(uint64_t pmsevfr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmsevfr_el1_val, 0x8) }
	}

	namespace e_1_
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmsevfr_el1, 1) }
		inline uint64_t is_enabled(uint64_t pmsevfr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmsevfr_el1_val, 1) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmsevfr_el1, 1) }
		inline uint64_t is_disabled(uint64_t pmsevfr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmsevfr_el1_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmsevfr_el1, 0x2) }
		inline uint64_t enable(uint64_t pmsevfr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmsevfr_el1_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmsevfr_el1, 0x2) }
		inline uint64_t disable(uint64_t pmsevfr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmsevfr_el1_val, 0x2) }
	}
}

// PMSFCR_EL1 (Sampling Filter Control Register)
// Controls sample filtering. The filter is the logical AND of the FL, FT and FE bits. For example, if FE == 1 and FT == 1 only samples including the selected operation types and the selected events will be recorded
namespace pmsfcr_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(pmsfcr_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmsfcr_el1, val) }

	namespace st
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmsfcr_el1, 18) }
		inline uint64_t is_enabled(uint64_t pmsfcr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmsfcr_el1_val, 18) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmsfcr_el1, 18) }
		inline uint64_t is_disabled(uint64_t pmsfcr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmsfcr_el1_val, 18) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmsfcr_el1, 0x40000) }
		inline uint64_t enable(uint64_t pmsfcr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmsfcr_el1_val, 0x40000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmsfcr_el1, 0x40000) }
		inline uint64_t disable(uint64_t pmsfcr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmsfcr_el1_val, 0x40000) }
	}

	namespace ld
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmsfcr_el1, 17) }
		inline uint64_t is_enabled(uint64_t pmsfcr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmsfcr_el1_val, 17) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmsfcr_el1, 17) }
		inline uint64_t is_disabled(uint64_t pmsfcr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmsfcr_el1_val, 17) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmsfcr_el1, 0x20000) }
		inline uint64_t enable(uint64_t pmsfcr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmsfcr_el1_val, 0x20000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmsfcr_el1, 0x20000) }
		inline uint64_t disable(uint64_t pmsfcr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmsfcr_el1_val, 0x20000) }
	}

	namespace b
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmsfcr_el1, 16) }
		inline uint64_t is_enabled(uint64_t pmsfcr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmsfcr_el1_val, 16) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmsfcr_el1, 16) }
		inline uint64_t is_disabled(uint64_t pmsfcr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmsfcr_el1_val, 16) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmsfcr_el1, 0x10000) }
		inline uint64_t enable(uint64_t pmsfcr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmsfcr_el1_val, 0x10000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmsfcr_el1, 0x10000) }
		inline uint64_t disable(uint64_t pmsfcr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmsfcr_el1_val, 0x10000) }
	}

	namespace fl
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmsfcr_el1, 2) }
		inline uint64_t is_enabled(uint64_t pmsfcr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmsfcr_el1_val, 2) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmsfcr_el1, 2) }
		inline uint64_t is_disabled(uint64_t pmsfcr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmsfcr_el1_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmsfcr_el1, 0x4) }
		inline uint64_t enable(uint64_t pmsfcr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmsfcr_el1_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmsfcr_el1, 0x4) }
		inline uint64_t disable(uint64_t pmsfcr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmsfcr_el1_val, 0x4) }
	}

	namespace ft
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmsfcr_el1, 1) }
		inline uint64_t is_enabled(uint64_t pmsfcr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmsfcr_el1_val, 1) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmsfcr_el1, 1) }
		inline uint64_t is_disabled(uint64_t pmsfcr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmsfcr_el1_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmsfcr_el1, 0x2) }
		inline uint64_t enable(uint64_t pmsfcr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmsfcr_el1_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmsfcr_el1, 0x2) }
		inline uint64_t disable(uint64_t pmsfcr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmsfcr_el1_val, 0x2) }
	}

	namespace fe
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmsfcr_el1, 0) }
		inline uint64_t is_enabled(uint64_t pmsfcr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmsfcr_el1_val, 0) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmsfcr_el1, 0) }
		inline uint64_t is_disabled(uint64_t pmsfcr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmsfcr_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmsfcr_el1, 0x1) }
		inline uint64_t enable(uint64_t pmsfcr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmsfcr_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmsfcr_el1, 0x1) }
		inline uint64_t disable(uint64_t pmsfcr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmsfcr_el1_val, 0x1) }
	}
}

// PMSICR_EL1 (Sampling Interval Counter Register)
// Software must write zero to PMSICR_EL1 before enabling sample profiling for a sampling session. Software must then treat PMSICR_EL1 as an opaque, 64-bit, read/write register used for context switches only.
namespace pmsicr_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(pmsicr_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmsicr_el1, val) }

	namespace ecount
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmsicr_el1, 0xff00000000000000, 56) }
		inline uint64_t get(uint64_t pmsicr_el1_val) noexcept { GET_BITFIELD_FUNC(pmsicr_el1_val, 0xff00000000000000, 56) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmsicr_el1, value, 0xff00000000000000, 56) }
		inline uint64_t set(uint64_t pmsicr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmsicr_el1, value, 0xff00000000000000, 56) }
	}

	namespace count
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmsicr_el1, 0xffffffff, 0) }
		inline uint64_t get(uint64_t pmsicr_el1_val) noexcept { GET_BITFIELD_FUNC(pmsicr_el1_val, 0xffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmsicr_el1, value, 0xffffffff, 0) }
		inline uint64_t set(uint64_t pmsicr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmsicr_el1, value, 0xffffffff, 0) }
	}
}

// PMSIDR_EL1 (Sampling Profiling ID Register)
// Describes the Statistical Profiling implementation to software
namespace pmsidr_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(pmsidr_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmsidr_el1, val) }

	namespace countsize
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmsidr_el1, 0xf0000, 16) }
		inline uint64_t get(uint64_t pmsidr_el1_val) noexcept { GET_BITFIELD_FUNC(pmsidr_el1_val, 0xf0000, 16) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmsidr_el1, value, 0xf0000, 16) }
		inline uint64_t set(uint64_t pmsidr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmsidr_el1, value, 0xf0000, 16) }
	}

	namespace maxsize
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmsidr_el1, 0xf000, 12) }
		inline uint64_t get(uint64_t pmsidr_el1_val) noexcept { GET_BITFIELD_FUNC(pmsidr_el1_val, 0xf000, 12) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmsidr_el1, value, 0xf000, 12) }
		inline uint64_t set(uint64_t pmsidr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmsidr_el1, value, 0xf000, 12) }
	}

	namespace interval
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmsidr_el1, 0xf00, 8) }
		inline uint64_t get(uint64_t pmsidr_el1_val) noexcept { GET_BITFIELD_FUNC(pmsidr_el1_val, 0xf00, 8) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmsidr_el1, value, 0xf00, 8) }
		inline uint64_t set(uint64_t pmsidr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmsidr_el1, value, 0xf00, 8) }
	}

	namespace ernd
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmsidr_el1, 5) }
		inline uint64_t is_enabled(uint64_t pmsidr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmsidr_el1_val, 5) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmsidr_el1, 5) }
		inline uint64_t is_disabled(uint64_t pmsidr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmsidr_el1_val, 5) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmsidr_el1, 0x20) }
		inline uint64_t enable(uint64_t pmsidr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmsidr_el1_val, 0x20) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmsidr_el1, 0x20) }
		inline uint64_t disable(uint64_t pmsidr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmsidr_el1_val, 0x20) }
	}

	namespace lds
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmsidr_el1, 4) }
		inline uint64_t is_enabled(uint64_t pmsidr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmsidr_el1_val, 4) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmsidr_el1, 4) }
		inline uint64_t is_disabled(uint64_t pmsidr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmsidr_el1_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmsidr_el1, 0x10) }
		inline uint64_t enable(uint64_t pmsidr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmsidr_el1_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmsidr_el1, 0x10) }
		inline uint64_t disable(uint64_t pmsidr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmsidr_el1_val, 0x10) }
	}

	namespace archinst
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmsidr_el1, 3) }
		inline uint64_t is_enabled(uint64_t pmsidr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmsidr_el1_val, 3) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmsidr_el1, 3) }
		inline uint64_t is_disabled(uint64_t pmsidr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmsidr_el1_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmsidr_el1, 0x8) }
		inline uint64_t enable(uint64_t pmsidr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmsidr_el1_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmsidr_el1, 0x8) }
		inline uint64_t disable(uint64_t pmsidr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmsidr_el1_val, 0x8) }
	}

	namespace fl
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmsidr_el1, 2) }
		inline uint64_t is_enabled(uint64_t pmsidr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmsidr_el1_val, 2) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmsidr_el1, 2) }
		inline uint64_t is_disabled(uint64_t pmsidr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmsidr_el1_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmsidr_el1, 0x4) }
		inline uint64_t enable(uint64_t pmsidr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmsidr_el1_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmsidr_el1, 0x4) }
		inline uint64_t disable(uint64_t pmsidr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmsidr_el1_val, 0x4) }
	}

	namespace ft
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmsidr_el1, 1) }
		inline uint64_t is_enabled(uint64_t pmsidr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmsidr_el1_val, 1) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmsidr_el1, 1) }
		inline uint64_t is_disabled(uint64_t pmsidr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmsidr_el1_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmsidr_el1, 0x2) }
		inline uint64_t enable(uint64_t pmsidr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmsidr_el1_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmsidr_el1, 0x2) }
		inline uint64_t disable(uint64_t pmsidr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmsidr_el1_val, 0x2) }
	}

	namespace fe
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmsidr_el1, 0) }
		inline uint64_t is_enabled(uint64_t pmsidr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmsidr_el1_val, 0) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmsidr_el1, 0) }
		inline uint64_t is_disabled(uint64_t pmsidr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmsidr_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmsidr_el1, 0x1) }
		inline uint64_t enable(uint64_t pmsidr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmsidr_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmsidr_el1, 0x1) }
		inline uint64_t disable(uint64_t pmsidr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmsidr_el1_val, 0x1) }
	}
}

// PMSIRR_EL1 (Sampling Interval Reload Register)
// Defines the interval between samples
namespace pmsirr_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(pmsirr_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmsirr_el1, val) }

	namespace interval
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmsirr_el1, 0xffffff00, 8) }
		inline uint64_t get(uint64_t pmsirr_el1_val) noexcept { GET_BITFIELD_FUNC(pmsirr_el1_val, 0xffffff00, 8) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmsirr_el1, value, 0xffffff00, 8) }
		inline uint64_t set(uint64_t pmsirr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmsirr_el1, value, 0xffffff00, 8) }
	}

	namespace rnd
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmsirr_el1, 0) }
		inline uint64_t is_enabled(uint64_t pmsirr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmsirr_el1_val, 0) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmsirr_el1, 0) }
		inline uint64_t is_disabled(uint64_t pmsirr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmsirr_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmsirr_el1, 0x1) }
		inline uint64_t enable(uint64_t pmsirr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmsirr_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmsirr_el1, 0x1) }
		inline uint64_t disable(uint64_t pmsirr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmsirr_el1_val, 0x1) }
	}
}

// PMSLATFR_EL1 (Sampling Latency Filter Register)
// Controls sample filtering by latency
namespace pmslatfr_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(pmslatfr_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmslatfr_el1, val) }

	namespace minlat
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmslatfr_el1, 0xfff, 0) }
		inline uint64_t get(uint64_t pmslatfr_el1_val) noexcept { GET_BITFIELD_FUNC(pmslatfr_el1_val, 0xfff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmslatfr_el1, value, 0xfff, 0) }
		inline uint64_t set(uint64_t pmslatfr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmslatfr_el1, value, 0xfff, 0) }
	}
}

// PMSWINC_EL0 (Performance Monitors Software Increment register)
// Increments a counter that is configured to count the Software increment event, event 
namespace pmswinc_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmswinc_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmswinc_el0, val) }

	namespace p_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmswinc_el0, 0x7fffffff, 0) }
		inline uint32_t get(uint32_t pmswinc_el0_val) noexcept { GET_BITFIELD_FUNC(pmswinc_el0_val, 0x7fffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmswinc_el0, value, 0x7fffffff, 0) }
		inline uint32_t set(uint32_t pmswinc_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmswinc_el0, value, 0x7fffffff, 0) }
	}
}

// PMUSERENR_EL0 (Performance Monitors User Enable Register)
// Enables or disables EL0 access to the Performance Monitors.
namespace pmuserenr_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmuserenr_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmuserenr_el0, val) }

	namespace er
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmuserenr_el0, 3) }
		inline uint32_t is_enabled(uint32_t pmuserenr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmuserenr_el0_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmuserenr_el0, 3) }
		inline uint32_t is_disabled(uint32_t pmuserenr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmuserenr_el0_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmuserenr_el0, 0x8) }
		inline uint32_t enable(uint32_t pmuserenr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmuserenr_el0_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmuserenr_el0, 0x8) }
		inline uint32_t disable(uint32_t pmuserenr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmuserenr_el0_val, 0x8) }
	}

	namespace cr
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmuserenr_el0, 2) }
		inline uint32_t is_enabled(uint32_t pmuserenr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmuserenr_el0_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmuserenr_el0, 2) }
		inline uint32_t is_disabled(uint32_t pmuserenr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmuserenr_el0_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmuserenr_el0, 0x4) }
		inline uint32_t enable(uint32_t pmuserenr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmuserenr_el0_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmuserenr_el0, 0x4) }
		inline uint32_t disable(uint32_t pmuserenr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmuserenr_el0_val, 0x4) }
	}

	namespace sw
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmuserenr_el0, 1) }
		inline uint32_t is_enabled(uint32_t pmuserenr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmuserenr_el0_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmuserenr_el0, 1) }
		inline uint32_t is_disabled(uint32_t pmuserenr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmuserenr_el0_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmuserenr_el0, 0x2) }
		inline uint32_t enable(uint32_t pmuserenr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmuserenr_el0_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmuserenr_el0, 0x2) }
		inline uint32_t disable(uint32_t pmuserenr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmuserenr_el0_val, 0x2) }
	}

	namespace en
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmuserenr_el0, 0) }
		inline uint32_t is_enabled(uint32_t pmuserenr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmuserenr_el0_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmuserenr_el0, 0) }
		inline uint32_t is_disabled(uint32_t pmuserenr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmuserenr_el0_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmuserenr_el0, 0x1) }
		inline uint32_t enable(uint32_t pmuserenr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmuserenr_el0_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmuserenr_el0, 0x1) }
		inline uint32_t disable(uint32_t pmuserenr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmuserenr_el0_val, 0x1) }
	}
}

// PMXEVCNTR_EL0 (Performance Monitors Selected Event Count Register)
// Reads or writes the value of the selected event counter, PMEVCNTR<n>_EL0. PMSELR_EL0.SEL determines which event counter is selected.
namespace pmxevcntr_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmxevcntr_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmxevcntr_el0, val) }

	namespace pmevcntr_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmxevcntr_el0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t pmxevcntr_el0_val) noexcept { GET_BITFIELD_FUNC(pmxevcntr_el0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmxevcntr_el0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t pmxevcntr_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmxevcntr_el0, value, 0xffffffff, 0) }
	}
}

// PMXEVTYPER_EL0 (Performance Monitors Selected Event Type Register)
// When PMSELR_EL0.SEL selects an event counter, this accesses a PMEVTYPER<n>_EL0 register. When PMSELR_EL0.SEL selects the cycle counter, this accesses PMCCFILTR_EL0.
namespace pmxevtyper_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmxevtyper_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmxevtyper_el0, val) }

	namespace event_type_register_or_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmxevtyper_el0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t pmxevtyper_el0_val) noexcept { GET_BITFIELD_FUNC(pmxevtyper_el0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmxevtyper_el0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t pmxevtyper_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmxevtyper_el0, value, 0xffffffff, 0) }
	}
}

// REVIDR_EL1 (Revision ID Register)
// Provides implementation-specific minor revision information.
namespace revidr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(revidr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(revidr_el1, val) }
}

// RMR_EL1 (Reset Management Register (EL1))
// See the ARMv8 architecture reference manual for a description of this register
namespace rmr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(rmr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(rmr_el1, val) }

	namespace rr
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(rmr_el1, 1) }
		inline uint32_t is_enabled(uint32_t rmr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(rmr_el1_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(rmr_el1, 1) }
		inline uint32_t is_disabled(uint32_t rmr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(rmr_el1_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(rmr_el1, 0x2) }
		inline uint32_t enable(uint32_t rmr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(rmr_el1_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(rmr_el1, 0x2) }
		inline uint32_t disable(uint32_t rmr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(rmr_el1_val, 0x2) }
	}

	namespace aa64
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(rmr_el1, 0) }
		inline uint32_t is_enabled(uint32_t rmr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(rmr_el1_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(rmr_el1, 0) }
		inline uint32_t is_disabled(uint32_t rmr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(rmr_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(rmr_el1, 0x1) }
		inline uint32_t enable(uint32_t rmr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(rmr_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(rmr_el1, 0x1) }
		inline uint32_t disable(uint32_t rmr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(rmr_el1_val, 0x1) }
	}
}

// RMR_EL2 (Reset Management Register (EL2))
// See the ARMv8 architecture reference manual for a description of this register
namespace rmr_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(rmr_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(rmr_el2, val) }

	namespace rr
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(rmr_el2, 1) }
		inline uint32_t is_enabled(uint32_t rmr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(rmr_el2_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(rmr_el2, 1) }
		inline uint32_t is_disabled(uint32_t rmr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(rmr_el2_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(rmr_el2, 0x2) }
		inline uint32_t enable(uint32_t rmr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(rmr_el2_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(rmr_el2, 0x2) }
		inline uint32_t disable(uint32_t rmr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(rmr_el2_val, 0x2) }
	}

	namespace aa64
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(rmr_el2, 0) }
		inline uint32_t is_enabled(uint32_t rmr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(rmr_el2_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(rmr_el2, 0) }
		inline uint32_t is_disabled(uint32_t rmr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(rmr_el2_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(rmr_el2, 0x1) }
		inline uint32_t enable(uint32_t rmr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(rmr_el2_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(rmr_el2, 0x1) }
		inline uint32_t disable(uint32_t rmr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(rmr_el2_val, 0x1) }
	}
}

// RMR_EL3 (Reset Management Register (EL3))
// See the ARMv8 architecture reference manual for a description of this register
namespace rmr_el3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(rmr_el3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(rmr_el3, val) }

	namespace rr
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(rmr_el3, 1) }
		inline uint32_t is_enabled(uint32_t rmr_el3_val) noexcept { IS_BIT_ENABLED_FUNC(rmr_el3_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(rmr_el3, 1) }
		inline uint32_t is_disabled(uint32_t rmr_el3_val) noexcept { IS_BIT_DISABLED_FUNC(rmr_el3_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(rmr_el3, 0x2) }
		inline uint32_t enable(uint32_t rmr_el3_val) noexcept { SET_BITS_BY_MASK_FUNC(rmr_el3_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(rmr_el3, 0x2) }
		inline uint32_t disable(uint32_t rmr_el3_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(rmr_el3_val, 0x2) }
	}

	namespace aa64
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(rmr_el3, 0) }
		inline uint32_t is_enabled(uint32_t rmr_el3_val) noexcept { IS_BIT_ENABLED_FUNC(rmr_el3_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(rmr_el3, 0) }
		inline uint32_t is_disabled(uint32_t rmr_el3_val) noexcept { IS_BIT_DISABLED_FUNC(rmr_el3_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(rmr_el3, 0x1) }
		inline uint32_t enable(uint32_t rmr_el3_val) noexcept { SET_BITS_BY_MASK_FUNC(rmr_el3_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(rmr_el3, 0x1) }
		inline uint32_t disable(uint32_t rmr_el3_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(rmr_el3_val, 0x1) }
	}
}

// RVBAR_EL1 (Reset Vector Base Address Register (if EL2 and EL3 not implemented))
// If EL1 is the highest Exception level implemented, contains the IMPLEMENTATION DEFINED address that execution starts from after reset when executing in AArch64 state.
namespace rvbar_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(rvbar_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(rvbar_el1, val) }

	namespace reset_address
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(rvbar_el1, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t rvbar_el1_val) noexcept { GET_BITFIELD_FUNC(rvbar_el1_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(rvbar_el1, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t rvbar_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(rvbar_el1, value, 0xffffffffffffffff, 0) }
	}
}

// RVBAR_EL2 (Reset Vector Base Address Register (if EL3 not implemented))
// If EL2 is the highest Exception level implemented, contains the IMPLEMENTATION DEFINED address that execution starts from after reset when executing in AArch64 state.
namespace rvbar_el2
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(rvbar_el2) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(rvbar_el2, val) }

	namespace reset_address
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(rvbar_el2, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t rvbar_el2_val) noexcept { GET_BITFIELD_FUNC(rvbar_el2_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(rvbar_el2, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t rvbar_el2, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(rvbar_el2, value, 0xffffffffffffffff, 0) }
	}
}

// RVBAR_EL3 (Reset Vector Base Address Register (if EL3 implemented))
// If EL3 is the highest Exception level implemented, contains the IMPLEMENTATION DEFINED address that execution starts from after reset when executing in AArch64 state.
namespace rvbar_el3
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(rvbar_el3) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(rvbar_el3, val) }

	namespace reset_address
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(rvbar_el3, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t rvbar_el3_val) noexcept { GET_BITFIELD_FUNC(rvbar_el3_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(rvbar_el3, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t rvbar_el3, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(rvbar_el3, value, 0xffffffffffffffff, 0) }
	}
}

// S1_<op1>_<Cn>_<Cm>_<op2> (IMPLEMENTATION DEFINED maintenance instructions)
// This area of the System instruction encoding space is reserved for IMPLEMENTATION DEFINED System instructions.
namespace s1_<op1>_<cn>_<cm>_<op2>
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(s1_<op1>_<cn>_<cm>_<op2>) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(s1_<op1>_<cn>_<cm>_<op2>, val) }
}

// S3_<op1>_<Cn>_<Cm>_<op2> (IMPLEMENTATION DEFINED registers)
// This area of the instruction set space is reserved for IMPLEMENTATION DEFINED registers.
namespace s3_<op1>_<cn>_<cm>_<op2>
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(s3_<op1>_<cn>_<cm>_<op2>) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(s3_<op1>_<cn>_<cm>_<op2>, val) }
}

// SCR_EL3 (Secure Configuration Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace scr_el3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(scr_el3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(scr_el3, val) }
}

// SCTLR_EL1 (System Control Register (EL1))
// Provides top level control of the system, including its memory system, at EL1 and EL0.
namespace sctlr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(sctlr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(sctlr_el1, val) }
}

// SCTLR_EL2 (System Control Register (EL2))
// See the ARMv8 architecture reference manual for a description of this register
namespace sctlr_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(sctlr_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(sctlr_el2, val) }

	// Fieldset valid when: HCR_EL2.{E2H, TGE} != {1, 1}
	namespace fieldset_1
	{	}

	// Fieldset valid when: HCR_EL2.{E2H, TGE} == {1, 1}
	namespace fieldset_2
	{	}
}

// SCTLR_EL3 (System Control Register (EL3))
// Provides top level control of the system, including its memory system, at EL3.
namespace sctlr_el3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(sctlr_el3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(sctlr_el3, val) }
}

// SDER32_EL3 (AArch32 Secure Debug Enable Register)
// Allows access to the AArch32 register SDER from AArch64 state only. Its value has no effect on execution in AArch64 state.
namespace sder32_el3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(sder32_el3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(sder32_el3, val) }

	namespace suniden
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(sder32_el3, 1) }
		inline uint32_t is_enabled(uint32_t sder32_el3_val) noexcept { IS_BIT_ENABLED_FUNC(sder32_el3_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(sder32_el3, 1) }
		inline uint32_t is_disabled(uint32_t sder32_el3_val) noexcept { IS_BIT_DISABLED_FUNC(sder32_el3_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(sder32_el3, 0x2) }
		inline uint32_t enable(uint32_t sder32_el3_val) noexcept { SET_BITS_BY_MASK_FUNC(sder32_el3_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(sder32_el3, 0x2) }
		inline uint32_t disable(uint32_t sder32_el3_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(sder32_el3_val, 0x2) }
	}

	namespace suiden
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(sder32_el3, 0) }
		inline uint32_t is_enabled(uint32_t sder32_el3_val) noexcept { IS_BIT_ENABLED_FUNC(sder32_el3_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(sder32_el3, 0) }
		inline uint32_t is_disabled(uint32_t sder32_el3_val) noexcept { IS_BIT_DISABLED_FUNC(sder32_el3_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(sder32_el3, 0x1) }
		inline uint32_t enable(uint32_t sder32_el3_val) noexcept { SET_BITS_BY_MASK_FUNC(sder32_el3_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(sder32_el3, 0x1) }
		inline uint32_t disable(uint32_t sder32_el3_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(sder32_el3_val, 0x1) }
	}
}

// SP_EL0 (Stack Pointer (EL0))
// Holds the stack pointer associated with EL0. At higher Exception levels, this is used as the current stack pointer when the value of SPSel.SP is 0.
namespace sp_el0
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(sp_el0) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(sp_el0, val) }

	namespace stack_pointer
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(sp_el0, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t sp_el0_val) noexcept { GET_BITFIELD_FUNC(sp_el0_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(sp_el0, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t sp_el0, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(sp_el0, value, 0xffffffffffffffff, 0) }
	}
}

// SP_EL1 (Stack Pointer (EL1))
// See the ARMv8 architecture reference manual for a description of this register
namespace sp_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(sp_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(sp_el1, val) }

	namespace stack_pointer
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(sp_el1, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t sp_el1_val) noexcept { GET_BITFIELD_FUNC(sp_el1_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(sp_el1, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t sp_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(sp_el1, value, 0xffffffffffffffff, 0) }
	}
}

// SP_EL2 (Stack Pointer (EL2))
// See the ARMv8 architecture reference manual for a description of this register
namespace sp_el2
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(sp_el2) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(sp_el2, val) }

	namespace stack_pointer
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(sp_el2, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t sp_el2_val) noexcept { GET_BITFIELD_FUNC(sp_el2_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(sp_el2, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t sp_el2, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(sp_el2, value, 0xffffffffffffffff, 0) }
	}
}

// SP_EL3 (Stack Pointer (EL3))
// See the ARMv8 architecture reference manual for a description of this register
namespace sp_el3
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(sp_el3) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(sp_el3, val) }

	namespace stack_pointer
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(sp_el3, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t sp_el3_val) noexcept { GET_BITFIELD_FUNC(sp_el3_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(sp_el3, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t sp_el3, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(sp_el3, value, 0xffffffffffffffff, 0) }
	}
}

// SPSel (Stack Pointer Select)
// Allows the Stack Pointer to be selected between SP_EL0 and SP_ELx.
namespace spsel
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(spsel) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(spsel, val) }

	namespace sp
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(spsel, 0) }
		inline uint32_t is_enabled(uint32_t spsel_val) noexcept { IS_BIT_ENABLED_FUNC(spsel_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(spsel, 0) }
		inline uint32_t is_disabled(uint32_t spsel_val) noexcept { IS_BIT_DISABLED_FUNC(spsel_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(spsel, 0x1) }
		inline uint32_t enable(uint32_t spsel_val) noexcept { SET_BITS_BY_MASK_FUNC(spsel_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(spsel, 0x1) }
		inline uint32_t disable(uint32_t spsel_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(spsel_val, 0x1) }
	}
}

// SPSR_abt (Saved Program Status Register (Abort mode))
// Holds the saved process state when an exception is taken to Abort mode.
namespace spsr_abt
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(spsr_abt) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(spsr_abt, val) }
}

// SPSR_EL1 (Saved Program Status Register (EL1))
// Holds the saved process state when an exception is taken to EL1.
namespace spsr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(spsr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(spsr_el1, val) }

	// Fieldset valid when: exception taken from AArch32
	namespace fieldset_1
	{	}

	// Fieldset valid when: exception taken from AArch64
	namespace fieldset_2
	{	}
}

// SPSR_EL2 (Saved Program Status Register (EL2))
// Holds the saved process state when an exception is taken to EL2.
namespace spsr_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(spsr_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(spsr_el2, val) }

	// Fieldset valid when: exception taken from AArch32
	namespace fieldset_1
	{	}

	// Fieldset valid when: exception taken from AArch64
	namespace fieldset_2
	{	}
}

// SPSR_EL3 (Saved Program Status Register (EL3))
// Holds the saved process state when an exception is taken to EL3.
namespace spsr_el3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(spsr_el3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(spsr_el3, val) }

	// Fieldset valid when: exception taken from AArch32
	namespace fieldset_1
	{	}

	// Fieldset valid when: exception taken from AArch64
	namespace fieldset_2
	{	}
}

// SPSR_fiq (Saved Program Status Register (FIQ mode))
// Holds the saved process state when an exception is taken to FIQ mode.
namespace spsr_fiq
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(spsr_fiq) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(spsr_fiq, val) }
}

// SPSR_irq (Saved Program Status Register (IRQ mode))
// Holds the saved process state when an exception is taken to IRQ mode.
namespace spsr_irq
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(spsr_irq) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(spsr_irq, val) }
}

// SPSR_und (Saved Program Status Register (Undefined mode))
// Holds the saved process state when an exception is taken to Undefined mode.
namespace spsr_und
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(spsr_und) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(spsr_und, val) }
}

// TCR_EL1 (Translation Control Register (EL1))
// The control register for stage 1 of the EL1&0 translation regime.
namespace tcr_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tcr_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tcr_el1, val) }
}

// TCR_EL2 (Translation Control Register (EL2))
// See the ARMv8 architecture reference manual for a description of this register
namespace tcr_el2
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tcr_el2) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tcr_el2, val) }

	// Fieldset valid when: HCR_EL2.E2H==0
	namespace fieldset_1
	{	}

	// Fieldset valid when: HCR_EL2.E2H==1
	namespace fieldset_2
	{	}
}

// TCR_EL3 (Translation Control Register (EL3))
// The control register for stage 1 of the EL3 translation regime.
namespace tcr_el3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tcr_el3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tcr_el3, val) }
}

// TLBI ALLE1 (TLB Invalidate All, EL1)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi alle1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbi alle1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi alle1, val) }
}

// TLBI ALLE1IS (TLB Invalidate All, EL1, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi alle1is
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbi alle1is) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi alle1is, val) }
}

// TLBI ALLE2 (TLB Invalidate All, EL2)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi alle2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbi alle2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi alle2, val) }
}

// TLBI ALLE2IS (TLB Invalidate All, EL2, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi alle2is
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbi alle2is) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi alle2is, val) }
}

// TLBI ALLE3 (TLB Invalidate All, EL3)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi alle3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbi alle3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi alle3, val) }
}

// TLBI ALLE3IS (TLB Invalidate All, EL3, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi alle3is
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbi alle3is) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi alle3is, val) }
}

// TLBI ASIDE1 (TLB Invalidate by ASID, EL1)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi aside1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tlbi aside1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi aside1, val) }

	namespace asid
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbi aside1, 0xffff000000000000, 48) }
		inline uint64_t get(uint64_t tlbi aside1_val) noexcept { GET_BITFIELD_FUNC(tlbi aside1_val, 0xffff000000000000, 48) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbi aside1, value, 0xffff000000000000, 48) }
		inline uint64_t set(uint64_t tlbi aside1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbi aside1, value, 0xffff000000000000, 48) }
	}
}

// TLBI ASIDE1IS (TLB Invalidate by ASID, EL1, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi aside1is
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tlbi aside1is) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi aside1is, val) }

	namespace asid
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbi aside1is, 0xffff000000000000, 48) }
		inline uint64_t get(uint64_t tlbi aside1is_val) noexcept { GET_BITFIELD_FUNC(tlbi aside1is_val, 0xffff000000000000, 48) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbi aside1is, value, 0xffff000000000000, 48) }
		inline uint64_t set(uint64_t tlbi aside1is, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbi aside1is, value, 0xffff000000000000, 48) }
	}
}

// TLBI IPAS2E1 (TLB Invalidate by Intermediate Physical Address, Stage 2, EL1)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi ipas2e1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tlbi ipas2e1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi ipas2e1, val) }
}

// TLBI IPAS2E1IS (TLB Invalidate by Intermediate Physical Address, Stage 2, EL1, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi ipas2e1is
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tlbi ipas2e1is) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi ipas2e1is, val) }
}

// TLBI IPAS2LE1 (TLB Invalidate by Intermediate Physical Address, Stage 2, Last level, EL1)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi ipas2le1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tlbi ipas2le1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi ipas2le1, val) }
}

// TLBI IPAS2LE1IS (TLB Invalidate by Intermediate Physical Address, Stage 2, Last level, EL1, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi ipas2le1is
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tlbi ipas2le1is) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi ipas2le1is, val) }
}

// TLBI VAAE1 (TLB Invalidate by VA, All ASID, EL1)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi vaae1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tlbi vaae1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi vaae1, val) }

	namespace va_55:12_
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbi vaae1, 0xfffffffffff, 0) }
		inline uint64_t get(uint64_t tlbi vaae1_val) noexcept { GET_BITFIELD_FUNC(tlbi vaae1_val, 0xfffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbi vaae1, value, 0xfffffffffff, 0) }
		inline uint64_t set(uint64_t tlbi vaae1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbi vaae1, value, 0xfffffffffff, 0) }
	}
}

// TLBI VAAE1IS (TLB Invalidate by VA, All ASID, EL1, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi vaae1is
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tlbi vaae1is) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi vaae1is, val) }

	namespace va_55:12_
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbi vaae1is, 0xfffffffffff, 0) }
		inline uint64_t get(uint64_t tlbi vaae1is_val) noexcept { GET_BITFIELD_FUNC(tlbi vaae1is_val, 0xfffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbi vaae1is, value, 0xfffffffffff, 0) }
		inline uint64_t set(uint64_t tlbi vaae1is, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbi vaae1is, value, 0xfffffffffff, 0) }
	}
}

// TLBI VAALE1 (TLB Invalidate by VA, All ASID, Last level, EL1)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi vaale1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tlbi vaale1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi vaale1, val) }

	namespace va_55:12_
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbi vaale1, 0xfffffffffff, 0) }
		inline uint64_t get(uint64_t tlbi vaale1_val) noexcept { GET_BITFIELD_FUNC(tlbi vaale1_val, 0xfffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbi vaale1, value, 0xfffffffffff, 0) }
		inline uint64_t set(uint64_t tlbi vaale1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbi vaale1, value, 0xfffffffffff, 0) }
	}
}

// TLBI VAALE1IS (TLB Invalidate by VA, All ASID, Last Level, EL1, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi vaale1is
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tlbi vaale1is) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi vaale1is, val) }

	namespace va_55:12_
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbi vaale1is, 0xfffffffffff, 0) }
		inline uint64_t get(uint64_t tlbi vaale1is_val) noexcept { GET_BITFIELD_FUNC(tlbi vaale1is_val, 0xfffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbi vaale1is, value, 0xfffffffffff, 0) }
		inline uint64_t set(uint64_t tlbi vaale1is, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbi vaale1is, value, 0xfffffffffff, 0) }
	}
}

// TLBI VAE1 (TLB Invalidate by VA, EL1)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi vae1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tlbi vae1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi vae1, val) }

	namespace asid
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbi vae1, 0xffff000000000000, 48) }
		inline uint64_t get(uint64_t tlbi vae1_val) noexcept { GET_BITFIELD_FUNC(tlbi vae1_val, 0xffff000000000000, 48) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbi vae1, value, 0xffff000000000000, 48) }
		inline uint64_t set(uint64_t tlbi vae1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbi vae1, value, 0xffff000000000000, 48) }
	}

	namespace va_55:12_
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbi vae1, 0xfffffffffff, 0) }
		inline uint64_t get(uint64_t tlbi vae1_val) noexcept { GET_BITFIELD_FUNC(tlbi vae1_val, 0xfffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbi vae1, value, 0xfffffffffff, 0) }
		inline uint64_t set(uint64_t tlbi vae1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbi vae1, value, 0xfffffffffff, 0) }
	}
}

// TLBI VAE1IS (TLB Invalidate by VA, EL1, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi vae1is
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tlbi vae1is) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi vae1is, val) }

	namespace asid
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbi vae1is, 0xffff000000000000, 48) }
		inline uint64_t get(uint64_t tlbi vae1is_val) noexcept { GET_BITFIELD_FUNC(tlbi vae1is_val, 0xffff000000000000, 48) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbi vae1is, value, 0xffff000000000000, 48) }
		inline uint64_t set(uint64_t tlbi vae1is, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbi vae1is, value, 0xffff000000000000, 48) }
	}

	namespace va_55:12_
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbi vae1is, 0xfffffffffff, 0) }
		inline uint64_t get(uint64_t tlbi vae1is_val) noexcept { GET_BITFIELD_FUNC(tlbi vae1is_val, 0xfffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbi vae1is, value, 0xfffffffffff, 0) }
		inline uint64_t set(uint64_t tlbi vae1is, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbi vae1is, value, 0xfffffffffff, 0) }
	}
}

// TLBI VAE2 (TLB Invalidate by VA, EL2)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi vae2
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tlbi vae2) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi vae2, val) }

	namespace va_55:12_
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbi vae2, 0xfffffffffff, 0) }
		inline uint64_t get(uint64_t tlbi vae2_val) noexcept { GET_BITFIELD_FUNC(tlbi vae2_val, 0xfffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbi vae2, value, 0xfffffffffff, 0) }
		inline uint64_t set(uint64_t tlbi vae2, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbi vae2, value, 0xfffffffffff, 0) }
	}
}

// TLBI VAE2IS (TLB Invalidate by VA, EL2, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi vae2is
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tlbi vae2is) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi vae2is, val) }

	namespace va_55:12_
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbi vae2is, 0xfffffffffff, 0) }
		inline uint64_t get(uint64_t tlbi vae2is_val) noexcept { GET_BITFIELD_FUNC(tlbi vae2is_val, 0xfffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbi vae2is, value, 0xfffffffffff, 0) }
		inline uint64_t set(uint64_t tlbi vae2is, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbi vae2is, value, 0xfffffffffff, 0) }
	}
}

// TLBI VAE3 (TLB Invalidate by VA, EL3)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi vae3
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tlbi vae3) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi vae3, val) }

	namespace va_55:12_
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbi vae3, 0xfffffffffff, 0) }
		inline uint64_t get(uint64_t tlbi vae3_val) noexcept { GET_BITFIELD_FUNC(tlbi vae3_val, 0xfffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbi vae3, value, 0xfffffffffff, 0) }
		inline uint64_t set(uint64_t tlbi vae3, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbi vae3, value, 0xfffffffffff, 0) }
	}
}

// TLBI VAE3IS (TLB Invalidate by VA, EL3, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi vae3is
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tlbi vae3is) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi vae3is, val) }

	namespace va_55:12_
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbi vae3is, 0xfffffffffff, 0) }
		inline uint64_t get(uint64_t tlbi vae3is_val) noexcept { GET_BITFIELD_FUNC(tlbi vae3is_val, 0xfffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbi vae3is, value, 0xfffffffffff, 0) }
		inline uint64_t set(uint64_t tlbi vae3is, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbi vae3is, value, 0xfffffffffff, 0) }
	}
}

// TLBI VALE1 (TLB Invalidate by VA, Last level, EL1)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi vale1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tlbi vale1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi vale1, val) }

	namespace asid
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbi vale1, 0xffff000000000000, 48) }
		inline uint64_t get(uint64_t tlbi vale1_val) noexcept { GET_BITFIELD_FUNC(tlbi vale1_val, 0xffff000000000000, 48) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbi vale1, value, 0xffff000000000000, 48) }
		inline uint64_t set(uint64_t tlbi vale1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbi vale1, value, 0xffff000000000000, 48) }
	}

	namespace va_55:12_
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbi vale1, 0xfffffffffff, 0) }
		inline uint64_t get(uint64_t tlbi vale1_val) noexcept { GET_BITFIELD_FUNC(tlbi vale1_val, 0xfffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbi vale1, value, 0xfffffffffff, 0) }
		inline uint64_t set(uint64_t tlbi vale1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbi vale1, value, 0xfffffffffff, 0) }
	}
}

// TLBI VALE1IS (TLB Invalidate by VA, Last level, EL1, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi vale1is
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tlbi vale1is) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi vale1is, val) }

	namespace asid
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbi vale1is, 0xffff000000000000, 48) }
		inline uint64_t get(uint64_t tlbi vale1is_val) noexcept { GET_BITFIELD_FUNC(tlbi vale1is_val, 0xffff000000000000, 48) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbi vale1is, value, 0xffff000000000000, 48) }
		inline uint64_t set(uint64_t tlbi vale1is, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbi vale1is, value, 0xffff000000000000, 48) }
	}

	namespace va_55:12_
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbi vale1is, 0xfffffffffff, 0) }
		inline uint64_t get(uint64_t tlbi vale1is_val) noexcept { GET_BITFIELD_FUNC(tlbi vale1is_val, 0xfffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbi vale1is, value, 0xfffffffffff, 0) }
		inline uint64_t set(uint64_t tlbi vale1is, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbi vale1is, value, 0xfffffffffff, 0) }
	}
}

// TLBI VALE2 (TLB Invalidate by VA, Last level, EL2)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi vale2
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tlbi vale2) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi vale2, val) }

	namespace va_55:12_
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbi vale2, 0xfffffffffff, 0) }
		inline uint64_t get(uint64_t tlbi vale2_val) noexcept { GET_BITFIELD_FUNC(tlbi vale2_val, 0xfffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbi vale2, value, 0xfffffffffff, 0) }
		inline uint64_t set(uint64_t tlbi vale2, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbi vale2, value, 0xfffffffffff, 0) }
	}
}

// TLBI VALE2IS (TLB Invalidate by VA, Last level, EL2, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi vale2is
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tlbi vale2is) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi vale2is, val) }

	namespace va_55:12_
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbi vale2is, 0xfffffffffff, 0) }
		inline uint64_t get(uint64_t tlbi vale2is_val) noexcept { GET_BITFIELD_FUNC(tlbi vale2is_val, 0xfffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbi vale2is, value, 0xfffffffffff, 0) }
		inline uint64_t set(uint64_t tlbi vale2is, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbi vale2is, value, 0xfffffffffff, 0) }
	}
}

// TLBI VALE3 (TLB Invalidate by VA, Last level, EL3)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi vale3
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tlbi vale3) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi vale3, val) }

	namespace va_55:12_
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbi vale3, 0xfffffffffff, 0) }
		inline uint64_t get(uint64_t tlbi vale3_val) noexcept { GET_BITFIELD_FUNC(tlbi vale3_val, 0xfffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbi vale3, value, 0xfffffffffff, 0) }
		inline uint64_t set(uint64_t tlbi vale3, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbi vale3, value, 0xfffffffffff, 0) }
	}
}

// TLBI VALE3IS (TLB Invalidate by VA, Last level, EL3, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi vale3is
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tlbi vale3is) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi vale3is, val) }

	namespace va_55:12_
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tlbi vale3is, 0xfffffffffff, 0) }
		inline uint64_t get(uint64_t tlbi vale3is_val) noexcept { GET_BITFIELD_FUNC(tlbi vale3is_val, 0xfffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tlbi vale3is, value, 0xfffffffffff, 0) }
		inline uint64_t set(uint64_t tlbi vale3is, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tlbi vale3is, value, 0xfffffffffff, 0) }
	}
}

// TLBI VMALLE1 (TLB Invalidate by VMID, All at stage 1, EL1)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi vmalle1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbi vmalle1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi vmalle1, val) }
}

// TLBI VMALLE1IS (TLB Invalidate by VMID, All at stage 1, EL1, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi vmalle1is
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbi vmalle1is) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi vmalle1is, val) }
}

// TLBI VMALLS12E1 (TLB Invalidate by VMID, All at Stage 1 and 2, EL1)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi vmalls12e1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbi vmalls12e1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi vmalls12e1, val) }
}

// TLBI VMALLS12E1IS (TLB Invalidate by VMID, All at Stage 1 and 2, EL1, Inner Shareable)
// See the ARMv8 architecture reference manual for a description of this register
namespace tlbi vmalls12e1is
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(tlbi vmalls12e1is) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tlbi vmalls12e1is, val) }
}

// TPIDR_EL0 (EL0 Read/Write Software Thread ID Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace tpidr_el0
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tpidr_el0) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tpidr_el0, val) }

	namespace thread_id
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tpidr_el0, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t tpidr_el0_val) noexcept { GET_BITFIELD_FUNC(tpidr_el0_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tpidr_el0, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t tpidr_el0, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tpidr_el0, value, 0xffffffffffffffff, 0) }
	}
}

// TPIDR_EL1 (EL1 Software Thread ID Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace tpidr_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tpidr_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tpidr_el1, val) }

	namespace thread_id
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tpidr_el1, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t tpidr_el1_val) noexcept { GET_BITFIELD_FUNC(tpidr_el1_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tpidr_el1, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t tpidr_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tpidr_el1, value, 0xffffffffffffffff, 0) }
	}
}

// TPIDR_EL2 (EL2 Software Thread ID Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace tpidr_el2
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tpidr_el2) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tpidr_el2, val) }

	namespace thread_id
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tpidr_el2, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t tpidr_el2_val) noexcept { GET_BITFIELD_FUNC(tpidr_el2_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tpidr_el2, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t tpidr_el2, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tpidr_el2, value, 0xffffffffffffffff, 0) }
	}
}

// TPIDR_EL3 (EL3 Software Thread ID Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace tpidr_el3
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tpidr_el3) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tpidr_el3, val) }

	namespace thread_id
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tpidr_el3, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t tpidr_el3_val) noexcept { GET_BITFIELD_FUNC(tpidr_el3_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tpidr_el3, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t tpidr_el3, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tpidr_el3, value, 0xffffffffffffffff, 0) }
	}
}

// TPIDRRO_EL0 (EL0 Read-Only Software Thread ID Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace tpidrro_el0
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(tpidrro_el0) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(tpidrro_el0, val) }

	namespace thread_id
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(tpidrro_el0, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t tpidrro_el0_val) noexcept { GET_BITFIELD_FUNC(tpidrro_el0_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(tpidrro_el0, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t tpidrro_el0, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(tpidrro_el0, value, 0xffffffffffffffff, 0) }
	}
}

// TTBR0_EL1 (Translation Table Base Register 0 (EL1))
// Holds the base address of the translation table for the initial lookup for stage 1 of the translation of an address from the lower VA range in the EL1&0 translation regime, and other information for this translation regime.
namespace ttbr0_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(ttbr0_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ttbr0_el1, val) }
}

// TTBR0_EL2 (Translation Table Base Register 0 (EL2))
// See the ARMv8 architecture reference manual for a description of this register
namespace ttbr0_el2
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(ttbr0_el2) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ttbr0_el2, val) }
}

// TTBR0_EL3 (Translation Table Base Register 0 (EL3))
// Holds the base address of the translation table for the initial lookup for stage 1 of an address translation in the EL3 translation regime, and other information for this translation regime.
namespace ttbr0_el3
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(ttbr0_el3) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ttbr0_el3, val) }
}

// TTBR1_EL1 (Translation Table Base Register 1 (EL1))
// Holds the base address of the translation table for the initial lookup for stage 1 of the translation of an address from the higher VA range in the EL1&0 stage 1 translation regime, and other information for this translation regime.
namespace ttbr1_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(ttbr1_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ttbr1_el1, val) }
}

// TTBR1_EL2 (Translation Table Base Register 1 (EL2))
// See the ARMv8 architecture reference manual for a description of this register
namespace ttbr1_el2
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(ttbr1_el2) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ttbr1_el2, val) }
}

// UAO (User Access Override)
// See the ARMv8 architecture reference manual for a description of this register
namespace uao
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(uao) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(uao, val) }

	namespace uao
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(uao, 23) }
		inline uint32_t is_enabled(uint32_t uao_val) noexcept { IS_BIT_ENABLED_FUNC(uao_val, 23) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(uao, 23) }
		inline uint32_t is_disabled(uint32_t uao_val) noexcept { IS_BIT_DISABLED_FUNC(uao_val, 23) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(uao, 0x800000) }
		inline uint32_t enable(uint32_t uao_val) noexcept { SET_BITS_BY_MASK_FUNC(uao_val, 0x800000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(uao, 0x800000) }
		inline uint32_t disable(uint32_t uao_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(uao_val, 0x800000) }
	}
}

// VBAR_EL1 (Vector Base Address Register (EL1))
// Holds the vector base address for any exception that is taken to EL1.
namespace vbar_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(vbar_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(vbar_el1, val) }

	namespace vector_base_address
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(vbar_el1, 0xfffffffffffff800, 11) }
		inline uint64_t get(uint64_t vbar_el1_val) noexcept { GET_BITFIELD_FUNC(vbar_el1_val, 0xfffffffffffff800, 11) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(vbar_el1, value, 0xfffffffffffff800, 11) }
		inline uint64_t set(uint64_t vbar_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(vbar_el1, value, 0xfffffffffffff800, 11) }
	}
}

// VBAR_EL2 (Vector Base Address Register (EL2))
// Holds the vector base address for any exception that is taken to EL2.
namespace vbar_el2
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(vbar_el2) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(vbar_el2, val) }

	namespace vector_base_address
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(vbar_el2, 0xfffffffffffff800, 11) }
		inline uint64_t get(uint64_t vbar_el2_val) noexcept { GET_BITFIELD_FUNC(vbar_el2_val, 0xfffffffffffff800, 11) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(vbar_el2, value, 0xfffffffffffff800, 11) }
		inline uint64_t set(uint64_t vbar_el2, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(vbar_el2, value, 0xfffffffffffff800, 11) }
	}
}

// VBAR_EL3 (Vector Base Address Register (EL3))
// Holds the vector base address for any exception that is taken to EL3.
namespace vbar_el3
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(vbar_el3) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(vbar_el3, val) }

	namespace vector_base_address
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(vbar_el3, 0xfffffffffffff800, 11) }
		inline uint64_t get(uint64_t vbar_el3_val) noexcept { GET_BITFIELD_FUNC(vbar_el3_val, 0xfffffffffffff800, 11) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(vbar_el3, value, 0xfffffffffffff800, 11) }
		inline uint64_t set(uint64_t vbar_el3, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(vbar_el3, value, 0xfffffffffffff800, 11) }
	}
}

// VMPIDR_EL2 (Virtualization Multiprocessor ID Register)
// Holds the value of the Virtualization Multiprocessor ID. This is the value returned by Non-secure EL1 reads of MPIDR_EL1.
namespace vmpidr_el2
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(vmpidr_el2) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(vmpidr_el2, val) }

	namespace aff3
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(vmpidr_el2, 0xff00000000, 32) }
		inline uint64_t get(uint64_t vmpidr_el2_val) noexcept { GET_BITFIELD_FUNC(vmpidr_el2_val, 0xff00000000, 32) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(vmpidr_el2, value, 0xff00000000, 32) }
		inline uint64_t set(uint64_t vmpidr_el2, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(vmpidr_el2, value, 0xff00000000, 32) }
	}

	namespace u
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(vmpidr_el2, 30) }
		inline uint64_t is_enabled(uint64_t vmpidr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(vmpidr_el2_val, 30) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(vmpidr_el2, 30) }
		inline uint64_t is_disabled(uint64_t vmpidr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(vmpidr_el2_val, 30) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(vmpidr_el2, 0x40000000) }
		inline uint64_t enable(uint64_t vmpidr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(vmpidr_el2_val, 0x40000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(vmpidr_el2, 0x40000000) }
		inline uint64_t disable(uint64_t vmpidr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(vmpidr_el2_val, 0x40000000) }
	}

	namespace mt
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(vmpidr_el2, 24) }
		inline uint64_t is_enabled(uint64_t vmpidr_el2_val) noexcept { IS_BIT_ENABLED_FUNC(vmpidr_el2_val, 24) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(vmpidr_el2, 24) }
		inline uint64_t is_disabled(uint64_t vmpidr_el2_val) noexcept { IS_BIT_DISABLED_FUNC(vmpidr_el2_val, 24) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(vmpidr_el2, 0x1000000) }
		inline uint64_t enable(uint64_t vmpidr_el2_val) noexcept { SET_BITS_BY_MASK_FUNC(vmpidr_el2_val, 0x1000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(vmpidr_el2, 0x1000000) }
		inline uint64_t disable(uint64_t vmpidr_el2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(vmpidr_el2_val, 0x1000000) }
	}

	namespace aff2
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(vmpidr_el2, 0xff0000, 16) }
		inline uint64_t get(uint64_t vmpidr_el2_val) noexcept { GET_BITFIELD_FUNC(vmpidr_el2_val, 0xff0000, 16) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(vmpidr_el2, value, 0xff0000, 16) }
		inline uint64_t set(uint64_t vmpidr_el2, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(vmpidr_el2, value, 0xff0000, 16) }
	}

	namespace aff1
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(vmpidr_el2, 0xff00, 8) }
		inline uint64_t get(uint64_t vmpidr_el2_val) noexcept { GET_BITFIELD_FUNC(vmpidr_el2_val, 0xff00, 8) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(vmpidr_el2, value, 0xff00, 8) }
		inline uint64_t set(uint64_t vmpidr_el2, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(vmpidr_el2, value, 0xff00, 8) }
	}

	namespace aff0
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(vmpidr_el2, 0xff, 0) }
		inline uint64_t get(uint64_t vmpidr_el2_val) noexcept { GET_BITFIELD_FUNC(vmpidr_el2_val, 0xff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(vmpidr_el2, value, 0xff, 0) }
		inline uint64_t set(uint64_t vmpidr_el2, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(vmpidr_el2, value, 0xff, 0) }
	}
}

// VPIDR_EL2 (Virtualization Processor ID Register)
// Holds the value of the Virtualization Processor ID. This is the value returned by Non-secure EL1 reads of MIDR_EL1.
namespace vpidr_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(vpidr_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(vpidr_el2, val) }

	namespace implementer
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(vpidr_el2, 0xff000000, 24) }
		inline uint32_t get(uint32_t vpidr_el2_val) noexcept { GET_BITFIELD_FUNC(vpidr_el2_val, 0xff000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(vpidr_el2, value, 0xff000000, 24) }
		inline uint32_t set(uint32_t vpidr_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(vpidr_el2, value, 0xff000000, 24) }
	}

	namespace variant
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(vpidr_el2, 0xf00000, 20) }
		inline uint32_t get(uint32_t vpidr_el2_val) noexcept { GET_BITFIELD_FUNC(vpidr_el2_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(vpidr_el2, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t vpidr_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(vpidr_el2, value, 0xf00000, 20) }
	}

	namespace architecture
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(vpidr_el2, 0xf0000, 16) }
		inline uint32_t get(uint32_t vpidr_el2_val) noexcept { GET_BITFIELD_FUNC(vpidr_el2_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(vpidr_el2, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t vpidr_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(vpidr_el2, value, 0xf0000, 16) }
	}

	namespace partnum
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(vpidr_el2, 0xfff0, 4) }
		inline uint32_t get(uint32_t vpidr_el2_val) noexcept { GET_BITFIELD_FUNC(vpidr_el2_val, 0xfff0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(vpidr_el2, value, 0xfff0, 4) }
		inline uint32_t set(uint32_t vpidr_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(vpidr_el2, value, 0xfff0, 4) }
	}

	namespace revision
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(vpidr_el2, 0xf, 0) }
		inline uint32_t get(uint32_t vpidr_el2_val) noexcept { GET_BITFIELD_FUNC(vpidr_el2_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(vpidr_el2, value, 0xf, 0) }
		inline uint32_t set(uint32_t vpidr_el2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(vpidr_el2, value, 0xf, 0) }
	}
}

// VTCR_EL2 (Virtualization Translation Control Register)
// The control register for stage 2 of the EL1&0 translation regime.
namespace vtcr_el2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(vtcr_el2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(vtcr_el2, val) }
}

// VTTBR_EL2 (Virtualization Translation Table Base Register)
// Holds the base address of the translation table for the initial lookup for stage 2 of an address translation in the Non-secure EL1&0 translation regime, and other information for this translation regime.
namespace vttbr_el2
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(vttbr_el2) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(vttbr_el2, val) }
}

// ASICCTL (CTI External Multiplexer Control register)
// See the ARMv8 architecture reference manual for a description of this register
namespace asicctl
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(asicctl) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(asicctl, val) }
}

// CNTACR<n> (Counter-timer Access Control Registers)
// See the ARMv8 architecture reference manual for a description of this register
namespace cntacr<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntacr<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntacr<n>, val) }

	namespace rwpt
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntacr<n>, 5) }
		inline uint32_t is_enabled(uint32_t cntacr<n>_val) noexcept { IS_BIT_ENABLED_FUNC(cntacr<n>_val, 5) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntacr<n>, 5) }
		inline uint32_t is_disabled(uint32_t cntacr<n>_val) noexcept { IS_BIT_DISABLED_FUNC(cntacr<n>_val, 5) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntacr<n>, 0x20) }
		inline uint32_t enable(uint32_t cntacr<n>_val) noexcept { SET_BITS_BY_MASK_FUNC(cntacr<n>_val, 0x20) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntacr<n>, 0x20) }
		inline uint32_t disable(uint32_t cntacr<n>_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntacr<n>_val, 0x20) }
	}

	namespace rwvt
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntacr<n>, 4) }
		inline uint32_t is_enabled(uint32_t cntacr<n>_val) noexcept { IS_BIT_ENABLED_FUNC(cntacr<n>_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntacr<n>, 4) }
		inline uint32_t is_disabled(uint32_t cntacr<n>_val) noexcept { IS_BIT_DISABLED_FUNC(cntacr<n>_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntacr<n>, 0x10) }
		inline uint32_t enable(uint32_t cntacr<n>_val) noexcept { SET_BITS_BY_MASK_FUNC(cntacr<n>_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntacr<n>, 0x10) }
		inline uint32_t disable(uint32_t cntacr<n>_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntacr<n>_val, 0x10) }
	}

	namespace rvoff
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntacr<n>, 3) }
		inline uint32_t is_enabled(uint32_t cntacr<n>_val) noexcept { IS_BIT_ENABLED_FUNC(cntacr<n>_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntacr<n>, 3) }
		inline uint32_t is_disabled(uint32_t cntacr<n>_val) noexcept { IS_BIT_DISABLED_FUNC(cntacr<n>_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntacr<n>, 0x8) }
		inline uint32_t enable(uint32_t cntacr<n>_val) noexcept { SET_BITS_BY_MASK_FUNC(cntacr<n>_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntacr<n>, 0x8) }
		inline uint32_t disable(uint32_t cntacr<n>_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntacr<n>_val, 0x8) }
	}

	namespace rfrq
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntacr<n>, 2) }
		inline uint32_t is_enabled(uint32_t cntacr<n>_val) noexcept { IS_BIT_ENABLED_FUNC(cntacr<n>_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntacr<n>, 2) }
		inline uint32_t is_disabled(uint32_t cntacr<n>_val) noexcept { IS_BIT_DISABLED_FUNC(cntacr<n>_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntacr<n>, 0x4) }
		inline uint32_t enable(uint32_t cntacr<n>_val) noexcept { SET_BITS_BY_MASK_FUNC(cntacr<n>_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntacr<n>, 0x4) }
		inline uint32_t disable(uint32_t cntacr<n>_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntacr<n>_val, 0x4) }
	}

	namespace rvct
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntacr<n>, 1) }
		inline uint32_t is_enabled(uint32_t cntacr<n>_val) noexcept { IS_BIT_ENABLED_FUNC(cntacr<n>_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntacr<n>, 1) }
		inline uint32_t is_disabled(uint32_t cntacr<n>_val) noexcept { IS_BIT_DISABLED_FUNC(cntacr<n>_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntacr<n>, 0x2) }
		inline uint32_t enable(uint32_t cntacr<n>_val) noexcept { SET_BITS_BY_MASK_FUNC(cntacr<n>_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntacr<n>, 0x2) }
		inline uint32_t disable(uint32_t cntacr<n>_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntacr<n>_val, 0x2) }
	}

	namespace rpct
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntacr<n>, 0) }
		inline uint32_t is_enabled(uint32_t cntacr<n>_val) noexcept { IS_BIT_ENABLED_FUNC(cntacr<n>_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntacr<n>, 0) }
		inline uint32_t is_disabled(uint32_t cntacr<n>_val) noexcept { IS_BIT_DISABLED_FUNC(cntacr<n>_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntacr<n>, 0x1) }
		inline uint32_t enable(uint32_t cntacr<n>_val) noexcept { SET_BITS_BY_MASK_FUNC(cntacr<n>_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntacr<n>, 0x1) }
		inline uint32_t disable(uint32_t cntacr<n>_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntacr<n>_val, 0x1) }
	}
}

// CNTCR (Counter Control Register)
// Enables the counter, controls the counter frequency setting, and controls counter behavior during debug.
namespace cntcr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntcr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntcr, val) }

	namespace fcreq
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntcr, 0x3ff00, 8) }
		inline uint32_t get(uint32_t cntcr_val) noexcept { GET_BITFIELD_FUNC(cntcr_val, 0x3ff00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntcr, value, 0x3ff00, 8) }
		inline uint32_t set(uint32_t cntcr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntcr, value, 0x3ff00, 8) }
	}

	namespace hdbg
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntcr, 1) }
		inline uint32_t is_enabled(uint32_t cntcr_val) noexcept { IS_BIT_ENABLED_FUNC(cntcr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntcr, 1) }
		inline uint32_t is_disabled(uint32_t cntcr_val) noexcept { IS_BIT_DISABLED_FUNC(cntcr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntcr, 0x2) }
		inline uint32_t enable(uint32_t cntcr_val) noexcept { SET_BITS_BY_MASK_FUNC(cntcr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntcr, 0x2) }
		inline uint32_t disable(uint32_t cntcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntcr_val, 0x2) }
	}

	namespace en
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntcr, 0) }
		inline uint32_t is_enabled(uint32_t cntcr_val) noexcept { IS_BIT_ENABLED_FUNC(cntcr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntcr, 0) }
		inline uint32_t is_disabled(uint32_t cntcr_val) noexcept { IS_BIT_DISABLED_FUNC(cntcr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntcr, 0x1) }
		inline uint32_t enable(uint32_t cntcr_val) noexcept { SET_BITS_BY_MASK_FUNC(cntcr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntcr, 0x1) }
		inline uint32_t disable(uint32_t cntcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntcr_val, 0x1) }
	}
}

// CNTCV (Counter Count Value register)
// Indicates the current count value.
namespace cntcv
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(cntcv) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntcv, val) }

	namespace countvalue
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntcv, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t cntcv_val) noexcept { GET_BITFIELD_FUNC(cntcv_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntcv, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t cntcv, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntcv, value, 0xffffffffffffffff, 0) }
	}
}

// CNTEL0ACR (Counter-timer EL0 Access Control Register)
// An implementation of CNTEL0ACR in the frame at CNTBaseN controls whether the CNTPCT, CNTVCT, CNTFRQ, EL1 Physical Timer, and Virtual Timer registers are visible in the frame at CNTEL0BaseN.
namespace cntel0acr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntel0acr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntel0acr, val) }

	namespace el0pten
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntel0acr, 9) }
		inline uint32_t is_enabled(uint32_t cntel0acr_val) noexcept { IS_BIT_ENABLED_FUNC(cntel0acr_val, 9) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntel0acr, 9) }
		inline uint32_t is_disabled(uint32_t cntel0acr_val) noexcept { IS_BIT_DISABLED_FUNC(cntel0acr_val, 9) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntel0acr, 0x200) }
		inline uint32_t enable(uint32_t cntel0acr_val) noexcept { SET_BITS_BY_MASK_FUNC(cntel0acr_val, 0x200) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntel0acr, 0x200) }
		inline uint32_t disable(uint32_t cntel0acr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntel0acr_val, 0x200) }
	}

	namespace el0vten
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntel0acr, 8) }
		inline uint32_t is_enabled(uint32_t cntel0acr_val) noexcept { IS_BIT_ENABLED_FUNC(cntel0acr_val, 8) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntel0acr, 8) }
		inline uint32_t is_disabled(uint32_t cntel0acr_val) noexcept { IS_BIT_DISABLED_FUNC(cntel0acr_val, 8) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntel0acr, 0x100) }
		inline uint32_t enable(uint32_t cntel0acr_val) noexcept { SET_BITS_BY_MASK_FUNC(cntel0acr_val, 0x100) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntel0acr, 0x100) }
		inline uint32_t disable(uint32_t cntel0acr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntel0acr_val, 0x100) }
	}

	namespace el0vcten
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntel0acr, 1) }
		inline uint32_t is_enabled(uint32_t cntel0acr_val) noexcept { IS_BIT_ENABLED_FUNC(cntel0acr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntel0acr, 1) }
		inline uint32_t is_disabled(uint32_t cntel0acr_val) noexcept { IS_BIT_DISABLED_FUNC(cntel0acr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntel0acr, 0x2) }
		inline uint32_t enable(uint32_t cntel0acr_val) noexcept { SET_BITS_BY_MASK_FUNC(cntel0acr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntel0acr, 0x2) }
		inline uint32_t disable(uint32_t cntel0acr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntel0acr_val, 0x2) }
	}

	namespace el0pcten
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntel0acr, 0) }
		inline uint32_t is_enabled(uint32_t cntel0acr_val) noexcept { IS_BIT_ENABLED_FUNC(cntel0acr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntel0acr, 0) }
		inline uint32_t is_disabled(uint32_t cntel0acr_val) noexcept { IS_BIT_DISABLED_FUNC(cntel0acr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntel0acr, 0x1) }
		inline uint32_t enable(uint32_t cntel0acr_val) noexcept { SET_BITS_BY_MASK_FUNC(cntel0acr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntel0acr, 0x1) }
		inline uint32_t disable(uint32_t cntel0acr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntel0acr_val, 0x1) }
	}
}

// CNTFID0 (Counter Frequency ID)
// Indicates the base frequency of the system counter.
namespace cntfid0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntfid0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntfid0, val) }

	namespace frequency
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntfid0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t cntfid0_val) noexcept { GET_BITFIELD_FUNC(cntfid0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntfid0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t cntfid0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntfid0, value, 0xffffffff, 0) }
	}
}

// CNTFID<n> (Counter Frequency IDs, n > 0)
// Indicates alternative system counter update frequencies.
namespace cntfid<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntfid<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntfid<n>, val) }

	namespace frequency
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntfid<n>, 0xffffffff, 0) }
		inline uint32_t get(uint32_t cntfid<n>_val) noexcept { GET_BITFIELD_FUNC(cntfid<n>_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntfid<n>, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t cntfid<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntfid<n>, value, 0xffffffff, 0) }
	}
}

// CNTFRQ (Counter-timer Frequency)
// This register is provided so that software can discover the frequency of the system counter. The instance of the register in the CNTCTLBase frame must be programmed with this value as part of system initialization. The value of the register is not interpreted by hardware.
namespace cntfrq
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntfrq) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntfrq, val) }

	namespace clock_frequency
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntfrq, 0xffffffff, 0) }
		inline uint32_t get(uint32_t cntfrq_val) noexcept { GET_BITFIELD_FUNC(cntfrq_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntfrq, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t cntfrq, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntfrq, value, 0xffffffff, 0) }
	}
}

// CNTNSAR (Counter-timer Non-secure Access Register)
// Provides the highest-level control of whether frames CNTBaseN and CNTEL0BaseN are accessible by Non-secure accesses.
namespace cntnsar
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntnsar) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntnsar, val) }

	namespace ns_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntnsar, 0xff, 0) }
		inline uint32_t get(uint32_t cntnsar_val) noexcept { GET_BITFIELD_FUNC(cntnsar_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntnsar, value, 0xff, 0) }
		inline uint32_t set(uint32_t cntnsar, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntnsar, value, 0xff, 0) }
	}
}

// CNTP_CTL (Counter-timer Physical Timer Control)
// Control register for the EL1 physical timer.
namespace cntp_ctl
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntp_ctl) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntp_ctl, val) }

	namespace istatus
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntp_ctl, 2) }
		inline uint32_t is_enabled(uint32_t cntp_ctl_val) noexcept { IS_BIT_ENABLED_FUNC(cntp_ctl_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntp_ctl, 2) }
		inline uint32_t is_disabled(uint32_t cntp_ctl_val) noexcept { IS_BIT_DISABLED_FUNC(cntp_ctl_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntp_ctl, 0x4) }
		inline uint32_t enable(uint32_t cntp_ctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cntp_ctl_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntp_ctl, 0x4) }
		inline uint32_t disable(uint32_t cntp_ctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntp_ctl_val, 0x4) }
	}

	namespace imask
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntp_ctl, 1) }
		inline uint32_t is_enabled(uint32_t cntp_ctl_val) noexcept { IS_BIT_ENABLED_FUNC(cntp_ctl_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntp_ctl, 1) }
		inline uint32_t is_disabled(uint32_t cntp_ctl_val) noexcept { IS_BIT_DISABLED_FUNC(cntp_ctl_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntp_ctl, 0x2) }
		inline uint32_t enable(uint32_t cntp_ctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cntp_ctl_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntp_ctl, 0x2) }
		inline uint32_t disable(uint32_t cntp_ctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntp_ctl_val, 0x2) }
	}

	namespace enable
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntp_ctl, 0) }
		inline uint32_t is_enabled(uint32_t cntp_ctl_val) noexcept { IS_BIT_ENABLED_FUNC(cntp_ctl_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntp_ctl, 0) }
		inline uint32_t is_disabled(uint32_t cntp_ctl_val) noexcept { IS_BIT_DISABLED_FUNC(cntp_ctl_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntp_ctl, 0x1) }
		inline uint32_t enable(uint32_t cntp_ctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cntp_ctl_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntp_ctl, 0x1) }
		inline uint32_t disable(uint32_t cntp_ctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntp_ctl_val, 0x1) }
	}
}

// CNTP_CVAL (Counter-timer Physical Timer CompareValue)
// Holds the 64-bit compare value for the EL1 physical timer.
namespace cntp_cval
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(cntp_cval) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntp_cval, val) }

	namespace comparevalue
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntp_cval, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t cntp_cval_val) noexcept { GET_BITFIELD_FUNC(cntp_cval_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntp_cval, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t cntp_cval, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntp_cval, value, 0xffffffffffffffff, 0) }
	}
}

// CNTP_TVAL (Counter-timer Physical Timer TimerValue)
// Holds the timer value for the EL1 physical timer.
namespace cntp_tval
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntp_tval) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntp_tval, val) }

	namespace timervalue
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntp_tval, 0xffffffff, 0) }
		inline uint32_t get(uint32_t cntp_tval_val) noexcept { GET_BITFIELD_FUNC(cntp_tval_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntp_tval, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t cntp_tval, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntp_tval, value, 0xffffffff, 0) }
	}
}

// CNTPCT (Counter-timer Physical Count)
// Holds the 64-bit physical count value.
namespace cntpct
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(cntpct) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntpct, val) }

	namespace physical_count_value
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntpct, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t cntpct_val) noexcept { GET_BITFIELD_FUNC(cntpct_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntpct, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t cntpct, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntpct, value, 0xffffffffffffffff, 0) }
	}
}

// CNTSR (Counter Status Register)
// Provides counter frequency status information.
namespace cntsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntsr, val) }

	namespace fcack
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntsr, 0xffffff00, 8) }
		inline uint32_t get(uint32_t cntsr_val) noexcept { GET_BITFIELD_FUNC(cntsr_val, 0xffffff00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntsr, value, 0xffffff00, 8) }
		inline uint32_t set(uint32_t cntsr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntsr, value, 0xffffff00, 8) }
	}

	namespace dbgh
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntsr, 1) }
		inline uint32_t is_enabled(uint32_t cntsr_val) noexcept { IS_BIT_ENABLED_FUNC(cntsr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntsr, 1) }
		inline uint32_t is_disabled(uint32_t cntsr_val) noexcept { IS_BIT_DISABLED_FUNC(cntsr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntsr, 0x2) }
		inline uint32_t enable(uint32_t cntsr_val) noexcept { SET_BITS_BY_MASK_FUNC(cntsr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntsr, 0x2) }
		inline uint32_t disable(uint32_t cntsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntsr_val, 0x2) }
	}
}

// CNTTIDR (Counter-timer Timer ID Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace cnttidr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cnttidr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cnttidr, val) }

	namespace frame_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cnttidr, 0xffffffff, 0) }
		inline uint32_t get(uint32_t cnttidr_val) noexcept { GET_BITFIELD_FUNC(cnttidr_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cnttidr, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t cnttidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cnttidr, value, 0xffffffff, 0) }
	}
}

// CNTV_CTL (Counter-timer Virtual Timer Control)
// Control register for the virtual timer.
namespace cntv_ctl
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntv_ctl) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntv_ctl, val) }

	namespace istatus
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntv_ctl, 2) }
		inline uint32_t is_enabled(uint32_t cntv_ctl_val) noexcept { IS_BIT_ENABLED_FUNC(cntv_ctl_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntv_ctl, 2) }
		inline uint32_t is_disabled(uint32_t cntv_ctl_val) noexcept { IS_BIT_DISABLED_FUNC(cntv_ctl_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntv_ctl, 0x4) }
		inline uint32_t enable(uint32_t cntv_ctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cntv_ctl_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntv_ctl, 0x4) }
		inline uint32_t disable(uint32_t cntv_ctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntv_ctl_val, 0x4) }
	}

	namespace imask
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntv_ctl, 1) }
		inline uint32_t is_enabled(uint32_t cntv_ctl_val) noexcept { IS_BIT_ENABLED_FUNC(cntv_ctl_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntv_ctl, 1) }
		inline uint32_t is_disabled(uint32_t cntv_ctl_val) noexcept { IS_BIT_DISABLED_FUNC(cntv_ctl_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntv_ctl, 0x2) }
		inline uint32_t enable(uint32_t cntv_ctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cntv_ctl_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntv_ctl, 0x2) }
		inline uint32_t disable(uint32_t cntv_ctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntv_ctl_val, 0x2) }
	}

	namespace enable
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cntv_ctl, 0) }
		inline uint32_t is_enabled(uint32_t cntv_ctl_val) noexcept { IS_BIT_ENABLED_FUNC(cntv_ctl_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cntv_ctl, 0) }
		inline uint32_t is_disabled(uint32_t cntv_ctl_val) noexcept { IS_BIT_DISABLED_FUNC(cntv_ctl_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cntv_ctl, 0x1) }
		inline uint32_t enable(uint32_t cntv_ctl_val) noexcept { SET_BITS_BY_MASK_FUNC(cntv_ctl_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cntv_ctl, 0x1) }
		inline uint32_t disable(uint32_t cntv_ctl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cntv_ctl_val, 0x1) }
	}
}

// CNTV_CVAL (Counter-timer Virtual Timer CompareValue)
// Holds the 64-bit compare value for the virtual timer.
namespace cntv_cval
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(cntv_cval) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntv_cval, val) }

	namespace comparevalue
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntv_cval, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t cntv_cval_val) noexcept { GET_BITFIELD_FUNC(cntv_cval_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntv_cval, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t cntv_cval, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntv_cval, value, 0xffffffffffffffff, 0) }
	}
}

// CNTV_TVAL (Counter-timer Virtual Timer TimerValue)
// Holds the timer value for the virtual timer.
namespace cntv_tval
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cntv_tval) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntv_tval, val) }

	namespace timervalue
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntv_tval, 0xffffffff, 0) }
		inline uint32_t get(uint32_t cntv_tval_val) noexcept { GET_BITFIELD_FUNC(cntv_tval_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntv_tval, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t cntv_tval, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntv_tval, value, 0xffffffff, 0) }
	}
}

// CNTVCT (Counter-timer Virtual Count)
// Holds the 64-bit virtual count value.
namespace cntvct
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(cntvct) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntvct, val) }

	namespace virtual_count_value
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntvct, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t cntvct_val) noexcept { GET_BITFIELD_FUNC(cntvct_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntvct, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t cntvct, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntvct, value, 0xffffffffffffffff, 0) }
	}
}

// CNTVOFF (Counter-timer Virtual Offset)
// Holds the 64-bit virtual offset for a CNTBaseN frame that has virtual timer capability. This is the offset between real time and virtual time.
namespace cntvoff
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(cntvoff) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntvoff, val) }

	namespace virtual_offset
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntvoff, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t cntvoff_val) noexcept { GET_BITFIELD_FUNC(cntvoff_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntvoff, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t cntvoff, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntvoff, value, 0xffffffffffffffff, 0) }
	}
}

// CNTVOFF<n> (Counter-timer Virtual Offsets)
// Holds the 64-bit virtual offset for frame CNTBase<n>.
namespace cntvoff<n>
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(cntvoff<n>) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cntvoff<n>, val) }

	namespace virtual_offset
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(cntvoff<n>, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t cntvoff<n>_val) noexcept { GET_BITFIELD_FUNC(cntvoff<n>_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cntvoff<n>, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t cntvoff<n>, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cntvoff<n>, value, 0xffffffffffffffff, 0) }
	}
}

// CounterID<n> (Counter ID registers)
// IMPLEMENTATION DEFINED identification registers 0 to 11 for the memory-mapped Generic Timer.
namespace counterid<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(counterid<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(counterid<n>, val) }
}

// CTIAPPCLEAR (CTI Application Trigger Clear register)
// Clears bits of the Application Trigger register.
namespace ctiappclear
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctiappclear) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctiappclear, val) }

	namespace appclear_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctiappclear, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ctiappclear_val) noexcept { GET_BITFIELD_FUNC(ctiappclear_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctiappclear, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ctiappclear, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctiappclear, value, 0xffffffff, 0) }
	}
}

// CTIAPPPULSE (CTI Application Pulse register)
// Causes event pulses to be generated on ECT channels.
namespace ctiapppulse
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctiapppulse) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctiapppulse, val) }

	namespace apppulse_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctiapppulse, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ctiapppulse_val) noexcept { GET_BITFIELD_FUNC(ctiapppulse_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctiapppulse, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ctiapppulse, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctiapppulse, value, 0xffffffff, 0) }
	}
}

// CTIAPPSET (CTI Application Trigger Set register)
// Sets bits of the Application Trigger register.
namespace ctiappset
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctiappset) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctiappset, val) }

	namespace appset_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctiappset, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ctiappset_val) noexcept { GET_BITFIELD_FUNC(ctiappset_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctiappset, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ctiappset, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctiappset, value, 0xffffffff, 0) }
	}
}

// CTIAUTHSTATUS (CTI Authentication Status register)
// Provides information about the state of the IMPLEMENTATION DEFINED authentication interface for CTI.
namespace ctiauthstatus
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctiauthstatus) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctiauthstatus, val) }

	namespace nsnid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctiauthstatus, 0xc, 2) }
		inline uint32_t get(uint32_t ctiauthstatus_val) noexcept { GET_BITFIELD_FUNC(ctiauthstatus_val, 0xc, 2) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctiauthstatus, value, 0xc, 2) }
		inline uint32_t set(uint32_t ctiauthstatus, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctiauthstatus, value, 0xc, 2) }
	}

	namespace nsid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctiauthstatus, 0x3, 0) }
		inline uint32_t get(uint32_t ctiauthstatus_val) noexcept { GET_BITFIELD_FUNC(ctiauthstatus_val, 0x3, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctiauthstatus, value, 0x3, 0) }
		inline uint32_t set(uint32_t ctiauthstatus, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctiauthstatus, value, 0x3, 0) }
	}
}

// CTICHINSTATUS (CTI Channel In Status register)
// Provides the raw status of the ECT channel inputs to the CTI.
namespace ctichinstatus
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctichinstatus) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctichinstatus, val) }

	namespace chin_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctichinstatus, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ctichinstatus_val) noexcept { GET_BITFIELD_FUNC(ctichinstatus_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctichinstatus, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ctichinstatus, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctichinstatus, value, 0xffffffff, 0) }
	}
}

// CTICHOUTSTATUS (CTI Channel Out Status register)
// Provides the status of the ECT channel outputs from the CTI.
namespace ctichoutstatus
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctichoutstatus) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctichoutstatus, val) }

	namespace chout_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctichoutstatus, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ctichoutstatus_val) noexcept { GET_BITFIELD_FUNC(ctichoutstatus_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctichoutstatus, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ctichoutstatus, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctichoutstatus, value, 0xffffffff, 0) }
	}
}

// CTICIDR0 (CTI Component Identification Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace cticidr0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cticidr0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cticidr0, val) }

	namespace prmbl_0
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cticidr0, 0xff, 0) }
		inline uint32_t get(uint32_t cticidr0_val) noexcept { GET_BITFIELD_FUNC(cticidr0_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cticidr0, value, 0xff, 0) }
		inline uint32_t set(uint32_t cticidr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cticidr0, value, 0xff, 0) }
	}
}

// CTICIDR1 (CTI Component Identification Register 1)
// See the ARMv8 architecture reference manual for a description of this register
namespace cticidr1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cticidr1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cticidr1, val) }

	namespace class
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cticidr1, 0xf0, 4) }
		inline uint32_t get(uint32_t cticidr1_val) noexcept { GET_BITFIELD_FUNC(cticidr1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cticidr1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t cticidr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cticidr1, value, 0xf0, 4) }
	}

	namespace prmbl_1
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cticidr1, 0xf, 0) }
		inline uint32_t get(uint32_t cticidr1_val) noexcept { GET_BITFIELD_FUNC(cticidr1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cticidr1, value, 0xf, 0) }
		inline uint32_t set(uint32_t cticidr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cticidr1, value, 0xf, 0) }
	}
}

// CTICIDR2 (CTI Component Identification Register 2)
// See the ARMv8 architecture reference manual for a description of this register
namespace cticidr2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cticidr2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cticidr2, val) }

	namespace prmbl_2
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cticidr2, 0xff, 0) }
		inline uint32_t get(uint32_t cticidr2_val) noexcept { GET_BITFIELD_FUNC(cticidr2_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cticidr2, value, 0xff, 0) }
		inline uint32_t set(uint32_t cticidr2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cticidr2, value, 0xff, 0) }
	}
}

// CTICIDR3 (CTI Component Identification Register 3)
// See the ARMv8 architecture reference manual for a description of this register
namespace cticidr3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cticidr3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cticidr3, val) }

	namespace prmbl_3
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cticidr3, 0xff, 0) }
		inline uint32_t get(uint32_t cticidr3_val) noexcept { GET_BITFIELD_FUNC(cticidr3_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cticidr3, value, 0xff, 0) }
		inline uint32_t set(uint32_t cticidr3, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cticidr3, value, 0xff, 0) }
	}
}

// CTICLAIMCLR (CTI Claim Tag Clear register)
// Used by software to read the values of the CLAIM bits, and to clear these bits to 0.
namespace cticlaimclr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cticlaimclr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cticlaimclr, val) }

	namespace claim_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cticlaimclr, 0xffffffff, 0) }
		inline uint32_t get(uint32_t cticlaimclr_val) noexcept { GET_BITFIELD_FUNC(cticlaimclr_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cticlaimclr, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t cticlaimclr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cticlaimclr, value, 0xffffffff, 0) }
	}
}

// CTICLAIMSET (CTI Claim Tag Set register)
// Used by software to set CLAIM bits to 1.
namespace cticlaimset
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cticlaimset) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cticlaimset, val) }

	namespace claim_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(cticlaimset, 0xffffffff, 0) }
		inline uint32_t get(uint32_t cticlaimset_val) noexcept { GET_BITFIELD_FUNC(cticlaimset_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(cticlaimset, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t cticlaimset, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(cticlaimset, value, 0xffffffff, 0) }
	}
}

// CTICONTROL (CTI Control register)
// Controls whether the CTI is enabled.
namespace cticontrol
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(cticontrol) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(cticontrol, val) }

	namespace glben
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(cticontrol, 0) }
		inline uint32_t is_enabled(uint32_t cticontrol_val) noexcept { IS_BIT_ENABLED_FUNC(cticontrol_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(cticontrol, 0) }
		inline uint32_t is_disabled(uint32_t cticontrol_val) noexcept { IS_BIT_DISABLED_FUNC(cticontrol_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(cticontrol, 0x1) }
		inline uint32_t enable(uint32_t cticontrol_val) noexcept { SET_BITS_BY_MASK_FUNC(cticontrol_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(cticontrol, 0x1) }
		inline uint32_t disable(uint32_t cticontrol_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(cticontrol_val, 0x1) }
	}
}

// CTIDEVAFF0 (CTI Device Affinity register 0)
// Copy of the low half of the PE MPIDR_EL1 register that allows a debugger to determine which PE in a multiprocessor system the CTI component relates to.
namespace ctidevaff0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctidevaff0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctidevaff0, val) }

	namespace none
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctidevaff0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ctidevaff0_val) noexcept { GET_BITFIELD_FUNC(ctidevaff0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctidevaff0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ctidevaff0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctidevaff0, value, 0xffffffff, 0) }
	}
}

// CTIDEVAFF1 (CTI Device Affinity register 1)
// Copy of the high half of the PE MPIDR_EL1 register that allows a debugger to determine which PE in a multiprocessor system the CTI component relates to.
namespace ctidevaff1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctidevaff1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctidevaff1, val) }

	namespace none
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctidevaff1, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ctidevaff1_val) noexcept { GET_BITFIELD_FUNC(ctidevaff1_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctidevaff1, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ctidevaff1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctidevaff1, value, 0xffffffff, 0) }
	}
}

// CTIDEVARCH (CTI Device Architecture register)
// Identifies the programmers' model architecture of the CTI component.
namespace ctidevarch
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctidevarch) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctidevarch, val) }

	namespace architect
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctidevarch, 0xffe00000, 21) }
		inline uint32_t get(uint32_t ctidevarch_val) noexcept { GET_BITFIELD_FUNC(ctidevarch_val, 0xffe00000, 21) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctidevarch, value, 0xffe00000, 21) }
		inline uint32_t set(uint32_t ctidevarch, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctidevarch, value, 0xffe00000, 21) }
	}

	namespace present
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ctidevarch, 20) }
		inline uint32_t is_enabled(uint32_t ctidevarch_val) noexcept { IS_BIT_ENABLED_FUNC(ctidevarch_val, 20) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ctidevarch, 20) }
		inline uint32_t is_disabled(uint32_t ctidevarch_val) noexcept { IS_BIT_DISABLED_FUNC(ctidevarch_val, 20) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ctidevarch, 0x100000) }
		inline uint32_t enable(uint32_t ctidevarch_val) noexcept { SET_BITS_BY_MASK_FUNC(ctidevarch_val, 0x100000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ctidevarch, 0x100000) }
		inline uint32_t disable(uint32_t ctidevarch_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ctidevarch_val, 0x100000) }
	}

	namespace revision
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctidevarch, 0xf0000, 16) }
		inline uint32_t get(uint32_t ctidevarch_val) noexcept { GET_BITFIELD_FUNC(ctidevarch_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctidevarch, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t ctidevarch, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctidevarch, value, 0xf0000, 16) }
	}

	namespace archid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctidevarch, 0xffff, 0) }
		inline uint32_t get(uint32_t ctidevarch_val) noexcept { GET_BITFIELD_FUNC(ctidevarch_val, 0xffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctidevarch, value, 0xffff, 0) }
		inline uint32_t set(uint32_t ctidevarch, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctidevarch, value, 0xffff, 0) }
	}
}

// CTIDEVID (CTI Device ID register 0)
// Describes the CTI component to the debugger.
namespace ctidevid
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctidevid) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctidevid, val) }

	namespace inout
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctidevid, 0x3000000, 24) }
		inline uint32_t get(uint32_t ctidevid_val) noexcept { GET_BITFIELD_FUNC(ctidevid_val, 0x3000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctidevid, value, 0x3000000, 24) }
		inline uint32_t set(uint32_t ctidevid, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctidevid, value, 0x3000000, 24) }
	}

	namespace numchan
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctidevid, 0x3f0000, 16) }
		inline uint32_t get(uint32_t ctidevid_val) noexcept { GET_BITFIELD_FUNC(ctidevid_val, 0x3f0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctidevid, value, 0x3f0000, 16) }
		inline uint32_t set(uint32_t ctidevid, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctidevid, value, 0x3f0000, 16) }
	}

	namespace numtrig
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctidevid, 0x3f00, 8) }
		inline uint32_t get(uint32_t ctidevid_val) noexcept { GET_BITFIELD_FUNC(ctidevid_val, 0x3f00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctidevid, value, 0x3f00, 8) }
		inline uint32_t set(uint32_t ctidevid, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctidevid, value, 0x3f00, 8) }
	}

	namespace extmuxnum
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctidevid, 0x1f, 0) }
		inline uint32_t get(uint32_t ctidevid_val) noexcept { GET_BITFIELD_FUNC(ctidevid_val, 0x1f, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctidevid, value, 0x1f, 0) }
		inline uint32_t set(uint32_t ctidevid, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctidevid, value, 0x1f, 0) }
	}
}

// CTIDEVID1 (CTI Device ID register 1)
// Reserved for future information about the CTI component to the debugger.
namespace ctidevid1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctidevid1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctidevid1, val) }
}

// CTIDEVID2 (CTI Device ID register 2)
// Reserved for future information about the CTI component to the debugger.
namespace ctidevid2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctidevid2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctidevid2, val) }
}

// CTIDEVTYPE (CTI Device Type register)
// Indicates to a debugger that this component is part of a PEs cross-trigger interface.
namespace ctidevtype
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctidevtype) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctidevtype, val) }

	namespace sub
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctidevtype, 0xf0, 4) }
		inline uint32_t get(uint32_t ctidevtype_val) noexcept { GET_BITFIELD_FUNC(ctidevtype_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctidevtype, value, 0xf0, 4) }
		inline uint32_t set(uint32_t ctidevtype, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctidevtype, value, 0xf0, 4) }
	}

	namespace major
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctidevtype, 0xf, 0) }
		inline uint32_t get(uint32_t ctidevtype_val) noexcept { GET_BITFIELD_FUNC(ctidevtype_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctidevtype, value, 0xf, 0) }
		inline uint32_t set(uint32_t ctidevtype, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctidevtype, value, 0xf, 0) }
	}
}

// CTIGATE (CTI Channel Gate Enable register)
// Determines whether events on channels propagate through the CTM to other ECT components, or from the CTM into the CTI.
namespace ctigate
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctigate) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctigate, val) }

	namespace gate_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctigate, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ctigate_val) noexcept { GET_BITFIELD_FUNC(ctigate_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctigate, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ctigate, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctigate, value, 0xffffffff, 0) }
	}
}

// CTIINEN<n> (CTI Input Trigger to Output Channel Enable registers)
// Enables the signaling of an event on output channels when input trigger event n is received by the CTI.
namespace ctiinen<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctiinen<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctiinen<n>, val) }

	namespace inen_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctiinen<n>, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ctiinen<n>_val) noexcept { GET_BITFIELD_FUNC(ctiinen<n>_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctiinen<n>, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ctiinen<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctiinen<n>, value, 0xffffffff, 0) }
	}
}

// CTIINTACK (CTI Output Trigger Acknowledge register)
// Can be used to deactivate the output triggers.
namespace ctiintack
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctiintack) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctiintack, val) }

	namespace ack_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctiintack, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ctiintack_val) noexcept { GET_BITFIELD_FUNC(ctiintack_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctiintack, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ctiintack, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctiintack, value, 0xffffffff, 0) }
	}
}

// CTIITCTRL (CTI Integration mode Control register)
// Enables the CTI to switch from its default mode into integration mode, where test software can control directly the inputs and outputs of the PE, for integration testing or topology detection.
namespace ctiitctrl
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctiitctrl) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctiitctrl, val) }

	namespace ime
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ctiitctrl, 0) }
		inline uint32_t is_enabled(uint32_t ctiitctrl_val) noexcept { IS_BIT_ENABLED_FUNC(ctiitctrl_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ctiitctrl, 0) }
		inline uint32_t is_disabled(uint32_t ctiitctrl_val) noexcept { IS_BIT_DISABLED_FUNC(ctiitctrl_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ctiitctrl, 0x1) }
		inline uint32_t enable(uint32_t ctiitctrl_val) noexcept { SET_BITS_BY_MASK_FUNC(ctiitctrl_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ctiitctrl, 0x1) }
		inline uint32_t disable(uint32_t ctiitctrl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ctiitctrl_val, 0x1) }
	}
}

// CTILAR (CTI Lock Access Register)
// Allows or disallows access to the CTI registers through a memory-mapped interface.
namespace ctilar
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctilar) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctilar, val) }

	namespace key
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctilar, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ctilar_val) noexcept { GET_BITFIELD_FUNC(ctilar_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctilar, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ctilar, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctilar, value, 0xffffffff, 0) }
	}
}

// CTILSR (CTI Lock Status Register)
// Indicates the current status of the Software Lock for CTI registers.
namespace ctilsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctilsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctilsr, val) }

	namespace ntt
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ctilsr, 2) }
		inline uint32_t is_enabled(uint32_t ctilsr_val) noexcept { IS_BIT_ENABLED_FUNC(ctilsr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ctilsr, 2) }
		inline uint32_t is_disabled(uint32_t ctilsr_val) noexcept { IS_BIT_DISABLED_FUNC(ctilsr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ctilsr, 0x4) }
		inline uint32_t enable(uint32_t ctilsr_val) noexcept { SET_BITS_BY_MASK_FUNC(ctilsr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ctilsr, 0x4) }
		inline uint32_t disable(uint32_t ctilsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ctilsr_val, 0x4) }
	}

	namespace slk
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ctilsr, 1) }
		inline uint32_t is_enabled(uint32_t ctilsr_val) noexcept { IS_BIT_ENABLED_FUNC(ctilsr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ctilsr, 1) }
		inline uint32_t is_disabled(uint32_t ctilsr_val) noexcept { IS_BIT_DISABLED_FUNC(ctilsr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ctilsr, 0x2) }
		inline uint32_t enable(uint32_t ctilsr_val) noexcept { SET_BITS_BY_MASK_FUNC(ctilsr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ctilsr, 0x2) }
		inline uint32_t disable(uint32_t ctilsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ctilsr_val, 0x2) }
	}

	namespace sli
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ctilsr, 0) }
		inline uint32_t is_enabled(uint32_t ctilsr_val) noexcept { IS_BIT_ENABLED_FUNC(ctilsr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ctilsr, 0) }
		inline uint32_t is_disabled(uint32_t ctilsr_val) noexcept { IS_BIT_DISABLED_FUNC(ctilsr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ctilsr, 0x1) }
		inline uint32_t enable(uint32_t ctilsr_val) noexcept { SET_BITS_BY_MASK_FUNC(ctilsr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ctilsr, 0x1) }
		inline uint32_t disable(uint32_t ctilsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ctilsr_val, 0x1) }
	}
}

// CTIOUTEN<n> (CTI Input Channel to Output Trigger Enable registers)
// Defines which input channels generate output trigger n.
namespace ctiouten<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctiouten<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctiouten<n>, val) }

	namespace outen_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctiouten<n>, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ctiouten<n>_val) noexcept { GET_BITFIELD_FUNC(ctiouten<n>_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctiouten<n>, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ctiouten<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctiouten<n>, value, 0xffffffff, 0) }
	}
}

// CTIPIDR0 (CTI Peripheral Identification Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace ctipidr0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctipidr0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctipidr0, val) }

	namespace part_0
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctipidr0, 0xff, 0) }
		inline uint32_t get(uint32_t ctipidr0_val) noexcept { GET_BITFIELD_FUNC(ctipidr0_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctipidr0, value, 0xff, 0) }
		inline uint32_t set(uint32_t ctipidr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctipidr0, value, 0xff, 0) }
	}
}

// CTIPIDR1 (CTI Peripheral Identification Register 1)
// See the ARMv8 architecture reference manual for a description of this register
namespace ctipidr1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctipidr1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctipidr1, val) }

	namespace des_0
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctipidr1, 0xf0, 4) }
		inline uint32_t get(uint32_t ctipidr1_val) noexcept { GET_BITFIELD_FUNC(ctipidr1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctipidr1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t ctipidr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctipidr1, value, 0xf0, 4) }
	}

	namespace part_1
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctipidr1, 0xf, 0) }
		inline uint32_t get(uint32_t ctipidr1_val) noexcept { GET_BITFIELD_FUNC(ctipidr1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctipidr1, value, 0xf, 0) }
		inline uint32_t set(uint32_t ctipidr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctipidr1, value, 0xf, 0) }
	}
}

// CTIPIDR2 (CTI Peripheral Identification Register 2)
// See the ARMv8 architecture reference manual for a description of this register
namespace ctipidr2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctipidr2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctipidr2, val) }

	namespace revision
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctipidr2, 0xf0, 4) }
		inline uint32_t get(uint32_t ctipidr2_val) noexcept { GET_BITFIELD_FUNC(ctipidr2_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctipidr2, value, 0xf0, 4) }
		inline uint32_t set(uint32_t ctipidr2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctipidr2, value, 0xf0, 4) }
	}

	namespace jedec
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(ctipidr2, 3) }
		inline uint32_t is_enabled(uint32_t ctipidr2_val) noexcept { IS_BIT_ENABLED_FUNC(ctipidr2_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(ctipidr2, 3) }
		inline uint32_t is_disabled(uint32_t ctipidr2_val) noexcept { IS_BIT_DISABLED_FUNC(ctipidr2_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(ctipidr2, 0x8) }
		inline uint32_t enable(uint32_t ctipidr2_val) noexcept { SET_BITS_BY_MASK_FUNC(ctipidr2_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(ctipidr2, 0x8) }
		inline uint32_t disable(uint32_t ctipidr2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(ctipidr2_val, 0x8) }
	}

	namespace des_1
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctipidr2, 0x7, 0) }
		inline uint32_t get(uint32_t ctipidr2_val) noexcept { GET_BITFIELD_FUNC(ctipidr2_val, 0x7, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctipidr2, value, 0x7, 0) }
		inline uint32_t set(uint32_t ctipidr2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctipidr2, value, 0x7, 0) }
	}
}

// CTIPIDR3 (CTI Peripheral Identification Register 3)
// See the ARMv8 architecture reference manual for a description of this register
namespace ctipidr3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctipidr3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctipidr3, val) }

	namespace revand
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctipidr3, 0xf0, 4) }
		inline uint32_t get(uint32_t ctipidr3_val) noexcept { GET_BITFIELD_FUNC(ctipidr3_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctipidr3, value, 0xf0, 4) }
		inline uint32_t set(uint32_t ctipidr3, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctipidr3, value, 0xf0, 4) }
	}

	namespace cmod
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctipidr3, 0xf, 0) }
		inline uint32_t get(uint32_t ctipidr3_val) noexcept { GET_BITFIELD_FUNC(ctipidr3_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctipidr3, value, 0xf, 0) }
		inline uint32_t set(uint32_t ctipidr3, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctipidr3, value, 0xf, 0) }
	}
}

// CTIPIDR4 (CTI Peripheral Identification Register 4)
// See the ARMv8 architecture reference manual for a description of this register
namespace ctipidr4
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctipidr4) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctipidr4, val) }

	namespace size
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctipidr4, 0xf0, 4) }
		inline uint32_t get(uint32_t ctipidr4_val) noexcept { GET_BITFIELD_FUNC(ctipidr4_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctipidr4, value, 0xf0, 4) }
		inline uint32_t set(uint32_t ctipidr4, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctipidr4, value, 0xf0, 4) }
	}

	namespace des_2
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctipidr4, 0xf, 0) }
		inline uint32_t get(uint32_t ctipidr4_val) noexcept { GET_BITFIELD_FUNC(ctipidr4_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctipidr4, value, 0xf, 0) }
		inline uint32_t set(uint32_t ctipidr4, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctipidr4, value, 0xf, 0) }
	}
}

// CTITRIGINSTATUS (CTI Trigger In Status register)
// Provides the status of the trigger inputs.
namespace ctitriginstatus
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctitriginstatus) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctitriginstatus, val) }

	namespace trin_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctitriginstatus, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ctitriginstatus_val) noexcept { GET_BITFIELD_FUNC(ctitriginstatus_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctitriginstatus, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ctitriginstatus, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctitriginstatus, value, 0xffffffff, 0) }
	}
}

// CTITRIGOUTSTATUS (CTI Trigger Out Status register)
// Provides the raw status of the trigger outputs, after processing by any IMPLEMENTATION DEFINED trigger interface logic. For output triggers that are self-acknowledging, this is only meaningful if the CTI implements multicycle channel events.
namespace ctitrigoutstatus
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(ctitrigoutstatus) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(ctitrigoutstatus, val) }

	namespace trout_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(ctitrigoutstatus, 0xffffffff, 0) }
		inline uint32_t get(uint32_t ctitrigoutstatus_val) noexcept { GET_BITFIELD_FUNC(ctitrigoutstatus_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(ctitrigoutstatus, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t ctitrigoutstatus, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(ctitrigoutstatus, value, 0xffffffff, 0) }
	}
}

// DBGAUTHSTATUS_EL1 (Debug Authentication Status register)
// Provides information about the state of the IMPLEMENTATION DEFINED authentication interface for debug.
namespace dbgauthstatus_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgauthstatus_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgauthstatus_el1, val) }

	namespace snid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgauthstatus_el1, 0xc0, 6) }
		inline uint32_t get(uint32_t dbgauthstatus_el1_val) noexcept { GET_BITFIELD_FUNC(dbgauthstatus_el1_val, 0xc0, 6) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgauthstatus_el1, value, 0xc0, 6) }
		inline uint32_t set(uint32_t dbgauthstatus_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgauthstatus_el1, value, 0xc0, 6) }
	}

	namespace sid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgauthstatus_el1, 0x30, 4) }
		inline uint32_t get(uint32_t dbgauthstatus_el1_val) noexcept { GET_BITFIELD_FUNC(dbgauthstatus_el1_val, 0x30, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgauthstatus_el1, value, 0x30, 4) }
		inline uint32_t set(uint32_t dbgauthstatus_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgauthstatus_el1, value, 0x30, 4) }
	}

	namespace nsnid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgauthstatus_el1, 0xc, 2) }
		inline uint32_t get(uint32_t dbgauthstatus_el1_val) noexcept { GET_BITFIELD_FUNC(dbgauthstatus_el1_val, 0xc, 2) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgauthstatus_el1, value, 0xc, 2) }
		inline uint32_t set(uint32_t dbgauthstatus_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgauthstatus_el1, value, 0xc, 2) }
	}

	namespace nsid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgauthstatus_el1, 0x3, 0) }
		inline uint32_t get(uint32_t dbgauthstatus_el1_val) noexcept { GET_BITFIELD_FUNC(dbgauthstatus_el1_val, 0x3, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgauthstatus_el1, value, 0x3, 0) }
		inline uint32_t set(uint32_t dbgauthstatus_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgauthstatus_el1, value, 0x3, 0) }
	}
}

// DBGBCR<n>_EL1 (Debug Breakpoint Control Registers)
// Holds control information for a breakpoint. Forms breakpoint n together with value register DBGBVR<n>_EL1.
namespace dbgbcr<n>_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgbcr<n>_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgbcr<n>_el1, val) }

	namespace bt
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbcr<n>_el1, 0xf00000, 20) }
		inline uint32_t get(uint32_t dbgbcr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgbcr<n>_el1_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbcr<n>_el1, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t dbgbcr<n>_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbcr<n>_el1, value, 0xf00000, 20) }
	}

	namespace lbn
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbcr<n>_el1, 0xf0000, 16) }
		inline uint32_t get(uint32_t dbgbcr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgbcr<n>_el1_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbcr<n>_el1, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t dbgbcr<n>_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbcr<n>_el1, value, 0xf0000, 16) }
	}

	namespace ssc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbcr<n>_el1, 0xc000, 14) }
		inline uint32_t get(uint32_t dbgbcr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgbcr<n>_el1_val, 0xc000, 14) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbcr<n>_el1, value, 0xc000, 14) }
		inline uint32_t set(uint32_t dbgbcr<n>_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbcr<n>_el1, value, 0xc000, 14) }
	}

	namespace hmc
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgbcr<n>_el1, 13) }
		inline uint32_t is_enabled(uint32_t dbgbcr<n>_el1_val) noexcept { IS_BIT_ENABLED_FUNC(dbgbcr<n>_el1_val, 13) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgbcr<n>_el1, 13) }
		inline uint32_t is_disabled(uint32_t dbgbcr<n>_el1_val) noexcept { IS_BIT_DISABLED_FUNC(dbgbcr<n>_el1_val, 13) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgbcr<n>_el1, 0x2000) }
		inline uint32_t enable(uint32_t dbgbcr<n>_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgbcr<n>_el1_val, 0x2000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgbcr<n>_el1, 0x2000) }
		inline uint32_t disable(uint32_t dbgbcr<n>_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgbcr<n>_el1_val, 0x2000) }
	}

	namespace bas
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbcr<n>_el1, 0x1e0, 5) }
		inline uint32_t get(uint32_t dbgbcr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgbcr<n>_el1_val, 0x1e0, 5) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbcr<n>_el1, value, 0x1e0, 5) }
		inline uint32_t set(uint32_t dbgbcr<n>_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbcr<n>_el1, value, 0x1e0, 5) }
	}

	namespace pmc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbcr<n>_el1, 0x6, 1) }
		inline uint32_t get(uint32_t dbgbcr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgbcr<n>_el1_val, 0x6, 1) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbcr<n>_el1, value, 0x6, 1) }
		inline uint32_t set(uint32_t dbgbcr<n>_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbcr<n>_el1, value, 0x6, 1) }
	}

	namespace e
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgbcr<n>_el1, 0) }
		inline uint32_t is_enabled(uint32_t dbgbcr<n>_el1_val) noexcept { IS_BIT_ENABLED_FUNC(dbgbcr<n>_el1_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgbcr<n>_el1, 0) }
		inline uint32_t is_disabled(uint32_t dbgbcr<n>_el1_val) noexcept { IS_BIT_DISABLED_FUNC(dbgbcr<n>_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgbcr<n>_el1, 0x1) }
		inline uint32_t enable(uint32_t dbgbcr<n>_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgbcr<n>_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgbcr<n>_el1, 0x1) }
		inline uint32_t disable(uint32_t dbgbcr<n>_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgbcr<n>_el1_val, 0x1) }
	}
}

// DBGBVR<n>_EL1 (Debug Breakpoint Value Registers)
// Holds a virtual address, or a VMID and/or a context ID, for use in breakpoint matching. Forms breakpoint n together with control register DBGBCR<n>_EL1.
namespace dbgbvr<n>_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(dbgbvr<n>_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgbvr<n>_el1, val) }

	// Fieldset valid when: DBGBCR<n>_EL1.BT==0b0x0x
	namespace fieldset_1
	{	}

	// Fieldset valid when: DBGBCR<n>_EL1.BT==0b001x
	namespace fieldset_2
	{
		namespace contextid
		{
			inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbvr<n>_el1, 0xffffffff, 0) }
			inline uint64_t get(uint64_t dbgbvr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgbvr<n>_el1_val, 0xffffffff, 0) }
			inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbvr<n>_el1, value, 0xffffffff, 0) }
			inline uint64_t set(uint64_t dbgbvr<n>_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbvr<n>_el1, value, 0xffffffff, 0) }
		}
	}

	// Fieldset valid when: DBGBCR<n>_EL1.BT==0b011x
	namespace fieldset_3
	{
		namespace contextid
		{
			inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbvr<n>_el1, 0xffffffff, 0) }
			inline uint64_t get(uint64_t dbgbvr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgbvr<n>_el1_val, 0xffffffff, 0) }
			inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbvr<n>_el1, value, 0xffffffff, 0) }
			inline uint64_t set(uint64_t dbgbvr<n>_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbvr<n>_el1, value, 0xffffffff, 0) }
		}
	}

	// Fieldset valid when: DBGBCR<n>_EL1.BT==0b100x and EL2 implemented
	namespace fieldset_4
	{	}

	// Fieldset valid when: DBGBCR<n>_EL1.BT==0b101x and EL2 implemented
	namespace fieldset_5
	{	}

	// Fieldset valid when: DBGBCR<n>_EL1.BT==0b110x and EL2 implemented
	namespace fieldset_6
	{
		namespace contextid2
		{
			inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbvr<n>_el1, 0xffffffff00000000, 32) }
			inline uint64_t get(uint64_t dbgbvr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgbvr<n>_el1_val, 0xffffffff00000000, 32) }
			inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbvr<n>_el1, value, 0xffffffff00000000, 32) }
			inline uint64_t set(uint64_t dbgbvr<n>_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbvr<n>_el1, value, 0xffffffff00000000, 32) }
		}
	}

	// Fieldset valid when: DBGBCR<n>_EL1.BT==0b111x and EL2 implemented
	namespace fieldset_7
	{
		namespace contextid2
		{
			inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbvr<n>_el1, 0xffffffff00000000, 32) }
			inline uint64_t get(uint64_t dbgbvr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgbvr<n>_el1_val, 0xffffffff00000000, 32) }
			inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbvr<n>_el1, value, 0xffffffff00000000, 32) }
			inline uint64_t set(uint64_t dbgbvr<n>_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbvr<n>_el1, value, 0xffffffff00000000, 32) }
		}

		namespace contextid
		{
			inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgbvr<n>_el1, 0xffffffff, 0) }
			inline uint64_t get(uint64_t dbgbvr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgbvr<n>_el1_val, 0xffffffff, 0) }
			inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgbvr<n>_el1, value, 0xffffffff, 0) }
			inline uint64_t set(uint64_t dbgbvr<n>_el1, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgbvr<n>_el1, value, 0xffffffff, 0) }
		}
	}
}

// DBGCLAIMCLR_EL1 (Debug Claim Tag Clear register)
// See the ARMv8 architecture reference manual for a description of this register
namespace dbgclaimclr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgclaimclr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgclaimclr_el1, val) }

	namespace claim
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgclaimclr_el1, 0xff, 0) }
		inline uint32_t get(uint32_t dbgclaimclr_el1_val) noexcept { GET_BITFIELD_FUNC(dbgclaimclr_el1_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgclaimclr_el1, value, 0xff, 0) }
		inline uint32_t set(uint32_t dbgclaimclr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgclaimclr_el1, value, 0xff, 0) }
	}
}

// DBGCLAIMSET_EL1 (Debug Claim Tag Set register)
// See the ARMv8 architecture reference manual for a description of this register
namespace dbgclaimset_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgclaimset_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgclaimset_el1, val) }

	namespace claim
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgclaimset_el1, 0xff, 0) }
		inline uint32_t get(uint32_t dbgclaimset_el1_val) noexcept { GET_BITFIELD_FUNC(dbgclaimset_el1_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgclaimset_el1, value, 0xff, 0) }
		inline uint32_t set(uint32_t dbgclaimset_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgclaimset_el1, value, 0xff, 0) }
	}
}

// DBGDTRRX_EL0 (Debug Data Transfer Register, Receive)
// Transfers data from an external debugger to the PE. For example, it is used by a debugger transferring commands and data to a debug target. It is a component of the Debug Communications Channel.
namespace dbgdtrrx_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgdtrrx_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgdtrrx_el0, val) }

	namespace update_dtrrx
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdtrrx_el0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t dbgdtrrx_el0_val) noexcept { GET_BITFIELD_FUNC(dbgdtrrx_el0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdtrrx_el0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t dbgdtrrx_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdtrrx_el0, value, 0xffffffff, 0) }
	}
}

// DBGDTRTX_EL0 (Debug Data Transfer Register, Transmit)
// Transfers data from the PE to an external debugger. For example, it is used by a debug target to transfer data to the debugger. It is a component of the Debug Communication Channel.
namespace dbgdtrtx_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgdtrtx_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgdtrtx_el0, val) }

	namespace return_dtrtx
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgdtrtx_el0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t dbgdtrtx_el0_val) noexcept { GET_BITFIELD_FUNC(dbgdtrtx_el0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgdtrtx_el0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t dbgdtrtx_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgdtrtx_el0, value, 0xffffffff, 0) }
	}
}

// DBGWCR<n>_EL1 (Debug Watchpoint Control Registers)
// Holds control information for a watchpoint. Forms watchpoint n together with value register DBGWVR<n>_EL1.
namespace dbgwcr<n>_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(dbgwcr<n>_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgwcr<n>_el1, val) }

	namespace mask
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgwcr<n>_el1, 0x1f000000, 24) }
		inline uint32_t get(uint32_t dbgwcr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgwcr<n>_el1_val, 0x1f000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgwcr<n>_el1, value, 0x1f000000, 24) }
		inline uint32_t set(uint32_t dbgwcr<n>_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgwcr<n>_el1, value, 0x1f000000, 24) }
	}

	namespace wt
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgwcr<n>_el1, 20) }
		inline uint32_t is_enabled(uint32_t dbgwcr<n>_el1_val) noexcept { IS_BIT_ENABLED_FUNC(dbgwcr<n>_el1_val, 20) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgwcr<n>_el1, 20) }
		inline uint32_t is_disabled(uint32_t dbgwcr<n>_el1_val) noexcept { IS_BIT_DISABLED_FUNC(dbgwcr<n>_el1_val, 20) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgwcr<n>_el1, 0x100000) }
		inline uint32_t enable(uint32_t dbgwcr<n>_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgwcr<n>_el1_val, 0x100000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgwcr<n>_el1, 0x100000) }
		inline uint32_t disable(uint32_t dbgwcr<n>_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgwcr<n>_el1_val, 0x100000) }
	}

	namespace lbn
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgwcr<n>_el1, 0xf0000, 16) }
		inline uint32_t get(uint32_t dbgwcr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgwcr<n>_el1_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgwcr<n>_el1, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t dbgwcr<n>_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgwcr<n>_el1, value, 0xf0000, 16) }
	}

	namespace ssc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgwcr<n>_el1, 0xc000, 14) }
		inline uint32_t get(uint32_t dbgwcr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgwcr<n>_el1_val, 0xc000, 14) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgwcr<n>_el1, value, 0xc000, 14) }
		inline uint32_t set(uint32_t dbgwcr<n>_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgwcr<n>_el1, value, 0xc000, 14) }
	}

	namespace hmc
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgwcr<n>_el1, 13) }
		inline uint32_t is_enabled(uint32_t dbgwcr<n>_el1_val) noexcept { IS_BIT_ENABLED_FUNC(dbgwcr<n>_el1_val, 13) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgwcr<n>_el1, 13) }
		inline uint32_t is_disabled(uint32_t dbgwcr<n>_el1_val) noexcept { IS_BIT_DISABLED_FUNC(dbgwcr<n>_el1_val, 13) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgwcr<n>_el1, 0x2000) }
		inline uint32_t enable(uint32_t dbgwcr<n>_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgwcr<n>_el1_val, 0x2000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgwcr<n>_el1, 0x2000) }
		inline uint32_t disable(uint32_t dbgwcr<n>_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgwcr<n>_el1_val, 0x2000) }
	}

	namespace bas
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgwcr<n>_el1, 0x1fe0, 5) }
		inline uint32_t get(uint32_t dbgwcr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgwcr<n>_el1_val, 0x1fe0, 5) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgwcr<n>_el1, value, 0x1fe0, 5) }
		inline uint32_t set(uint32_t dbgwcr<n>_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgwcr<n>_el1, value, 0x1fe0, 5) }
	}

	namespace lsc
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgwcr<n>_el1, 0x18, 3) }
		inline uint32_t get(uint32_t dbgwcr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgwcr<n>_el1_val, 0x18, 3) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgwcr<n>_el1, value, 0x18, 3) }
		inline uint32_t set(uint32_t dbgwcr<n>_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgwcr<n>_el1, value, 0x18, 3) }
	}

	namespace pac
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(dbgwcr<n>_el1, 0x6, 1) }
		inline uint32_t get(uint32_t dbgwcr<n>_el1_val) noexcept { GET_BITFIELD_FUNC(dbgwcr<n>_el1_val, 0x6, 1) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(dbgwcr<n>_el1, value, 0x6, 1) }
		inline uint32_t set(uint32_t dbgwcr<n>_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(dbgwcr<n>_el1, value, 0x6, 1) }
	}

	namespace e
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(dbgwcr<n>_el1, 0) }
		inline uint32_t is_enabled(uint32_t dbgwcr<n>_el1_val) noexcept { IS_BIT_ENABLED_FUNC(dbgwcr<n>_el1_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(dbgwcr<n>_el1, 0) }
		inline uint32_t is_disabled(uint32_t dbgwcr<n>_el1_val) noexcept { IS_BIT_DISABLED_FUNC(dbgwcr<n>_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(dbgwcr<n>_el1, 0x1) }
		inline uint32_t enable(uint32_t dbgwcr<n>_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(dbgwcr<n>_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(dbgwcr<n>_el1, 0x1) }
		inline uint32_t disable(uint32_t dbgwcr<n>_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(dbgwcr<n>_el1_val, 0x1) }
	}
}

// DBGWVR<n>_EL1 (Debug Watchpoint Value Registers)
// Holds a data address value for use in watchpoint matching. Forms watchpoint n together with control register DBGWCR<n>_EL1.
namespace dbgwvr<n>_el1
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(dbgwvr<n>_el1) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(dbgwvr<n>_el1, val) }
}

// EDAA32PFR (External Debug AArch32 Processor Feature Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace edaa32pfr
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(edaa32pfr) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edaa32pfr, val) }

	namespace el3
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(edaa32pfr, 0xf000, 12) }
		inline uint64_t get(uint64_t edaa32pfr_val) noexcept { GET_BITFIELD_FUNC(edaa32pfr_val, 0xf000, 12) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edaa32pfr, value, 0xf000, 12) }
		inline uint64_t set(uint64_t edaa32pfr, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edaa32pfr, value, 0xf000, 12) }
	}

	namespace el2
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(edaa32pfr, 0xf00, 8) }
		inline uint64_t get(uint64_t edaa32pfr_val) noexcept { GET_BITFIELD_FUNC(edaa32pfr_val, 0xf00, 8) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edaa32pfr, value, 0xf00, 8) }
		inline uint64_t set(uint64_t edaa32pfr, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edaa32pfr, value, 0xf00, 8) }
	}

	namespace pmsa
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(edaa32pfr, 0xf0, 4) }
		inline uint64_t get(uint64_t edaa32pfr_val) noexcept { GET_BITFIELD_FUNC(edaa32pfr_val, 0xf0, 4) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edaa32pfr, value, 0xf0, 4) }
		inline uint64_t set(uint64_t edaa32pfr, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edaa32pfr, value, 0xf0, 4) }
	}

	namespace vmsa
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(edaa32pfr, 0xf, 0) }
		inline uint64_t get(uint64_t edaa32pfr_val) noexcept { GET_BITFIELD_FUNC(edaa32pfr_val, 0xf, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edaa32pfr, value, 0xf, 0) }
		inline uint64_t set(uint64_t edaa32pfr, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edaa32pfr, value, 0xf, 0) }
	}
}

// EDACR (External Debug Auxiliary Control Register)
// Allows implementations to support IMPLEMENTATION DEFINED controls.
namespace edacr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(edacr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edacr, val) }
}

// EDCIDR0 (External Debug Component Identification Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace edcidr0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(edcidr0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edcidr0, val) }

	namespace prmbl_0
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(edcidr0, 0xff, 0) }
		inline uint32_t get(uint32_t edcidr0_val) noexcept { GET_BITFIELD_FUNC(edcidr0_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edcidr0, value, 0xff, 0) }
		inline uint32_t set(uint32_t edcidr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edcidr0, value, 0xff, 0) }
	}
}

// EDCIDR1 (External Debug Component Identification Register 1)
// See the ARMv8 architecture reference manual for a description of this register
namespace edcidr1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(edcidr1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edcidr1, val) }

	namespace class
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(edcidr1, 0xf0, 4) }
		inline uint32_t get(uint32_t edcidr1_val) noexcept { GET_BITFIELD_FUNC(edcidr1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edcidr1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t edcidr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edcidr1, value, 0xf0, 4) }
	}

	namespace prmbl_1
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(edcidr1, 0xf, 0) }
		inline uint32_t get(uint32_t edcidr1_val) noexcept { GET_BITFIELD_FUNC(edcidr1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edcidr1, value, 0xf, 0) }
		inline uint32_t set(uint32_t edcidr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edcidr1, value, 0xf, 0) }
	}
}

// EDCIDR2 (External Debug Component Identification Register 2)
// See the ARMv8 architecture reference manual for a description of this register
namespace edcidr2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(edcidr2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edcidr2, val) }

	namespace prmbl_2
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(edcidr2, 0xff, 0) }
		inline uint32_t get(uint32_t edcidr2_val) noexcept { GET_BITFIELD_FUNC(edcidr2_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edcidr2, value, 0xff, 0) }
		inline uint32_t set(uint32_t edcidr2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edcidr2, value, 0xff, 0) }
	}
}

// EDCIDR3 (External Debug Component Identification Register 3)
// See the ARMv8 architecture reference manual for a description of this register
namespace edcidr3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(edcidr3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edcidr3, val) }

	namespace prmbl_3
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(edcidr3, 0xff, 0) }
		inline uint32_t get(uint32_t edcidr3_val) noexcept { GET_BITFIELD_FUNC(edcidr3_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edcidr3, value, 0xff, 0) }
		inline uint32_t set(uint32_t edcidr3, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edcidr3, value, 0xff, 0) }
	}
}

// EDCIDSR (External Debug Context ID Sample Register)
// Contains the sampled value of the Context ID, captured on reading EDPCSR[31:0].
namespace edcidsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(edcidsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edcidsr, val) }

	// Fieldset valid when: ARMv8.2-PCSample is not implemented
	namespace fieldset_1
	{
		namespace contextidr
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(edcidsr, 0xffffffff, 0) }
			inline uint32_t get(uint32_t edcidsr_val) noexcept { GET_BITFIELD_FUNC(edcidsr_val, 0xffffffff, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edcidsr, value, 0xffffffff, 0) }
			inline uint32_t set(uint32_t edcidsr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edcidsr, value, 0xffffffff, 0) }
		}
	}

	// Fieldset valid when: ARMv8.2-PCSample is implemented
	namespace fieldset_2
	{	}
}

// EDDEVAFF0 (External Debug Device Affinity register 0)
// Copy of the low half of the PE MPIDR_EL1 register that allows a debugger to determine which PE in a multiprocessor system the external debug component relates to.
namespace eddevaff0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(eddevaff0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(eddevaff0, val) }

	namespace none
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(eddevaff0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t eddevaff0_val) noexcept { GET_BITFIELD_FUNC(eddevaff0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(eddevaff0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t eddevaff0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(eddevaff0, value, 0xffffffff, 0) }
	}
}

// EDDEVAFF1 (External Debug Device Affinity register 1)
// Copy of the high half of the PE MPIDR_EL1 register that allows a debugger to determine which PE in a multiprocessor system the external debug component relates to.
namespace eddevaff1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(eddevaff1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(eddevaff1, val) }

	namespace none
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(eddevaff1, 0xffffffff, 0) }
		inline uint32_t get(uint32_t eddevaff1_val) noexcept { GET_BITFIELD_FUNC(eddevaff1_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(eddevaff1, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t eddevaff1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(eddevaff1, value, 0xffffffff, 0) }
	}
}

// EDDEVARCH (External Debug Device Architecture register)
// Identifies the programmers' model architecture of the external debug component.
namespace eddevarch
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(eddevarch) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(eddevarch, val) }

	namespace architect
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(eddevarch, 0xffe00000, 21) }
		inline uint32_t get(uint32_t eddevarch_val) noexcept { GET_BITFIELD_FUNC(eddevarch_val, 0xffe00000, 21) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(eddevarch, value, 0xffe00000, 21) }
		inline uint32_t set(uint32_t eddevarch, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(eddevarch, value, 0xffe00000, 21) }
	}

	namespace present
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(eddevarch, 20) }
		inline uint32_t is_enabled(uint32_t eddevarch_val) noexcept { IS_BIT_ENABLED_FUNC(eddevarch_val, 20) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(eddevarch, 20) }
		inline uint32_t is_disabled(uint32_t eddevarch_val) noexcept { IS_BIT_DISABLED_FUNC(eddevarch_val, 20) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(eddevarch, 0x100000) }
		inline uint32_t enable(uint32_t eddevarch_val) noexcept { SET_BITS_BY_MASK_FUNC(eddevarch_val, 0x100000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(eddevarch, 0x100000) }
		inline uint32_t disable(uint32_t eddevarch_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(eddevarch_val, 0x100000) }
	}

	namespace revision
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(eddevarch, 0xf0000, 16) }
		inline uint32_t get(uint32_t eddevarch_val) noexcept { GET_BITFIELD_FUNC(eddevarch_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(eddevarch, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t eddevarch, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(eddevarch, value, 0xf0000, 16) }
	}

	namespace archid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(eddevarch, 0xffff, 0) }
		inline uint32_t get(uint32_t eddevarch_val) noexcept { GET_BITFIELD_FUNC(eddevarch_val, 0xffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(eddevarch, value, 0xffff, 0) }
		inline uint32_t set(uint32_t eddevarch, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(eddevarch, value, 0xffff, 0) }
	}
}

// EDDEVID (External Debug Device ID register 0)
// Provides extra information for external debuggers about features of the debug implementation.
namespace eddevid
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(eddevid) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(eddevid, val) }

	namespace auxregs
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(eddevid, 0xf000000, 24) }
		inline uint32_t get(uint32_t eddevid_val) noexcept { GET_BITFIELD_FUNC(eddevid_val, 0xf000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(eddevid, value, 0xf000000, 24) }
		inline uint32_t set(uint32_t eddevid, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(eddevid, value, 0xf000000, 24) }
	}

	namespace pcsample
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(eddevid, 0xf, 0) }
		inline uint32_t get(uint32_t eddevid_val) noexcept { GET_BITFIELD_FUNC(eddevid_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(eddevid, value, 0xf, 0) }
		inline uint32_t set(uint32_t eddevid, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(eddevid, value, 0xf, 0) }
	}
}

// EDDEVID1 (External Debug Device ID register 1)
// Provides extra information for external debuggers about features of the debug implementation.
namespace eddevid1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(eddevid1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(eddevid1, val) }

	namespace pcsroffset
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(eddevid1, 0xf, 0) }
		inline uint32_t get(uint32_t eddevid1_val) noexcept { GET_BITFIELD_FUNC(eddevid1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(eddevid1, value, 0xf, 0) }
		inline uint32_t set(uint32_t eddevid1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(eddevid1, value, 0xf, 0) }
	}
}

// EDDEVID2 (External Debug Device ID register 2)
// Reserved for future descriptions of features of the debug implementation.
namespace eddevid2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(eddevid2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(eddevid2, val) }
}

// EDDEVTYPE (External Debug Device Type register)
// Indicates to a debugger that this component is part of a PEs debug logic.
namespace eddevtype
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(eddevtype) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(eddevtype, val) }

	namespace sub
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(eddevtype, 0xf0, 4) }
		inline uint32_t get(uint32_t eddevtype_val) noexcept { GET_BITFIELD_FUNC(eddevtype_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(eddevtype, value, 0xf0, 4) }
		inline uint32_t set(uint32_t eddevtype, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(eddevtype, value, 0xf0, 4) }
	}

	namespace major
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(eddevtype, 0xf, 0) }
		inline uint32_t get(uint32_t eddevtype_val) noexcept { GET_BITFIELD_FUNC(eddevtype_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(eddevtype, value, 0xf, 0) }
		inline uint32_t set(uint32_t eddevtype, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(eddevtype, value, 0xf, 0) }
	}
}

// EDDFR (External Debug Feature Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace eddfr
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(eddfr) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(eddfr, val) }

	namespace ctx_cmps
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(eddfr, 0xf0000000, 28) }
		inline uint64_t get(uint64_t eddfr_val) noexcept { GET_BITFIELD_FUNC(eddfr_val, 0xf0000000, 28) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(eddfr, value, 0xf0000000, 28) }
		inline uint64_t set(uint64_t eddfr, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(eddfr, value, 0xf0000000, 28) }
	}

	namespace wrps
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(eddfr, 0xf00000, 20) }
		inline uint64_t get(uint64_t eddfr_val) noexcept { GET_BITFIELD_FUNC(eddfr_val, 0xf00000, 20) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(eddfr, value, 0xf00000, 20) }
		inline uint64_t set(uint64_t eddfr, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(eddfr, value, 0xf00000, 20) }
	}

	namespace brps
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(eddfr, 0xf000, 12) }
		inline uint64_t get(uint64_t eddfr_val) noexcept { GET_BITFIELD_FUNC(eddfr_val, 0xf000, 12) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(eddfr, value, 0xf000, 12) }
		inline uint64_t set(uint64_t eddfr, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(eddfr, value, 0xf000, 12) }
	}

	namespace pmuver
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(eddfr, 0xf00, 8) }
		inline uint64_t get(uint64_t eddfr_val) noexcept { GET_BITFIELD_FUNC(eddfr_val, 0xf00, 8) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(eddfr, value, 0xf00, 8) }
		inline uint64_t set(uint64_t eddfr, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(eddfr, value, 0xf00, 8) }
	}

	namespace tracever
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(eddfr, 0xf0, 4) }
		inline uint64_t get(uint64_t eddfr_val) noexcept { GET_BITFIELD_FUNC(eddfr_val, 0xf0, 4) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(eddfr, value, 0xf0, 4) }
		inline uint64_t set(uint64_t eddfr, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(eddfr, value, 0xf0, 4) }
	}

	namespace unknown
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(eddfr, 0xf, 0) }
		inline uint64_t get(uint64_t eddfr_val) noexcept { GET_BITFIELD_FUNC(eddfr_val, 0xf, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(eddfr, value, 0xf, 0) }
		inline uint64_t set(uint64_t eddfr, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(eddfr, value, 0xf, 0) }
	}
}

// EDECCR (External Debug Exception Catch Control Register)
// Controls Exception Catch debug events.
namespace edeccr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(edeccr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edeccr, val) }
}

// EDECR (External Debug Execution Control Register)
// Controls Halting debug events.
namespace edecr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(edecr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edecr, val) }

	namespace ss
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edecr, 2) }
		inline uint32_t is_enabled(uint32_t edecr_val) noexcept { IS_BIT_ENABLED_FUNC(edecr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edecr, 2) }
		inline uint32_t is_disabled(uint32_t edecr_val) noexcept { IS_BIT_DISABLED_FUNC(edecr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edecr, 0x4) }
		inline uint32_t enable(uint32_t edecr_val) noexcept { SET_BITS_BY_MASK_FUNC(edecr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edecr, 0x4) }
		inline uint32_t disable(uint32_t edecr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edecr_val, 0x4) }
	}

	namespace rce
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edecr, 1) }
		inline uint32_t is_enabled(uint32_t edecr_val) noexcept { IS_BIT_ENABLED_FUNC(edecr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edecr, 1) }
		inline uint32_t is_disabled(uint32_t edecr_val) noexcept { IS_BIT_DISABLED_FUNC(edecr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edecr, 0x2) }
		inline uint32_t enable(uint32_t edecr_val) noexcept { SET_BITS_BY_MASK_FUNC(edecr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edecr, 0x2) }
		inline uint32_t disable(uint32_t edecr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edecr_val, 0x2) }
	}

	namespace osuce
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edecr, 0) }
		inline uint32_t is_enabled(uint32_t edecr_val) noexcept { IS_BIT_ENABLED_FUNC(edecr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edecr, 0) }
		inline uint32_t is_disabled(uint32_t edecr_val) noexcept { IS_BIT_DISABLED_FUNC(edecr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edecr, 0x1) }
		inline uint32_t enable(uint32_t edecr_val) noexcept { SET_BITS_BY_MASK_FUNC(edecr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edecr, 0x1) }
		inline uint32_t disable(uint32_t edecr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edecr_val, 0x1) }
	}
}

// EDESR (External Debug Event Status Register)
// Indicates the status of internally pending Halting debug events.
namespace edesr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(edesr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edesr, val) }

	namespace ss
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edesr, 2) }
		inline uint32_t is_enabled(uint32_t edesr_val) noexcept { IS_BIT_ENABLED_FUNC(edesr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edesr, 2) }
		inline uint32_t is_disabled(uint32_t edesr_val) noexcept { IS_BIT_DISABLED_FUNC(edesr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edesr, 0x4) }
		inline uint32_t enable(uint32_t edesr_val) noexcept { SET_BITS_BY_MASK_FUNC(edesr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edesr, 0x4) }
		inline uint32_t disable(uint32_t edesr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edesr_val, 0x4) }
	}

	namespace rc
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edesr, 1) }
		inline uint32_t is_enabled(uint32_t edesr_val) noexcept { IS_BIT_ENABLED_FUNC(edesr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edesr, 1) }
		inline uint32_t is_disabled(uint32_t edesr_val) noexcept { IS_BIT_DISABLED_FUNC(edesr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edesr, 0x2) }
		inline uint32_t enable(uint32_t edesr_val) noexcept { SET_BITS_BY_MASK_FUNC(edesr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edesr, 0x2) }
		inline uint32_t disable(uint32_t edesr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edesr_val, 0x2) }
	}

	namespace osuc
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edesr, 0) }
		inline uint32_t is_enabled(uint32_t edesr_val) noexcept { IS_BIT_ENABLED_FUNC(edesr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edesr, 0) }
		inline uint32_t is_disabled(uint32_t edesr_val) noexcept { IS_BIT_DISABLED_FUNC(edesr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edesr, 0x1) }
		inline uint32_t enable(uint32_t edesr_val) noexcept { SET_BITS_BY_MASK_FUNC(edesr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edesr, 0x1) }
		inline uint32_t disable(uint32_t edesr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edesr_val, 0x1) }
	}
}

// EDITCTRL (External Debug Integration mode Control register)
// Enables the external debug to switch from its default mode into integration mode, where test software can control directly the inputs and outputs of the PE, for integration testing or topology detection.
namespace editctrl
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(editctrl) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(editctrl, val) }

	namespace ime
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(editctrl, 0) }
		inline uint32_t is_enabled(uint32_t editctrl_val) noexcept { IS_BIT_ENABLED_FUNC(editctrl_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(editctrl, 0) }
		inline uint32_t is_disabled(uint32_t editctrl_val) noexcept { IS_BIT_DISABLED_FUNC(editctrl_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(editctrl, 0x1) }
		inline uint32_t enable(uint32_t editctrl_val) noexcept { SET_BITS_BY_MASK_FUNC(editctrl_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(editctrl, 0x1) }
		inline uint32_t disable(uint32_t editctrl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(editctrl_val, 0x1) }
	}
}

// EDITR (External Debug Instruction Transfer Register)
// Used in Debug state for passing instructions to the PE for execution.
namespace editr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(editr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(editr, val) }

	// Fieldset valid when: in AArch32 state
	namespace fieldset_1
	{
		namespace t32second
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(editr, 0xffff0000, 16) }
			inline uint32_t get(uint32_t editr_val) noexcept { GET_BITFIELD_FUNC(editr_val, 0xffff0000, 16) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(editr, value, 0xffff0000, 16) }
			inline uint32_t set(uint32_t editr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(editr, value, 0xffff0000, 16) }
		}

		namespace t32first
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(editr, 0xffff, 0) }
			inline uint32_t get(uint32_t editr_val) noexcept { GET_BITFIELD_FUNC(editr_val, 0xffff, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(editr, value, 0xffff, 0) }
			inline uint32_t set(uint32_t editr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(editr, value, 0xffff, 0) }
		}
	}

	// Fieldset valid when: in AArch64 state
	namespace fieldset_2
	{
		namespace a64_instruction_to_be_executed_on_the_pe
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(editr, 0xffffffff, 0) }
			inline uint32_t get(uint32_t editr_val) noexcept { GET_BITFIELD_FUNC(editr_val, 0xffffffff, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(editr, value, 0xffffffff, 0) }
			inline uint32_t set(uint32_t editr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(editr, value, 0xffffffff, 0) }
		}
	}
}

// EDLAR (External Debug Lock Access Register)
// Allows or disallows access to the external debug registers through a memory-mapped interface.
namespace edlar
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(edlar) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edlar, val) }

	namespace key
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(edlar, 0xffffffff, 0) }
		inline uint32_t get(uint32_t edlar_val) noexcept { GET_BITFIELD_FUNC(edlar_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edlar, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t edlar, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edlar, value, 0xffffffff, 0) }
	}
}

// EDLSR (External Debug Lock Status Register)
// Indicates the current status of the software lock for external debug registers.
namespace edlsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(edlsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edlsr, val) }

	namespace ntt
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edlsr, 2) }
		inline uint32_t is_enabled(uint32_t edlsr_val) noexcept { IS_BIT_ENABLED_FUNC(edlsr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edlsr, 2) }
		inline uint32_t is_disabled(uint32_t edlsr_val) noexcept { IS_BIT_DISABLED_FUNC(edlsr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edlsr, 0x4) }
		inline uint32_t enable(uint32_t edlsr_val) noexcept { SET_BITS_BY_MASK_FUNC(edlsr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edlsr, 0x4) }
		inline uint32_t disable(uint32_t edlsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edlsr_val, 0x4) }
	}

	namespace slk
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edlsr, 1) }
		inline uint32_t is_enabled(uint32_t edlsr_val) noexcept { IS_BIT_ENABLED_FUNC(edlsr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edlsr, 1) }
		inline uint32_t is_disabled(uint32_t edlsr_val) noexcept { IS_BIT_DISABLED_FUNC(edlsr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edlsr, 0x2) }
		inline uint32_t enable(uint32_t edlsr_val) noexcept { SET_BITS_BY_MASK_FUNC(edlsr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edlsr, 0x2) }
		inline uint32_t disable(uint32_t edlsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edlsr_val, 0x2) }
	}

	namespace sli
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edlsr, 0) }
		inline uint32_t is_enabled(uint32_t edlsr_val) noexcept { IS_BIT_ENABLED_FUNC(edlsr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edlsr, 0) }
		inline uint32_t is_disabled(uint32_t edlsr_val) noexcept { IS_BIT_DISABLED_FUNC(edlsr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edlsr, 0x1) }
		inline uint32_t enable(uint32_t edlsr_val) noexcept { SET_BITS_BY_MASK_FUNC(edlsr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edlsr, 0x1) }
		inline uint32_t disable(uint32_t edlsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edlsr_val, 0x1) }
	}
}

// EDPCSR (External Debug Program Counter Sample Register)
// Holds a sampled instruction address value.
namespace edpcsr
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(edpcsr) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edpcsr, val) }

	// Fieldset valid when: ARMv8.1-VHE is not implemented
	namespace fieldset_1
	{
		namespace pc_sample_high_word,_edpcsrhi
		{
			inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(edpcsr, 0xffffffff00000000, 32) }
			inline uint64_t get(uint64_t edpcsr_val) noexcept { GET_BITFIELD_FUNC(edpcsr_val, 0xffffffff00000000, 32) }
			inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edpcsr, value, 0xffffffff00000000, 32) }
			inline uint64_t set(uint64_t edpcsr, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edpcsr, value, 0xffffffff00000000, 32) }
		}

		namespace pc_sample_low_word
		{
			inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(edpcsr, 0xffffffff, 0) }
			inline uint64_t get(uint64_t edpcsr_val) noexcept { GET_BITFIELD_FUNC(edpcsr_val, 0xffffffff, 0) }
			inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edpcsr, value, 0xffffffff, 0) }
			inline uint64_t set(uint64_t edpcsr, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edpcsr, value, 0xffffffff, 0) }
		}
	}

	// Fieldset valid when: ARMv8.1-VHE is implemented and EDSCR.SC2 == 0
	namespace fieldset_2
	{
		namespace pc_sample_high_word,_edpcsrhi
		{
			inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(edpcsr, 0xffffffff00000000, 32) }
			inline uint64_t get(uint64_t edpcsr_val) noexcept { GET_BITFIELD_FUNC(edpcsr_val, 0xffffffff00000000, 32) }
			inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edpcsr, value, 0xffffffff00000000, 32) }
			inline uint64_t set(uint64_t edpcsr, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edpcsr, value, 0xffffffff00000000, 32) }
		}

		namespace pc_sample_low_word
		{
			inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(edpcsr, 0xffffffff, 0) }
			inline uint64_t get(uint64_t edpcsr_val) noexcept { GET_BITFIELD_FUNC(edpcsr_val, 0xffffffff, 0) }
			inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edpcsr, value, 0xffffffff, 0) }
			inline uint64_t set(uint64_t edpcsr, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edpcsr, value, 0xffffffff, 0) }
		}
	}

	// Fieldset valid when: ARMv8.1-VHE is implemented and EDSCR.SC2 == 1
	namespace fieldset_3
	{
		namespace ns
		{
			inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edpcsr, 63) }
			inline uint64_t is_enabled(uint64_t edpcsr_val) noexcept { IS_BIT_ENABLED_FUNC(edpcsr_val, 63) }
			inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edpcsr, 63) }
			inline uint64_t is_disabled(uint64_t edpcsr_val) noexcept { IS_BIT_DISABLED_FUNC(edpcsr_val, 63) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edpcsr, 0x8000000000000000) }
			inline uint64_t enable(uint64_t edpcsr_val) noexcept { SET_BITS_BY_MASK_FUNC(edpcsr_val, 0x8000000000000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edpcsr, 0x8000000000000000) }
			inline uint64_t disable(uint64_t edpcsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edpcsr_val, 0x8000000000000000) }
		}

		namespace el
		{
			inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(edpcsr, 0x6000000000000000, 61) }
			inline uint64_t get(uint64_t edpcsr_val) noexcept { GET_BITFIELD_FUNC(edpcsr_val, 0x6000000000000000, 61) }
			inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edpcsr, value, 0x6000000000000000, 61) }
			inline uint64_t set(uint64_t edpcsr, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edpcsr, value, 0x6000000000000000, 61) }
		}

		namespace pc_sample_high_word,_edpcsrhi
		{
			inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(edpcsr, 0xffffff00000000, 32) }
			inline uint64_t get(uint64_t edpcsr_val) noexcept { GET_BITFIELD_FUNC(edpcsr_val, 0xffffff00000000, 32) }
			inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edpcsr, value, 0xffffff00000000, 32) }
			inline uint64_t set(uint64_t edpcsr, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edpcsr, value, 0xffffff00000000, 32) }
		}

		namespace pc_sample_low_word
		{
			inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(edpcsr, 0xffffffff, 0) }
			inline uint64_t get(uint64_t edpcsr_val) noexcept { GET_BITFIELD_FUNC(edpcsr_val, 0xffffffff, 0) }
			inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edpcsr, value, 0xffffffff, 0) }
			inline uint64_t set(uint64_t edpcsr, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edpcsr, value, 0xffffffff, 0) }
		}
	}

	// Fieldset valid when: ARMv8.2-PCSample is implemented
	namespace fieldset_4
	{	}
}

// EDPFR (External Debug Processor Feature Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace edpfr
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(edpfr) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edpfr, val) }
}

// EDPIDR0 (External Debug Peripheral Identification Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace edpidr0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(edpidr0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edpidr0, val) }

	namespace part_0
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(edpidr0, 0xff, 0) }
		inline uint32_t get(uint32_t edpidr0_val) noexcept { GET_BITFIELD_FUNC(edpidr0_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edpidr0, value, 0xff, 0) }
		inline uint32_t set(uint32_t edpidr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edpidr0, value, 0xff, 0) }
	}
}

// EDPIDR1 (External Debug Peripheral Identification Register 1)
// See the ARMv8 architecture reference manual for a description of this register
namespace edpidr1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(edpidr1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edpidr1, val) }

	namespace des_0
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(edpidr1, 0xf0, 4) }
		inline uint32_t get(uint32_t edpidr1_val) noexcept { GET_BITFIELD_FUNC(edpidr1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edpidr1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t edpidr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edpidr1, value, 0xf0, 4) }
	}

	namespace part_1
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(edpidr1, 0xf, 0) }
		inline uint32_t get(uint32_t edpidr1_val) noexcept { GET_BITFIELD_FUNC(edpidr1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edpidr1, value, 0xf, 0) }
		inline uint32_t set(uint32_t edpidr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edpidr1, value, 0xf, 0) }
	}
}

// EDPIDR2 (External Debug Peripheral Identification Register 2)
// See the ARMv8 architecture reference manual for a description of this register
namespace edpidr2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(edpidr2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edpidr2, val) }

	namespace revision
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(edpidr2, 0xf0, 4) }
		inline uint32_t get(uint32_t edpidr2_val) noexcept { GET_BITFIELD_FUNC(edpidr2_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edpidr2, value, 0xf0, 4) }
		inline uint32_t set(uint32_t edpidr2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edpidr2, value, 0xf0, 4) }
	}

	namespace jedec
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edpidr2, 3) }
		inline uint32_t is_enabled(uint32_t edpidr2_val) noexcept { IS_BIT_ENABLED_FUNC(edpidr2_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edpidr2, 3) }
		inline uint32_t is_disabled(uint32_t edpidr2_val) noexcept { IS_BIT_DISABLED_FUNC(edpidr2_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edpidr2, 0x8) }
		inline uint32_t enable(uint32_t edpidr2_val) noexcept { SET_BITS_BY_MASK_FUNC(edpidr2_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edpidr2, 0x8) }
		inline uint32_t disable(uint32_t edpidr2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edpidr2_val, 0x8) }
	}

	namespace des_1
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(edpidr2, 0x7, 0) }
		inline uint32_t get(uint32_t edpidr2_val) noexcept { GET_BITFIELD_FUNC(edpidr2_val, 0x7, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edpidr2, value, 0x7, 0) }
		inline uint32_t set(uint32_t edpidr2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edpidr2, value, 0x7, 0) }
	}
}

// EDPIDR3 (External Debug Peripheral Identification Register 3)
// See the ARMv8 architecture reference manual for a description of this register
namespace edpidr3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(edpidr3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edpidr3, val) }

	namespace revand
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(edpidr3, 0xf0, 4) }
		inline uint32_t get(uint32_t edpidr3_val) noexcept { GET_BITFIELD_FUNC(edpidr3_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edpidr3, value, 0xf0, 4) }
		inline uint32_t set(uint32_t edpidr3, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edpidr3, value, 0xf0, 4) }
	}

	namespace cmod
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(edpidr3, 0xf, 0) }
		inline uint32_t get(uint32_t edpidr3_val) noexcept { GET_BITFIELD_FUNC(edpidr3_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edpidr3, value, 0xf, 0) }
		inline uint32_t set(uint32_t edpidr3, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edpidr3, value, 0xf, 0) }
	}
}

// EDPIDR4 (External Debug Peripheral Identification Register 4)
// See the ARMv8 architecture reference manual for a description of this register
namespace edpidr4
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(edpidr4) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edpidr4, val) }

	namespace size
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(edpidr4, 0xf0, 4) }
		inline uint32_t get(uint32_t edpidr4_val) noexcept { GET_BITFIELD_FUNC(edpidr4_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edpidr4, value, 0xf0, 4) }
		inline uint32_t set(uint32_t edpidr4, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edpidr4, value, 0xf0, 4) }
	}

	namespace des_2
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(edpidr4, 0xf, 0) }
		inline uint32_t get(uint32_t edpidr4_val) noexcept { GET_BITFIELD_FUNC(edpidr4_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edpidr4, value, 0xf, 0) }
		inline uint32_t set(uint32_t edpidr4, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edpidr4, value, 0xf, 0) }
	}
}

// EDPRCR (External Debug Power/Reset Control Register)
// Controls the PE functionality related to powerup, reset, and powerdown.
namespace edprcr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(edprcr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edprcr, val) }

	namespace corepurq
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edprcr, 3) }
		inline uint32_t is_enabled(uint32_t edprcr_val) noexcept { IS_BIT_ENABLED_FUNC(edprcr_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edprcr, 3) }
		inline uint32_t is_disabled(uint32_t edprcr_val) noexcept { IS_BIT_DISABLED_FUNC(edprcr_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edprcr, 0x8) }
		inline uint32_t enable(uint32_t edprcr_val) noexcept { SET_BITS_BY_MASK_FUNC(edprcr_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edprcr, 0x8) }
		inline uint32_t disable(uint32_t edprcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edprcr_val, 0x8) }
	}

	namespace cwrr
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edprcr, 1) }
		inline uint32_t is_enabled(uint32_t edprcr_val) noexcept { IS_BIT_ENABLED_FUNC(edprcr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edprcr, 1) }
		inline uint32_t is_disabled(uint32_t edprcr_val) noexcept { IS_BIT_DISABLED_FUNC(edprcr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edprcr, 0x2) }
		inline uint32_t enable(uint32_t edprcr_val) noexcept { SET_BITS_BY_MASK_FUNC(edprcr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edprcr, 0x2) }
		inline uint32_t disable(uint32_t edprcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edprcr_val, 0x2) }
	}

	namespace corenpdrq
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edprcr, 0) }
		inline uint32_t is_enabled(uint32_t edprcr_val) noexcept { IS_BIT_ENABLED_FUNC(edprcr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edprcr, 0) }
		inline uint32_t is_disabled(uint32_t edprcr_val) noexcept { IS_BIT_DISABLED_FUNC(edprcr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edprcr, 0x1) }
		inline uint32_t enable(uint32_t edprcr_val) noexcept { SET_BITS_BY_MASK_FUNC(edprcr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edprcr, 0x1) }
		inline uint32_t disable(uint32_t edprcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edprcr_val, 0x1) }
	}
}

// EDPRSR (External Debug Processor Status Register)
// Holds information about the reset and powerdown state of the PE.
namespace edprsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(edprsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edprsr, val) }

	namespace sdr
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edprsr, 11) }
		inline uint32_t is_enabled(uint32_t edprsr_val) noexcept { IS_BIT_ENABLED_FUNC(edprsr_val, 11) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edprsr, 11) }
		inline uint32_t is_disabled(uint32_t edprsr_val) noexcept { IS_BIT_DISABLED_FUNC(edprsr_val, 11) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edprsr, 0x800) }
		inline uint32_t enable(uint32_t edprsr_val) noexcept { SET_BITS_BY_MASK_FUNC(edprsr_val, 0x800) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edprsr, 0x800) }
		inline uint32_t disable(uint32_t edprsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edprsr_val, 0x800) }
	}

	namespace spmad
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edprsr, 10) }
		inline uint32_t is_enabled(uint32_t edprsr_val) noexcept { IS_BIT_ENABLED_FUNC(edprsr_val, 10) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edprsr, 10) }
		inline uint32_t is_disabled(uint32_t edprsr_val) noexcept { IS_BIT_DISABLED_FUNC(edprsr_val, 10) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edprsr, 0x400) }
		inline uint32_t enable(uint32_t edprsr_val) noexcept { SET_BITS_BY_MASK_FUNC(edprsr_val, 0x400) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edprsr, 0x400) }
		inline uint32_t disable(uint32_t edprsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edprsr_val, 0x400) }
	}

	namespace epmad
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edprsr, 9) }
		inline uint32_t is_enabled(uint32_t edprsr_val) noexcept { IS_BIT_ENABLED_FUNC(edprsr_val, 9) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edprsr, 9) }
		inline uint32_t is_disabled(uint32_t edprsr_val) noexcept { IS_BIT_DISABLED_FUNC(edprsr_val, 9) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edprsr, 0x200) }
		inline uint32_t enable(uint32_t edprsr_val) noexcept { SET_BITS_BY_MASK_FUNC(edprsr_val, 0x200) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edprsr, 0x200) }
		inline uint32_t disable(uint32_t edprsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edprsr_val, 0x200) }
	}

	namespace sdad
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edprsr, 8) }
		inline uint32_t is_enabled(uint32_t edprsr_val) noexcept { IS_BIT_ENABLED_FUNC(edprsr_val, 8) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edprsr, 8) }
		inline uint32_t is_disabled(uint32_t edprsr_val) noexcept { IS_BIT_DISABLED_FUNC(edprsr_val, 8) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edprsr, 0x100) }
		inline uint32_t enable(uint32_t edprsr_val) noexcept { SET_BITS_BY_MASK_FUNC(edprsr_val, 0x100) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edprsr, 0x100) }
		inline uint32_t disable(uint32_t edprsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edprsr_val, 0x100) }
	}

	namespace edad
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edprsr, 7) }
		inline uint32_t is_enabled(uint32_t edprsr_val) noexcept { IS_BIT_ENABLED_FUNC(edprsr_val, 7) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edprsr, 7) }
		inline uint32_t is_disabled(uint32_t edprsr_val) noexcept { IS_BIT_DISABLED_FUNC(edprsr_val, 7) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edprsr, 0x80) }
		inline uint32_t enable(uint32_t edprsr_val) noexcept { SET_BITS_BY_MASK_FUNC(edprsr_val, 0x80) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edprsr, 0x80) }
		inline uint32_t disable(uint32_t edprsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edprsr_val, 0x80) }
	}

	namespace dlk
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edprsr, 6) }
		inline uint32_t is_enabled(uint32_t edprsr_val) noexcept { IS_BIT_ENABLED_FUNC(edprsr_val, 6) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edprsr, 6) }
		inline uint32_t is_disabled(uint32_t edprsr_val) noexcept { IS_BIT_DISABLED_FUNC(edprsr_val, 6) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edprsr, 0x40) }
		inline uint32_t enable(uint32_t edprsr_val) noexcept { SET_BITS_BY_MASK_FUNC(edprsr_val, 0x40) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edprsr, 0x40) }
		inline uint32_t disable(uint32_t edprsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edprsr_val, 0x40) }
	}

	namespace oslk
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edprsr, 5) }
		inline uint32_t is_enabled(uint32_t edprsr_val) noexcept { IS_BIT_ENABLED_FUNC(edprsr_val, 5) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edprsr, 5) }
		inline uint32_t is_disabled(uint32_t edprsr_val) noexcept { IS_BIT_DISABLED_FUNC(edprsr_val, 5) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edprsr, 0x20) }
		inline uint32_t enable(uint32_t edprsr_val) noexcept { SET_BITS_BY_MASK_FUNC(edprsr_val, 0x20) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edprsr, 0x20) }
		inline uint32_t disable(uint32_t edprsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edprsr_val, 0x20) }
	}

	namespace halted
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edprsr, 4) }
		inline uint32_t is_enabled(uint32_t edprsr_val) noexcept { IS_BIT_ENABLED_FUNC(edprsr_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edprsr, 4) }
		inline uint32_t is_disabled(uint32_t edprsr_val) noexcept { IS_BIT_DISABLED_FUNC(edprsr_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edprsr, 0x10) }
		inline uint32_t enable(uint32_t edprsr_val) noexcept { SET_BITS_BY_MASK_FUNC(edprsr_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edprsr, 0x10) }
		inline uint32_t disable(uint32_t edprsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edprsr_val, 0x10) }
	}

	namespace sr
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edprsr, 3) }
		inline uint32_t is_enabled(uint32_t edprsr_val) noexcept { IS_BIT_ENABLED_FUNC(edprsr_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edprsr, 3) }
		inline uint32_t is_disabled(uint32_t edprsr_val) noexcept { IS_BIT_DISABLED_FUNC(edprsr_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edprsr, 0x8) }
		inline uint32_t enable(uint32_t edprsr_val) noexcept { SET_BITS_BY_MASK_FUNC(edprsr_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edprsr, 0x8) }
		inline uint32_t disable(uint32_t edprsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edprsr_val, 0x8) }
	}

	namespace r
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edprsr, 2) }
		inline uint32_t is_enabled(uint32_t edprsr_val) noexcept { IS_BIT_ENABLED_FUNC(edprsr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edprsr, 2) }
		inline uint32_t is_disabled(uint32_t edprsr_val) noexcept { IS_BIT_DISABLED_FUNC(edprsr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edprsr, 0x4) }
		inline uint32_t enable(uint32_t edprsr_val) noexcept { SET_BITS_BY_MASK_FUNC(edprsr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edprsr, 0x4) }
		inline uint32_t disable(uint32_t edprsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edprsr_val, 0x4) }
	}

	namespace spd
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edprsr, 1) }
		inline uint32_t is_enabled(uint32_t edprsr_val) noexcept { IS_BIT_ENABLED_FUNC(edprsr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edprsr, 1) }
		inline uint32_t is_disabled(uint32_t edprsr_val) noexcept { IS_BIT_DISABLED_FUNC(edprsr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edprsr, 0x2) }
		inline uint32_t enable(uint32_t edprsr_val) noexcept { SET_BITS_BY_MASK_FUNC(edprsr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edprsr, 0x2) }
		inline uint32_t disable(uint32_t edprsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edprsr_val, 0x2) }
	}

	namespace pu
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edprsr, 0) }
		inline uint32_t is_enabled(uint32_t edprsr_val) noexcept { IS_BIT_ENABLED_FUNC(edprsr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edprsr, 0) }
		inline uint32_t is_disabled(uint32_t edprsr_val) noexcept { IS_BIT_DISABLED_FUNC(edprsr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edprsr, 0x1) }
		inline uint32_t enable(uint32_t edprsr_val) noexcept { SET_BITS_BY_MASK_FUNC(edprsr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edprsr, 0x1) }
		inline uint32_t disable(uint32_t edprsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edprsr_val, 0x1) }
	}
}

// EDRCR (External Debug Reserve Control Register)
// This register is used to allow imprecise entry to Debug state and clear sticky bits in EDSCR.
namespace edrcr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(edrcr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edrcr, val) }

	namespace cbrrq
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edrcr, 4) }
		inline uint32_t is_enabled(uint32_t edrcr_val) noexcept { IS_BIT_ENABLED_FUNC(edrcr_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edrcr, 4) }
		inline uint32_t is_disabled(uint32_t edrcr_val) noexcept { IS_BIT_DISABLED_FUNC(edrcr_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edrcr, 0x10) }
		inline uint32_t enable(uint32_t edrcr_val) noexcept { SET_BITS_BY_MASK_FUNC(edrcr_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edrcr, 0x10) }
		inline uint32_t disable(uint32_t edrcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edrcr_val, 0x10) }
	}

	namespace cspa
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edrcr, 3) }
		inline uint32_t is_enabled(uint32_t edrcr_val) noexcept { IS_BIT_ENABLED_FUNC(edrcr_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edrcr, 3) }
		inline uint32_t is_disabled(uint32_t edrcr_val) noexcept { IS_BIT_DISABLED_FUNC(edrcr_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edrcr, 0x8) }
		inline uint32_t enable(uint32_t edrcr_val) noexcept { SET_BITS_BY_MASK_FUNC(edrcr_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edrcr, 0x8) }
		inline uint32_t disable(uint32_t edrcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edrcr_val, 0x8) }
	}

	namespace cse
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edrcr, 2) }
		inline uint32_t is_enabled(uint32_t edrcr_val) noexcept { IS_BIT_ENABLED_FUNC(edrcr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edrcr, 2) }
		inline uint32_t is_disabled(uint32_t edrcr_val) noexcept { IS_BIT_DISABLED_FUNC(edrcr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edrcr, 0x4) }
		inline uint32_t enable(uint32_t edrcr_val) noexcept { SET_BITS_BY_MASK_FUNC(edrcr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edrcr, 0x4) }
		inline uint32_t disable(uint32_t edrcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edrcr_val, 0x4) }
	}
}

// EDSCR (External Debug Status and Control Register)
// Main control register for the debug implementation.
namespace edscr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(edscr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edscr, val) }
}

// EDVIDSR (External Debug Virtual Context Sample Register)
// Contains sampled values captured on reading EDPCSR[31:0].
namespace edvidsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(edvidsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edvidsr, val) }

	// Fieldset valid when: ARMv8.1-VHE is not implemented
	namespace fieldset_1
	{
		namespace ns
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edvidsr, 31) }
			inline uint32_t is_enabled(uint32_t edvidsr_val) noexcept { IS_BIT_ENABLED_FUNC(edvidsr_val, 31) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edvidsr, 31) }
			inline uint32_t is_disabled(uint32_t edvidsr_val) noexcept { IS_BIT_DISABLED_FUNC(edvidsr_val, 31) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edvidsr, 0x80000000) }
			inline uint32_t enable(uint32_t edvidsr_val) noexcept { SET_BITS_BY_MASK_FUNC(edvidsr_val, 0x80000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edvidsr, 0x80000000) }
			inline uint32_t disable(uint32_t edvidsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edvidsr_val, 0x80000000) }
		}

		namespace e2
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edvidsr, 30) }
			inline uint32_t is_enabled(uint32_t edvidsr_val) noexcept { IS_BIT_ENABLED_FUNC(edvidsr_val, 30) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edvidsr, 30) }
			inline uint32_t is_disabled(uint32_t edvidsr_val) noexcept { IS_BIT_DISABLED_FUNC(edvidsr_val, 30) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edvidsr, 0x40000000) }
			inline uint32_t enable(uint32_t edvidsr_val) noexcept { SET_BITS_BY_MASK_FUNC(edvidsr_val, 0x40000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edvidsr, 0x40000000) }
			inline uint32_t disable(uint32_t edvidsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edvidsr_val, 0x40000000) }
		}

		namespace e3
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edvidsr, 29) }
			inline uint32_t is_enabled(uint32_t edvidsr_val) noexcept { IS_BIT_ENABLED_FUNC(edvidsr_val, 29) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edvidsr, 29) }
			inline uint32_t is_disabled(uint32_t edvidsr_val) noexcept { IS_BIT_DISABLED_FUNC(edvidsr_val, 29) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edvidsr, 0x20000000) }
			inline uint32_t enable(uint32_t edvidsr_val) noexcept { SET_BITS_BY_MASK_FUNC(edvidsr_val, 0x20000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edvidsr, 0x20000000) }
			inline uint32_t disable(uint32_t edvidsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edvidsr_val, 0x20000000) }
		}

		namespace hv
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edvidsr, 28) }
			inline uint32_t is_enabled(uint32_t edvidsr_val) noexcept { IS_BIT_ENABLED_FUNC(edvidsr_val, 28) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edvidsr, 28) }
			inline uint32_t is_disabled(uint32_t edvidsr_val) noexcept { IS_BIT_DISABLED_FUNC(edvidsr_val, 28) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edvidsr, 0x10000000) }
			inline uint32_t enable(uint32_t edvidsr_val) noexcept { SET_BITS_BY_MASK_FUNC(edvidsr_val, 0x10000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edvidsr, 0x10000000) }
			inline uint32_t disable(uint32_t edvidsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edvidsr_val, 0x10000000) }
		}

		namespace vmid
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(edvidsr, 0xff, 0) }
			inline uint32_t get(uint32_t edvidsr_val) noexcept { GET_BITFIELD_FUNC(edvidsr_val, 0xff, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edvidsr, value, 0xff, 0) }
			inline uint32_t set(uint32_t edvidsr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edvidsr, value, 0xff, 0) }
		}
	}

	// Fieldset valid when: ARMv8.1-VHE is implemented and EDSCR.SC2 == 0
	namespace fieldset_2
	{
		namespace ns
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edvidsr, 31) }
			inline uint32_t is_enabled(uint32_t edvidsr_val) noexcept { IS_BIT_ENABLED_FUNC(edvidsr_val, 31) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edvidsr, 31) }
			inline uint32_t is_disabled(uint32_t edvidsr_val) noexcept { IS_BIT_DISABLED_FUNC(edvidsr_val, 31) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edvidsr, 0x80000000) }
			inline uint32_t enable(uint32_t edvidsr_val) noexcept { SET_BITS_BY_MASK_FUNC(edvidsr_val, 0x80000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edvidsr, 0x80000000) }
			inline uint32_t disable(uint32_t edvidsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edvidsr_val, 0x80000000) }
		}

		namespace e2
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edvidsr, 30) }
			inline uint32_t is_enabled(uint32_t edvidsr_val) noexcept { IS_BIT_ENABLED_FUNC(edvidsr_val, 30) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edvidsr, 30) }
			inline uint32_t is_disabled(uint32_t edvidsr_val) noexcept { IS_BIT_DISABLED_FUNC(edvidsr_val, 30) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edvidsr, 0x40000000) }
			inline uint32_t enable(uint32_t edvidsr_val) noexcept { SET_BITS_BY_MASK_FUNC(edvidsr_val, 0x40000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edvidsr, 0x40000000) }
			inline uint32_t disable(uint32_t edvidsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edvidsr_val, 0x40000000) }
		}

		namespace e3
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edvidsr, 29) }
			inline uint32_t is_enabled(uint32_t edvidsr_val) noexcept { IS_BIT_ENABLED_FUNC(edvidsr_val, 29) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edvidsr, 29) }
			inline uint32_t is_disabled(uint32_t edvidsr_val) noexcept { IS_BIT_DISABLED_FUNC(edvidsr_val, 29) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edvidsr, 0x20000000) }
			inline uint32_t enable(uint32_t edvidsr_val) noexcept { SET_BITS_BY_MASK_FUNC(edvidsr_val, 0x20000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edvidsr, 0x20000000) }
			inline uint32_t disable(uint32_t edvidsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edvidsr_val, 0x20000000) }
		}

		namespace hv
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(edvidsr, 28) }
			inline uint32_t is_enabled(uint32_t edvidsr_val) noexcept { IS_BIT_ENABLED_FUNC(edvidsr_val, 28) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(edvidsr, 28) }
			inline uint32_t is_disabled(uint32_t edvidsr_val) noexcept { IS_BIT_DISABLED_FUNC(edvidsr_val, 28) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(edvidsr, 0x10000000) }
			inline uint32_t enable(uint32_t edvidsr_val) noexcept { SET_BITS_BY_MASK_FUNC(edvidsr_val, 0x10000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(edvidsr, 0x10000000) }
			inline uint32_t disable(uint32_t edvidsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(edvidsr_val, 0x10000000) }
		}

		namespace vmid
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(edvidsr, 0xffff, 0) }
			inline uint32_t get(uint32_t edvidsr_val) noexcept { GET_BITFIELD_FUNC(edvidsr_val, 0xffff, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edvidsr, value, 0xffff, 0) }
			inline uint32_t set(uint32_t edvidsr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edvidsr, value, 0xffff, 0) }
		}
	}

	// Fieldset valid when: ARMv8.1-VHE is implemented and EDSCR.SC2 == 1
	namespace fieldset_3
	{
		namespace contextidr_el2
		{
			inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(edvidsr, 0xffffffff, 0) }
			inline uint32_t get(uint32_t edvidsr_val) noexcept { GET_BITFIELD_FUNC(edvidsr_val, 0xffffffff, 0) }
			inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edvidsr, value, 0xffffffff, 0) }
			inline uint32_t set(uint32_t edvidsr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edvidsr, value, 0xffffffff, 0) }
		}
	}

	// Fieldset valid when: ARMv8.2-PCSample is implemented
	namespace fieldset_4
	{	}
}

// EDWAR (External Debug Watchpoint Address Register)
// Returns the virtual data address being accessed when a Watchpoint Debug Event was triggered.
namespace edwar
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(edwar) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(edwar, val) }

	namespace watchpoint_address
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(edwar, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t edwar_val) noexcept { GET_BITFIELD_FUNC(edwar_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(edwar, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t edwar, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(edwar, value, 0xffffffffffffffff, 0) }
	}
}

// GICC_ABPR (CPU Interface Aliased Binary Point Register)
// Defines the point at which the priority value fields split into two parts, the group priority field and the subpriority field. The group priority field determines Group 1 interrupt preemption.
namespace gicc_abpr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicc_abpr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicc_abpr, val) }

	namespace binary_point
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicc_abpr, 0x7, 0) }
		inline uint32_t get(uint32_t gicc_abpr_val) noexcept { GET_BITFIELD_FUNC(gicc_abpr_val, 0x7, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicc_abpr, value, 0x7, 0) }
		inline uint32_t set(uint32_t gicc_abpr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicc_abpr, value, 0x7, 0) }
	}
}

// GICC_AEOIR (CPU Interface Aliased End Of Interrupt Register)
// A write to this register performs priority drop for the specified Group 1 interrupt and, if the appropriate GICC_CTLR.EOImodeS or GICC_CTLR.EOImodeNS field == 0, also deactivates the interrupt.
namespace gicc_aeoir
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicc_aeoir) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicc_aeoir, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicc_aeoir, 0xffffff, 0) }
		inline uint32_t get(uint32_t gicc_aeoir_val) noexcept { GET_BITFIELD_FUNC(gicc_aeoir_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicc_aeoir, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t gicc_aeoir, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicc_aeoir, value, 0xffffff, 0) }
	}
}

// GICC_AHPPIR (CPU Interface Aliased Highest Priority Pending Interrupt Register)
// If the highest priority pending interrupt is in Group 1, this register provides the INTID of the highest priority pending interrupt on the CPU interface.
namespace gicc_ahppir
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicc_ahppir) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicc_ahppir, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicc_ahppir, 0xffffff, 0) }
		inline uint32_t get(uint32_t gicc_ahppir_val) noexcept { GET_BITFIELD_FUNC(gicc_ahppir_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicc_ahppir, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t gicc_ahppir, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicc_ahppir, value, 0xffffff, 0) }
	}
}

// GICC_AIAR (CPU Interface Aliased Interrupt Acknowledge Register)
// Provides the INTID of the signaled Group 1 interrupt. A read of this register by the PE acts as an acknowledge for the interrupt.
namespace gicc_aiar
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicc_aiar) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicc_aiar, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicc_aiar, 0xffffff, 0) }
		inline uint32_t get(uint32_t gicc_aiar_val) noexcept { GET_BITFIELD_FUNC(gicc_aiar_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicc_aiar, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t gicc_aiar, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicc_aiar, value, 0xffffff, 0) }
	}
}

// GICC_APR<n> (CPU Interface Active Priorities Registers)
// Provides information about interrupt active priorities.
namespace gicc_apr<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicc_apr<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicc_apr<n>, val) }
}

// GICC_BPR (CPU Interface Binary Point Register)
// Defines the point at which the priority value fields split into two parts, the group priority field and the subpriority field.
namespace gicc_bpr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicc_bpr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicc_bpr, val) }

	namespace binary_point
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicc_bpr, 0x7, 0) }
		inline uint32_t get(uint32_t gicc_bpr_val) noexcept { GET_BITFIELD_FUNC(gicc_bpr_val, 0x7, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicc_bpr, value, 0x7, 0) }
		inline uint32_t set(uint32_t gicc_bpr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicc_bpr, value, 0x7, 0) }
	}
}

// GICC_CTLR (CPU Interface Control Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicc_ctlr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicc_ctlr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicc_ctlr, val) }

	// Fieldset valid when: GICD_CTLR.DS==0, Non-secure access
	namespace fieldset_1
	{
		namespace eoimodens
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_ctlr, 9) }
			inline uint32_t is_enabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_ctlr_val, 9) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_ctlr, 9) }
			inline uint32_t is_disabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_ctlr_val, 9) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x200) }
			inline uint32_t enable(uint32_t gicc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x200) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x200) }
			inline uint32_t disable(uint32_t gicc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x200) }
		}

		namespace irqbypdisgrp1
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_ctlr, 6) }
			inline uint32_t is_enabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_ctlr_val, 6) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_ctlr, 6) }
			inline uint32_t is_disabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_ctlr_val, 6) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x40) }
			inline uint32_t enable(uint32_t gicc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x40) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x40) }
			inline uint32_t disable(uint32_t gicc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x40) }
		}

		namespace fiqbypdisgrp1
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_ctlr, 5) }
			inline uint32_t is_enabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_ctlr_val, 5) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_ctlr, 5) }
			inline uint32_t is_disabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_ctlr_val, 5) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x20) }
			inline uint32_t enable(uint32_t gicc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x20) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x20) }
			inline uint32_t disable(uint32_t gicc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x20) }
		}

		namespace enablegrp1
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_ctlr, 0) }
			inline uint32_t is_enabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_ctlr_val, 0) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_ctlr, 0) }
			inline uint32_t is_disabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_ctlr_val, 0) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x1) }
			inline uint32_t enable(uint32_t gicc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x1) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x1) }
			inline uint32_t disable(uint32_t gicc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x1) }
		}
	}

	// Fieldset valid when: GICD_CTLR.DS==0, Secure access
	namespace fieldset_2
	{
		namespace eoimodens
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_ctlr, 10) }
			inline uint32_t is_enabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_ctlr_val, 10) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_ctlr, 10) }
			inline uint32_t is_disabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_ctlr_val, 10) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x400) }
			inline uint32_t enable(uint32_t gicc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x400) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x400) }
			inline uint32_t disable(uint32_t gicc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x400) }
		}

		namespace eoimodes
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_ctlr, 9) }
			inline uint32_t is_enabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_ctlr_val, 9) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_ctlr, 9) }
			inline uint32_t is_disabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_ctlr_val, 9) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x200) }
			inline uint32_t enable(uint32_t gicc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x200) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x200) }
			inline uint32_t disable(uint32_t gicc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x200) }
		}

		namespace irqbypdisgrp1
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_ctlr, 8) }
			inline uint32_t is_enabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_ctlr_val, 8) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_ctlr, 8) }
			inline uint32_t is_disabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_ctlr_val, 8) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x100) }
			inline uint32_t enable(uint32_t gicc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x100) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x100) }
			inline uint32_t disable(uint32_t gicc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x100) }
		}

		namespace fiqbypdisgrp1
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_ctlr, 7) }
			inline uint32_t is_enabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_ctlr_val, 7) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_ctlr, 7) }
			inline uint32_t is_disabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_ctlr_val, 7) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x80) }
			inline uint32_t enable(uint32_t gicc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x80) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x80) }
			inline uint32_t disable(uint32_t gicc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x80) }
		}

		namespace irqbypdisgrp0
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_ctlr, 6) }
			inline uint32_t is_enabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_ctlr_val, 6) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_ctlr, 6) }
			inline uint32_t is_disabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_ctlr_val, 6) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x40) }
			inline uint32_t enable(uint32_t gicc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x40) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x40) }
			inline uint32_t disable(uint32_t gicc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x40) }
		}

		namespace fiqbypdisgrp0
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_ctlr, 5) }
			inline uint32_t is_enabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_ctlr_val, 5) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_ctlr, 5) }
			inline uint32_t is_disabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_ctlr_val, 5) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x20) }
			inline uint32_t enable(uint32_t gicc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x20) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x20) }
			inline uint32_t disable(uint32_t gicc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x20) }
		}

		namespace cbpr
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_ctlr, 4) }
			inline uint32_t is_enabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_ctlr_val, 4) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_ctlr, 4) }
			inline uint32_t is_disabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_ctlr_val, 4) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x10) }
			inline uint32_t enable(uint32_t gicc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x10) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x10) }
			inline uint32_t disable(uint32_t gicc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x10) }
		}

		namespace fiqen
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_ctlr, 3) }
			inline uint32_t is_enabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_ctlr_val, 3) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_ctlr, 3) }
			inline uint32_t is_disabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_ctlr_val, 3) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x8) }
			inline uint32_t enable(uint32_t gicc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x8) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x8) }
			inline uint32_t disable(uint32_t gicc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x8) }
		}

		namespace enablegrp1
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_ctlr, 1) }
			inline uint32_t is_enabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_ctlr_val, 1) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_ctlr, 1) }
			inline uint32_t is_disabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_ctlr_val, 1) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x2) }
			inline uint32_t enable(uint32_t gicc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x2) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x2) }
			inline uint32_t disable(uint32_t gicc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x2) }
		}

		namespace enablegrp0
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_ctlr, 0) }
			inline uint32_t is_enabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_ctlr_val, 0) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_ctlr, 0) }
			inline uint32_t is_disabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_ctlr_val, 0) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x1) }
			inline uint32_t enable(uint32_t gicc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x1) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x1) }
			inline uint32_t disable(uint32_t gicc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x1) }
		}
	}

	// Fieldset valid when: GICD_CTLR.DS==1
	namespace fieldset_3
	{
		namespace eoimode
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_ctlr, 9) }
			inline uint32_t is_enabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_ctlr_val, 9) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_ctlr, 9) }
			inline uint32_t is_disabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_ctlr_val, 9) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x200) }
			inline uint32_t enable(uint32_t gicc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x200) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x200) }
			inline uint32_t disable(uint32_t gicc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x200) }
		}

		namespace irqbypdisgrp1
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_ctlr, 8) }
			inline uint32_t is_enabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_ctlr_val, 8) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_ctlr, 8) }
			inline uint32_t is_disabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_ctlr_val, 8) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x100) }
			inline uint32_t enable(uint32_t gicc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x100) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x100) }
			inline uint32_t disable(uint32_t gicc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x100) }
		}

		namespace fiqbypdisgrp1
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_ctlr, 7) }
			inline uint32_t is_enabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_ctlr_val, 7) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_ctlr, 7) }
			inline uint32_t is_disabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_ctlr_val, 7) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x80) }
			inline uint32_t enable(uint32_t gicc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x80) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x80) }
			inline uint32_t disable(uint32_t gicc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x80) }
		}

		namespace irqbypdisgrp0
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_ctlr, 6) }
			inline uint32_t is_enabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_ctlr_val, 6) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_ctlr, 6) }
			inline uint32_t is_disabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_ctlr_val, 6) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x40) }
			inline uint32_t enable(uint32_t gicc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x40) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x40) }
			inline uint32_t disable(uint32_t gicc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x40) }
		}

		namespace fiqbypdisgrp0
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_ctlr, 5) }
			inline uint32_t is_enabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_ctlr_val, 5) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_ctlr, 5) }
			inline uint32_t is_disabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_ctlr_val, 5) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x20) }
			inline uint32_t enable(uint32_t gicc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x20) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x20) }
			inline uint32_t disable(uint32_t gicc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x20) }
		}

		namespace cbpr
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_ctlr, 4) }
			inline uint32_t is_enabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_ctlr_val, 4) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_ctlr, 4) }
			inline uint32_t is_disabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_ctlr_val, 4) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x10) }
			inline uint32_t enable(uint32_t gicc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x10) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x10) }
			inline uint32_t disable(uint32_t gicc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x10) }
		}

		namespace fiqen
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_ctlr, 3) }
			inline uint32_t is_enabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_ctlr_val, 3) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_ctlr, 3) }
			inline uint32_t is_disabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_ctlr_val, 3) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x8) }
			inline uint32_t enable(uint32_t gicc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x8) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x8) }
			inline uint32_t disable(uint32_t gicc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x8) }
		}

		namespace enablegrp1
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_ctlr, 1) }
			inline uint32_t is_enabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_ctlr_val, 1) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_ctlr, 1) }
			inline uint32_t is_disabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_ctlr_val, 1) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x2) }
			inline uint32_t enable(uint32_t gicc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x2) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x2) }
			inline uint32_t disable(uint32_t gicc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x2) }
		}

		namespace enablegrp0
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_ctlr, 0) }
			inline uint32_t is_enabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_ctlr_val, 0) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_ctlr, 0) }
			inline uint32_t is_disabled(uint32_t gicc_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_ctlr_val, 0) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x1) }
			inline uint32_t enable(uint32_t gicc_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x1) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_ctlr, 0x1) }
			inline uint32_t disable(uint32_t gicc_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_ctlr_val, 0x1) }
		}
	}
}

// GICC_DIR (CPU Interface Deactivate Interrupt Register)
// When interrupt priority drop is separated from interrupt deactivation, a write to this register deactivates the specified interrupt.
namespace gicc_dir
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicc_dir) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicc_dir, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicc_dir, 0xffffff, 0) }
		inline uint32_t get(uint32_t gicc_dir_val) noexcept { GET_BITFIELD_FUNC(gicc_dir_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicc_dir, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t gicc_dir, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicc_dir, value, 0xffffff, 0) }
	}
}

// GICC_EOIR (CPU Interface End Of Interrupt Register)
// A write to this register performs priority drop for the specified interrupt and, if the appropriate GICC_CTLR.EOImodeS or GICC_CTLR.EOImodeNS field == 0, also deactivates the interrupt.
namespace gicc_eoir
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicc_eoir) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicc_eoir, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicc_eoir, 0xffffff, 0) }
		inline uint32_t get(uint32_t gicc_eoir_val) noexcept { GET_BITFIELD_FUNC(gicc_eoir_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicc_eoir, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t gicc_eoir, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicc_eoir, value, 0xffffff, 0) }
	}
}

// GICC_HPPIR (CPU Interface Highest Priority Pending Interrupt Register)
// Provides the INTID of the highest priority pending interrupt on the CPU interface.
namespace gicc_hppir
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicc_hppir) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicc_hppir, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicc_hppir, 0xffffff, 0) }
		inline uint32_t get(uint32_t gicc_hppir_val) noexcept { GET_BITFIELD_FUNC(gicc_hppir_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicc_hppir, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t gicc_hppir, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicc_hppir, value, 0xffffff, 0) }
	}
}

// GICC_IAR (CPU Interface Interrupt Acknowledge Register)
// Provides the INTID of the signaled interrupt. A read of this register by the PE acts as an acknowledge for the interrupt.
namespace gicc_iar
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicc_iar) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicc_iar, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicc_iar, 0xffffff, 0) }
		inline uint32_t get(uint32_t gicc_iar_val) noexcept { GET_BITFIELD_FUNC(gicc_iar_val, 0xffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicc_iar, value, 0xffffff, 0) }
		inline uint32_t set(uint32_t gicc_iar, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicc_iar, value, 0xffffff, 0) }
	}
}

// GICC_IIDR (CPU Interface Identification Register)
// Provides information about the implementer and revision of the CPU interface.
namespace gicc_iidr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicc_iidr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicc_iidr, val) }

	namespace productid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicc_iidr, 0xfff00000, 20) }
		inline uint32_t get(uint32_t gicc_iidr_val) noexcept { GET_BITFIELD_FUNC(gicc_iidr_val, 0xfff00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicc_iidr, value, 0xfff00000, 20) }
		inline uint32_t set(uint32_t gicc_iidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicc_iidr, value, 0xfff00000, 20) }
	}

	namespace architecture_version
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicc_iidr, 0xf0000, 16) }
		inline uint32_t get(uint32_t gicc_iidr_val) noexcept { GET_BITFIELD_FUNC(gicc_iidr_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicc_iidr, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t gicc_iidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicc_iidr, value, 0xf0000, 16) }
	}

	namespace revision
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicc_iidr, 0xf000, 12) }
		inline uint32_t get(uint32_t gicc_iidr_val) noexcept { GET_BITFIELD_FUNC(gicc_iidr_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicc_iidr, value, 0xf000, 12) }
		inline uint32_t set(uint32_t gicc_iidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicc_iidr, value, 0xf000, 12) }
	}

	namespace implementer
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicc_iidr, 0xfff, 0) }
		inline uint32_t get(uint32_t gicc_iidr_val) noexcept { GET_BITFIELD_FUNC(gicc_iidr_val, 0xfff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicc_iidr, value, 0xfff, 0) }
		inline uint32_t set(uint32_t gicc_iidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicc_iidr, value, 0xfff, 0) }
	}
}

// GICC_NSAPR<n> (CPU Interface Non-secure Active Priorities Registers)
// Provides information about Group 1 interrupt active priorities.
namespace gicc_nsapr<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicc_nsapr<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicc_nsapr<n>, val) }
}

// GICC_PMR (CPU Interface Priority Mask Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicc_pmr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicc_pmr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicc_pmr, val) }

	namespace priority
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicc_pmr, 0xff, 0) }
		inline uint32_t get(uint32_t gicc_pmr_val) noexcept { GET_BITFIELD_FUNC(gicc_pmr_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicc_pmr, value, 0xff, 0) }
		inline uint32_t set(uint32_t gicc_pmr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicc_pmr, value, 0xff, 0) }
	}
}

// GICC_RPR (CPU Interface Running Priority Register)
// This register indicates the running priority of the CPU interface.
namespace gicc_rpr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicc_rpr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicc_rpr, val) }

	namespace priority
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicc_rpr, 0xff, 0) }
		inline uint32_t get(uint32_t gicc_rpr_val) noexcept { GET_BITFIELD_FUNC(gicc_rpr_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicc_rpr, value, 0xff, 0) }
		inline uint32_t set(uint32_t gicc_rpr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicc_rpr, value, 0xff, 0) }
	}
}

// GICC_STATUSR (CPU Interface Status Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicc_statusr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicc_statusr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicc_statusr, val) }

	namespace asv
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_statusr, 4) }
		inline uint32_t is_enabled(uint32_t gicc_statusr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_statusr_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_statusr, 4) }
		inline uint32_t is_disabled(uint32_t gicc_statusr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_statusr_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_statusr, 0x10) }
		inline uint32_t enable(uint32_t gicc_statusr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_statusr_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_statusr, 0x10) }
		inline uint32_t disable(uint32_t gicc_statusr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_statusr_val, 0x10) }
	}

	namespace wrod
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_statusr, 3) }
		inline uint32_t is_enabled(uint32_t gicc_statusr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_statusr_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_statusr, 3) }
		inline uint32_t is_disabled(uint32_t gicc_statusr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_statusr_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_statusr, 0x8) }
		inline uint32_t enable(uint32_t gicc_statusr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_statusr_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_statusr, 0x8) }
		inline uint32_t disable(uint32_t gicc_statusr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_statusr_val, 0x8) }
	}

	namespace rwod
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_statusr, 2) }
		inline uint32_t is_enabled(uint32_t gicc_statusr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_statusr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_statusr, 2) }
		inline uint32_t is_disabled(uint32_t gicc_statusr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_statusr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_statusr, 0x4) }
		inline uint32_t enable(uint32_t gicc_statusr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_statusr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_statusr, 0x4) }
		inline uint32_t disable(uint32_t gicc_statusr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_statusr_val, 0x4) }
	}

	namespace wrd
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_statusr, 1) }
		inline uint32_t is_enabled(uint32_t gicc_statusr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_statusr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_statusr, 1) }
		inline uint32_t is_disabled(uint32_t gicc_statusr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_statusr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_statusr, 0x2) }
		inline uint32_t enable(uint32_t gicc_statusr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_statusr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_statusr, 0x2) }
		inline uint32_t disable(uint32_t gicc_statusr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_statusr_val, 0x2) }
	}

	namespace rrd
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicc_statusr, 0) }
		inline uint32_t is_enabled(uint32_t gicc_statusr_val) noexcept { IS_BIT_ENABLED_FUNC(gicc_statusr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicc_statusr, 0) }
		inline uint32_t is_disabled(uint32_t gicc_statusr_val) noexcept { IS_BIT_DISABLED_FUNC(gicc_statusr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicc_statusr, 0x1) }
		inline uint32_t enable(uint32_t gicc_statusr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicc_statusr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicc_statusr, 0x1) }
		inline uint32_t disable(uint32_t gicc_statusr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicc_statusr_val, 0x1) }
	}
}

// GICD_CLRSPI_NSR (Clear Non-secure SPI Pending Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicd_clrspi_nsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicd_clrspi_nsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicd_clrspi_nsr, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_clrspi_nsr, 0x3ff, 0) }
		inline uint32_t get(uint32_t gicd_clrspi_nsr_val) noexcept { GET_BITFIELD_FUNC(gicd_clrspi_nsr_val, 0x3ff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_clrspi_nsr, value, 0x3ff, 0) }
		inline uint32_t set(uint32_t gicd_clrspi_nsr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_clrspi_nsr, value, 0x3ff, 0) }
	}
}

// GICD_CLRSPI_SR (Clear Secure SPI Pending Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicd_clrspi_sr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicd_clrspi_sr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicd_clrspi_sr, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_clrspi_sr, 0x3ff, 0) }
		inline uint32_t get(uint32_t gicd_clrspi_sr_val) noexcept { GET_BITFIELD_FUNC(gicd_clrspi_sr_val, 0x3ff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_clrspi_sr, value, 0x3ff, 0) }
		inline uint32_t set(uint32_t gicd_clrspi_sr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_clrspi_sr, value, 0x3ff, 0) }
	}
}

// GICD_CPENDSGIR<n> (SGI Clear-Pending Registers)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicd_cpendsgir<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicd_cpendsgir<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicd_cpendsgir<n>, val) }

	namespace sgi_clear_pending_bits_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_cpendsgir<n>, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gicd_cpendsgir<n>_val) noexcept { GET_BITFIELD_FUNC(gicd_cpendsgir<n>_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_cpendsgir<n>, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gicd_cpendsgir<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_cpendsgir<n>, value, 0xffffffff, 0) }
	}
}

// GICD_CTLR (Distributor Control Register)
// Enables interrupts and affinity routing.
namespace gicd_ctlr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicd_ctlr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicd_ctlr, val) }

	// Fieldset valid when: access is Secure, in a system that supports two Security states
	namespace fieldset_1
	{
		namespace rwp
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_ctlr, 31) }
			inline uint32_t is_enabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_ctlr_val, 31) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_ctlr, 31) }
			inline uint32_t is_disabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_ctlr_val, 31) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x80000000) }
			inline uint32_t enable(uint32_t gicd_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x80000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x80000000) }
			inline uint32_t disable(uint32_t gicd_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x80000000) }
		}

		namespace e1nwf
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_ctlr, 7) }
			inline uint32_t is_enabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_ctlr_val, 7) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_ctlr, 7) }
			inline uint32_t is_disabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_ctlr_val, 7) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x80) }
			inline uint32_t enable(uint32_t gicd_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x80) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x80) }
			inline uint32_t disable(uint32_t gicd_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x80) }
		}

		namespace ds
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_ctlr, 6) }
			inline uint32_t is_enabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_ctlr_val, 6) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_ctlr, 6) }
			inline uint32_t is_disabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_ctlr_val, 6) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x40) }
			inline uint32_t enable(uint32_t gicd_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x40) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x40) }
			inline uint32_t disable(uint32_t gicd_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x40) }
		}

		namespace are_ns
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_ctlr, 5) }
			inline uint32_t is_enabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_ctlr_val, 5) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_ctlr, 5) }
			inline uint32_t is_disabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_ctlr_val, 5) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x20) }
			inline uint32_t enable(uint32_t gicd_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x20) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x20) }
			inline uint32_t disable(uint32_t gicd_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x20) }
		}

		namespace are_s
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_ctlr, 4) }
			inline uint32_t is_enabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_ctlr_val, 4) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_ctlr, 4) }
			inline uint32_t is_disabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_ctlr_val, 4) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x10) }
			inline uint32_t enable(uint32_t gicd_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x10) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x10) }
			inline uint32_t disable(uint32_t gicd_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x10) }
		}

		namespace enablegrp1s
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_ctlr, 2) }
			inline uint32_t is_enabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_ctlr_val, 2) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_ctlr, 2) }
			inline uint32_t is_disabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_ctlr_val, 2) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x4) }
			inline uint32_t enable(uint32_t gicd_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x4) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x4) }
			inline uint32_t disable(uint32_t gicd_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x4) }
		}

		namespace enablegrp1ns
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_ctlr, 1) }
			inline uint32_t is_enabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_ctlr_val, 1) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_ctlr, 1) }
			inline uint32_t is_disabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_ctlr_val, 1) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x2) }
			inline uint32_t enable(uint32_t gicd_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x2) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x2) }
			inline uint32_t disable(uint32_t gicd_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x2) }
		}

		namespace enablegrp0
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_ctlr, 0) }
			inline uint32_t is_enabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_ctlr_val, 0) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_ctlr, 0) }
			inline uint32_t is_disabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_ctlr_val, 0) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x1) }
			inline uint32_t enable(uint32_t gicd_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x1) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x1) }
			inline uint32_t disable(uint32_t gicd_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x1) }
		}
	}

	// Fieldset valid when: access is Non-secure, in a system that supports two Security states
	namespace fieldset_2
	{
		namespace rwp
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_ctlr, 31) }
			inline uint32_t is_enabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_ctlr_val, 31) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_ctlr, 31) }
			inline uint32_t is_disabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_ctlr_val, 31) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x80000000) }
			inline uint32_t enable(uint32_t gicd_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x80000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x80000000) }
			inline uint32_t disable(uint32_t gicd_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x80000000) }
		}

		namespace are_ns
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_ctlr, 4) }
			inline uint32_t is_enabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_ctlr_val, 4) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_ctlr, 4) }
			inline uint32_t is_disabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_ctlr_val, 4) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x10) }
			inline uint32_t enable(uint32_t gicd_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x10) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x10) }
			inline uint32_t disable(uint32_t gicd_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x10) }
		}

		namespace enablegrp1a
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_ctlr, 1) }
			inline uint32_t is_enabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_ctlr_val, 1) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_ctlr, 1) }
			inline uint32_t is_disabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_ctlr_val, 1) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x2) }
			inline uint32_t enable(uint32_t gicd_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x2) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x2) }
			inline uint32_t disable(uint32_t gicd_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x2) }
		}

		namespace enablegrp1
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_ctlr, 0) }
			inline uint32_t is_enabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_ctlr_val, 0) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_ctlr, 0) }
			inline uint32_t is_disabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_ctlr_val, 0) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x1) }
			inline uint32_t enable(uint32_t gicd_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x1) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x1) }
			inline uint32_t disable(uint32_t gicd_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x1) }
		}
	}

	// Fieldset valid when: in a system that supports only a single Security state
	namespace fieldset_3
	{
		namespace rwp
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_ctlr, 31) }
			inline uint32_t is_enabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_ctlr_val, 31) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_ctlr, 31) }
			inline uint32_t is_disabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_ctlr_val, 31) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x80000000) }
			inline uint32_t enable(uint32_t gicd_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x80000000) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x80000000) }
			inline uint32_t disable(uint32_t gicd_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x80000000) }
		}

		namespace e1nwf
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_ctlr, 7) }
			inline uint32_t is_enabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_ctlr_val, 7) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_ctlr, 7) }
			inline uint32_t is_disabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_ctlr_val, 7) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x80) }
			inline uint32_t enable(uint32_t gicd_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x80) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x80) }
			inline uint32_t disable(uint32_t gicd_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x80) }
		}

		namespace ds
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_ctlr, 6) }
			inline uint32_t is_enabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_ctlr_val, 6) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_ctlr, 6) }
			inline uint32_t is_disabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_ctlr_val, 6) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x40) }
			inline uint32_t enable(uint32_t gicd_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x40) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x40) }
			inline uint32_t disable(uint32_t gicd_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x40) }
		}

		namespace are
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_ctlr, 4) }
			inline uint32_t is_enabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_ctlr_val, 4) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_ctlr, 4) }
			inline uint32_t is_disabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_ctlr_val, 4) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x10) }
			inline uint32_t enable(uint32_t gicd_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x10) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x10) }
			inline uint32_t disable(uint32_t gicd_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x10) }
		}

		namespace enablegrp1
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_ctlr, 1) }
			inline uint32_t is_enabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_ctlr_val, 1) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_ctlr, 1) }
			inline uint32_t is_disabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_ctlr_val, 1) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x2) }
			inline uint32_t enable(uint32_t gicd_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x2) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x2) }
			inline uint32_t disable(uint32_t gicd_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x2) }
		}

		namespace enablegrp0
		{
			inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_ctlr, 0) }
			inline uint32_t is_enabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_ctlr_val, 0) }
			inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_ctlr, 0) }
			inline uint32_t is_disabled(uint32_t gicd_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_ctlr_val, 0) }
			inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x1) }
			inline uint32_t enable(uint32_t gicd_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x1) }
			inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_ctlr, 0x1) }
			inline uint32_t disable(uint32_t gicd_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_ctlr_val, 0x1) }
		}
	}
}

// GICD_ICACTIVER<n> (Interrupt Clear-Active Registers)
// Deactivates the corresponding interrupt. These registers are used when saving and restoring GIC state.
namespace gicd_icactiver<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicd_icactiver<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicd_icactiver<n>, val) }

	namespace clear_active_bit_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_icactiver<n>, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gicd_icactiver<n>_val) noexcept { GET_BITFIELD_FUNC(gicd_icactiver<n>_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_icactiver<n>, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gicd_icactiver<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_icactiver<n>, value, 0xffffffff, 0) }
	}
}

// GICD_ICENABLER<n> (Interrupt Clear-Enable Registers)
// Disables forwarding of the corresponding interrupt to the CPU interfaces.
namespace gicd_icenabler<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicd_icenabler<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicd_icenabler<n>, val) }

	namespace clear_enable_bit_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_icenabler<n>, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gicd_icenabler<n>_val) noexcept { GET_BITFIELD_FUNC(gicd_icenabler<n>_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_icenabler<n>, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gicd_icenabler<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_icenabler<n>, value, 0xffffffff, 0) }
	}
}

// GICD_ICFGR<n> (Interrupt Configuration Registers)
// Determines whether the corresponding interrupt is edge-triggered or level-sensitive.
namespace gicd_icfgr<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicd_icfgr<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicd_icfgr<n>, val) }

	namespace int_config_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_icfgr<n>, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gicd_icfgr<n>_val) noexcept { GET_BITFIELD_FUNC(gicd_icfgr<n>_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_icfgr<n>, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gicd_icfgr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_icfgr<n>, value, 0xffffffff, 0) }
	}
}

// GICD_ICPENDR<n> (Interrupt Clear-Pending Registers)
// Removes the pending state from the corresponding interrupt.
namespace gicd_icpendr<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicd_icpendr<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicd_icpendr<n>, val) }

	namespace clear_pending_bit_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_icpendr<n>, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gicd_icpendr<n>_val) noexcept { GET_BITFIELD_FUNC(gicd_icpendr<n>_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_icpendr<n>, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gicd_icpendr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_icpendr<n>, value, 0xffffffff, 0) }
	}
}

// GICD_IGROUPR<n> (Interrupt Group Registers)
// Controls whether the corresponding interrupt is in Group 0 or Group 1.
namespace gicd_igroupr<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicd_igroupr<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicd_igroupr<n>, val) }

	namespace group_status_bit_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_igroupr<n>, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gicd_igroupr<n>_val) noexcept { GET_BITFIELD_FUNC(gicd_igroupr<n>_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_igroupr<n>, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gicd_igroupr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_igroupr<n>, value, 0xffffffff, 0) }
	}
}

// GICD_IGRPMODR<n> (Interrupt Group Modifier Registers)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicd_igrpmodr<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicd_igrpmodr<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicd_igrpmodr<n>, val) }

	namespace group_modifier_bit_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_igrpmodr<n>, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gicd_igrpmodr<n>_val) noexcept { GET_BITFIELD_FUNC(gicd_igrpmodr<n>_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_igrpmodr<n>, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gicd_igrpmodr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_igrpmodr<n>, value, 0xffffffff, 0) }
	}
}

// GICD_IIDR (Distributor Implementer Identification Register)
// Provides information about the implementer and revision of the Distributor.
namespace gicd_iidr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicd_iidr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicd_iidr, val) }

	namespace productid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_iidr, 0xff000000, 24) }
		inline uint32_t get(uint32_t gicd_iidr_val) noexcept { GET_BITFIELD_FUNC(gicd_iidr_val, 0xff000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_iidr, value, 0xff000000, 24) }
		inline uint32_t set(uint32_t gicd_iidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_iidr, value, 0xff000000, 24) }
	}

	namespace variant
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_iidr, 0xf0000, 16) }
		inline uint32_t get(uint32_t gicd_iidr_val) noexcept { GET_BITFIELD_FUNC(gicd_iidr_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_iidr, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t gicd_iidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_iidr, value, 0xf0000, 16) }
	}

	namespace revision
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_iidr, 0xf000, 12) }
		inline uint32_t get(uint32_t gicd_iidr_val) noexcept { GET_BITFIELD_FUNC(gicd_iidr_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_iidr, value, 0xf000, 12) }
		inline uint32_t set(uint32_t gicd_iidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_iidr, value, 0xf000, 12) }
	}

	namespace implementer
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_iidr, 0xfff, 0) }
		inline uint32_t get(uint32_t gicd_iidr_val) noexcept { GET_BITFIELD_FUNC(gicd_iidr_val, 0xfff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_iidr, value, 0xfff, 0) }
		inline uint32_t set(uint32_t gicd_iidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_iidr, value, 0xfff, 0) }
	}
}

// GICD_IPRIORITYR<n> (Interrupt Priority Registers)
// Holds the priority of the corresponding interrupt.
namespace gicd_ipriorityr<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicd_ipriorityr<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicd_ipriorityr<n>, val) }

	namespace priority_offset_3b
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_ipriorityr<n>, 0xff000000, 24) }
		inline uint32_t get(uint32_t gicd_ipriorityr<n>_val) noexcept { GET_BITFIELD_FUNC(gicd_ipriorityr<n>_val, 0xff000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_ipriorityr<n>, value, 0xff000000, 24) }
		inline uint32_t set(uint32_t gicd_ipriorityr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_ipriorityr<n>, value, 0xff000000, 24) }
	}

	namespace priority_offset_2b
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_ipriorityr<n>, 0xff0000, 16) }
		inline uint32_t get(uint32_t gicd_ipriorityr<n>_val) noexcept { GET_BITFIELD_FUNC(gicd_ipriorityr<n>_val, 0xff0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_ipriorityr<n>, value, 0xff0000, 16) }
		inline uint32_t set(uint32_t gicd_ipriorityr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_ipriorityr<n>, value, 0xff0000, 16) }
	}

	namespace priority_offset_1b
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_ipriorityr<n>, 0xff00, 8) }
		inline uint32_t get(uint32_t gicd_ipriorityr<n>_val) noexcept { GET_BITFIELD_FUNC(gicd_ipriorityr<n>_val, 0xff00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_ipriorityr<n>, value, 0xff00, 8) }
		inline uint32_t set(uint32_t gicd_ipriorityr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_ipriorityr<n>, value, 0xff00, 8) }
	}

	namespace priority_offset_0b
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_ipriorityr<n>, 0xff, 0) }
		inline uint32_t get(uint32_t gicd_ipriorityr<n>_val) noexcept { GET_BITFIELD_FUNC(gicd_ipriorityr<n>_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_ipriorityr<n>, value, 0xff, 0) }
		inline uint32_t set(uint32_t gicd_ipriorityr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_ipriorityr<n>, value, 0xff, 0) }
	}
}

// GICD_IROUTER<n> (Interrupt Routing Registers)
// When affinity routing is enabled, provides routing information for the SPI with INTID n.
namespace gicd_irouter<n>
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(gicd_irouter<n>) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicd_irouter<n>, val) }

	namespace aff3
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_irouter<n>, 0xff00000000, 32) }
		inline uint64_t get(uint64_t gicd_irouter<n>_val) noexcept { GET_BITFIELD_FUNC(gicd_irouter<n>_val, 0xff00000000, 32) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_irouter<n>, value, 0xff00000000, 32) }
		inline uint64_t set(uint64_t gicd_irouter<n>, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_irouter<n>, value, 0xff00000000, 32) }
	}

	namespace interrupt_routing_mode
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_irouter<n>, 31) }
		inline uint64_t is_enabled(uint64_t gicd_irouter<n>_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_irouter<n>_val, 31) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_irouter<n>, 31) }
		inline uint64_t is_disabled(uint64_t gicd_irouter<n>_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_irouter<n>_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_irouter<n>, 0x80000000) }
		inline uint64_t enable(uint64_t gicd_irouter<n>_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_irouter<n>_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_irouter<n>, 0x80000000) }
		inline uint64_t disable(uint64_t gicd_irouter<n>_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_irouter<n>_val, 0x80000000) }
	}

	namespace aff2
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_irouter<n>, 0xff0000, 16) }
		inline uint64_t get(uint64_t gicd_irouter<n>_val) noexcept { GET_BITFIELD_FUNC(gicd_irouter<n>_val, 0xff0000, 16) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_irouter<n>, value, 0xff0000, 16) }
		inline uint64_t set(uint64_t gicd_irouter<n>, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_irouter<n>, value, 0xff0000, 16) }
	}

	namespace aff1
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_irouter<n>, 0xff00, 8) }
		inline uint64_t get(uint64_t gicd_irouter<n>_val) noexcept { GET_BITFIELD_FUNC(gicd_irouter<n>_val, 0xff00, 8) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_irouter<n>, value, 0xff00, 8) }
		inline uint64_t set(uint64_t gicd_irouter<n>, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_irouter<n>, value, 0xff00, 8) }
	}

	namespace aff0
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_irouter<n>, 0xff, 0) }
		inline uint64_t get(uint64_t gicd_irouter<n>_val) noexcept { GET_BITFIELD_FUNC(gicd_irouter<n>_val, 0xff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_irouter<n>, value, 0xff, 0) }
		inline uint64_t set(uint64_t gicd_irouter<n>, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_irouter<n>, value, 0xff, 0) }
	}
}

// GICD_ISACTIVER<n> (Interrupt Set-Active Registers)
// Activates the corresponding interrupt. These registers are used when saving and restoring GIC state.
namespace gicd_isactiver<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicd_isactiver<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicd_isactiver<n>, val) }

	namespace set_active_bit_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_isactiver<n>, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gicd_isactiver<n>_val) noexcept { GET_BITFIELD_FUNC(gicd_isactiver<n>_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_isactiver<n>, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gicd_isactiver<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_isactiver<n>, value, 0xffffffff, 0) }
	}
}

// GICD_ISENABLER<n> (Interrupt Set-Enable Registers)
// Enables forwarding of the corresponding interrupt to the CPU interfaces.
namespace gicd_isenabler<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicd_isenabler<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicd_isenabler<n>, val) }

	namespace set_enable_bit_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_isenabler<n>, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gicd_isenabler<n>_val) noexcept { GET_BITFIELD_FUNC(gicd_isenabler<n>_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_isenabler<n>, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gicd_isenabler<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_isenabler<n>, value, 0xffffffff, 0) }
	}
}

// GICD_ISPENDR<n> (Interrupt Set-Pending Registers)
// Adds the pending state to the corresponding interrupt.
namespace gicd_ispendr<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicd_ispendr<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicd_ispendr<n>, val) }

	namespace set_pending_bit_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_ispendr<n>, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gicd_ispendr<n>_val) noexcept { GET_BITFIELD_FUNC(gicd_ispendr<n>_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_ispendr<n>, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gicd_ispendr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_ispendr<n>, value, 0xffffffff, 0) }
	}
}

// GICD_ITARGETSR<n> (Interrupt Processor Targets Registers)
// When affinity routing is not enabled, holds the list of target PEs for the interrupt. That is, it holds the list of CPU interfaces to which the Distributor forwards the interrupt if it is asserted and has sufficient priority.
namespace gicd_itargetsr<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicd_itargetsr<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicd_itargetsr<n>, val) }

	namespace cpu_targets_offset_3b
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_itargetsr<n>, 0xff000000, 24) }
		inline uint32_t get(uint32_t gicd_itargetsr<n>_val) noexcept { GET_BITFIELD_FUNC(gicd_itargetsr<n>_val, 0xff000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_itargetsr<n>, value, 0xff000000, 24) }
		inline uint32_t set(uint32_t gicd_itargetsr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_itargetsr<n>, value, 0xff000000, 24) }
	}

	namespace cpu_targets_offset_2b
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_itargetsr<n>, 0xff0000, 16) }
		inline uint32_t get(uint32_t gicd_itargetsr<n>_val) noexcept { GET_BITFIELD_FUNC(gicd_itargetsr<n>_val, 0xff0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_itargetsr<n>, value, 0xff0000, 16) }
		inline uint32_t set(uint32_t gicd_itargetsr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_itargetsr<n>, value, 0xff0000, 16) }
	}

	namespace cpu_targets_offset_1b
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_itargetsr<n>, 0xff00, 8) }
		inline uint32_t get(uint32_t gicd_itargetsr<n>_val) noexcept { GET_BITFIELD_FUNC(gicd_itargetsr<n>_val, 0xff00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_itargetsr<n>, value, 0xff00, 8) }
		inline uint32_t set(uint32_t gicd_itargetsr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_itargetsr<n>, value, 0xff00, 8) }
	}

	namespace cpu_targets_offset_0b
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_itargetsr<n>, 0xff, 0) }
		inline uint32_t get(uint32_t gicd_itargetsr<n>_val) noexcept { GET_BITFIELD_FUNC(gicd_itargetsr<n>_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_itargetsr<n>, value, 0xff, 0) }
		inline uint32_t set(uint32_t gicd_itargetsr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_itargetsr<n>, value, 0xff, 0) }
	}
}

// GICD_NSACR<n> (Non-secure Access Control Registers)
// Enables Secure software to permit Non-secure software on a particular PE to create and control Group 0 interrupts.
namespace gicd_nsacr<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicd_nsacr<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicd_nsacr<n>, val) }

	namespace ns_access_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_nsacr<n>, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gicd_nsacr<n>_val) noexcept { GET_BITFIELD_FUNC(gicd_nsacr<n>_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_nsacr<n>, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gicd_nsacr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_nsacr<n>, value, 0xffffffff, 0) }
	}
}

// GICD_SETSPI_NSR (Set Non-secure SPI Pending Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicd_setspi_nsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicd_setspi_nsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicd_setspi_nsr, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_setspi_nsr, 0x3ff, 0) }
		inline uint32_t get(uint32_t gicd_setspi_nsr_val) noexcept { GET_BITFIELD_FUNC(gicd_setspi_nsr_val, 0x3ff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_setspi_nsr, value, 0x3ff, 0) }
		inline uint32_t set(uint32_t gicd_setspi_nsr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_setspi_nsr, value, 0x3ff, 0) }
	}
}

// GICD_SETSPI_SR (Set Secure SPI Pending Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicd_setspi_sr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicd_setspi_sr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicd_setspi_sr, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_setspi_sr, 0x3ff, 0) }
		inline uint32_t get(uint32_t gicd_setspi_sr_val) noexcept { GET_BITFIELD_FUNC(gicd_setspi_sr_val, 0x3ff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_setspi_sr, value, 0x3ff, 0) }
		inline uint32_t set(uint32_t gicd_setspi_sr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_setspi_sr, value, 0x3ff, 0) }
	}
}

// GICD_SGIR (Software Generated Interrupt Register)
// Controls the generation of SGIs.
namespace gicd_sgir
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicd_sgir) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicd_sgir, val) }

	namespace targetlistfilter
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_sgir, 0x3000000, 24) }
		inline uint32_t get(uint32_t gicd_sgir_val) noexcept { GET_BITFIELD_FUNC(gicd_sgir_val, 0x3000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_sgir, value, 0x3000000, 24) }
		inline uint32_t set(uint32_t gicd_sgir, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_sgir, value, 0x3000000, 24) }
	}

	namespace cputargetlist
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_sgir, 0xff0000, 16) }
		inline uint32_t get(uint32_t gicd_sgir_val) noexcept { GET_BITFIELD_FUNC(gicd_sgir_val, 0xff0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_sgir, value, 0xff0000, 16) }
		inline uint32_t set(uint32_t gicd_sgir, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_sgir, value, 0xff0000, 16) }
	}

	namespace nsatt
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_sgir, 15) }
		inline uint32_t is_enabled(uint32_t gicd_sgir_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_sgir_val, 15) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_sgir, 15) }
		inline uint32_t is_disabled(uint32_t gicd_sgir_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_sgir_val, 15) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_sgir, 0x8000) }
		inline uint32_t enable(uint32_t gicd_sgir_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_sgir_val, 0x8000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_sgir, 0x8000) }
		inline uint32_t disable(uint32_t gicd_sgir_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_sgir_val, 0x8000) }
	}

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_sgir, 0xf, 0) }
		inline uint32_t get(uint32_t gicd_sgir_val) noexcept { GET_BITFIELD_FUNC(gicd_sgir_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_sgir, value, 0xf, 0) }
		inline uint32_t set(uint32_t gicd_sgir, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_sgir, value, 0xf, 0) }
	}
}

// GICD_SPENDSGIR<n> (SGI Set-Pending Registers)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicd_spendsgir<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicd_spendsgir<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicd_spendsgir<n>, val) }

	namespace sgi_set_pending_bits_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_spendsgir<n>, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gicd_spendsgir<n>_val) noexcept { GET_BITFIELD_FUNC(gicd_spendsgir<n>_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_spendsgir<n>, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gicd_spendsgir<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_spendsgir<n>, value, 0xffffffff, 0) }
	}
}

// GICD_STATUSR (Error Reporting Status Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicd_statusr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicd_statusr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicd_statusr, val) }

	namespace wrod
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_statusr, 3) }
		inline uint32_t is_enabled(uint32_t gicd_statusr_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_statusr_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_statusr, 3) }
		inline uint32_t is_disabled(uint32_t gicd_statusr_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_statusr_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_statusr, 0x8) }
		inline uint32_t enable(uint32_t gicd_statusr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_statusr_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_statusr, 0x8) }
		inline uint32_t disable(uint32_t gicd_statusr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_statusr_val, 0x8) }
	}

	namespace rwod
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_statusr, 2) }
		inline uint32_t is_enabled(uint32_t gicd_statusr_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_statusr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_statusr, 2) }
		inline uint32_t is_disabled(uint32_t gicd_statusr_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_statusr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_statusr, 0x4) }
		inline uint32_t enable(uint32_t gicd_statusr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_statusr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_statusr, 0x4) }
		inline uint32_t disable(uint32_t gicd_statusr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_statusr_val, 0x4) }
	}

	namespace wrd
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_statusr, 1) }
		inline uint32_t is_enabled(uint32_t gicd_statusr_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_statusr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_statusr, 1) }
		inline uint32_t is_disabled(uint32_t gicd_statusr_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_statusr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_statusr, 0x2) }
		inline uint32_t enable(uint32_t gicd_statusr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_statusr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_statusr, 0x2) }
		inline uint32_t disable(uint32_t gicd_statusr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_statusr_val, 0x2) }
	}

	namespace rrd
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_statusr, 0) }
		inline uint32_t is_enabled(uint32_t gicd_statusr_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_statusr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_statusr, 0) }
		inline uint32_t is_disabled(uint32_t gicd_statusr_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_statusr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_statusr, 0x1) }
		inline uint32_t enable(uint32_t gicd_statusr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_statusr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_statusr, 0x1) }
		inline uint32_t disable(uint32_t gicd_statusr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_statusr_val, 0x1) }
	}
}

// GICD_TYPER (Interrupt Controller Type Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicd_typer
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicd_typer) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicd_typer, val) }

	namespace rss
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_typer, 26) }
		inline uint32_t is_enabled(uint32_t gicd_typer_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_typer_val, 26) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_typer, 26) }
		inline uint32_t is_disabled(uint32_t gicd_typer_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_typer_val, 26) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_typer, 0x4000000) }
		inline uint32_t enable(uint32_t gicd_typer_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_typer_val, 0x4000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_typer, 0x4000000) }
		inline uint32_t disable(uint32_t gicd_typer_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_typer_val, 0x4000000) }
	}

	namespace no1n
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_typer, 25) }
		inline uint32_t is_enabled(uint32_t gicd_typer_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_typer_val, 25) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_typer, 25) }
		inline uint32_t is_disabled(uint32_t gicd_typer_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_typer_val, 25) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_typer, 0x2000000) }
		inline uint32_t enable(uint32_t gicd_typer_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_typer_val, 0x2000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_typer, 0x2000000) }
		inline uint32_t disable(uint32_t gicd_typer_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_typer_val, 0x2000000) }
	}

	namespace a3v
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_typer, 24) }
		inline uint32_t is_enabled(uint32_t gicd_typer_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_typer_val, 24) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_typer, 24) }
		inline uint32_t is_disabled(uint32_t gicd_typer_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_typer_val, 24) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_typer, 0x1000000) }
		inline uint32_t enable(uint32_t gicd_typer_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_typer_val, 0x1000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_typer, 0x1000000) }
		inline uint32_t disable(uint32_t gicd_typer_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_typer_val, 0x1000000) }
	}

	namespace idbits
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_typer, 0xf80000, 19) }
		inline uint32_t get(uint32_t gicd_typer_val) noexcept { GET_BITFIELD_FUNC(gicd_typer_val, 0xf80000, 19) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_typer, value, 0xf80000, 19) }
		inline uint32_t set(uint32_t gicd_typer, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_typer, value, 0xf80000, 19) }
	}

	namespace dvis
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_typer, 18) }
		inline uint32_t is_enabled(uint32_t gicd_typer_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_typer_val, 18) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_typer, 18) }
		inline uint32_t is_disabled(uint32_t gicd_typer_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_typer_val, 18) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_typer, 0x40000) }
		inline uint32_t enable(uint32_t gicd_typer_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_typer_val, 0x40000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_typer, 0x40000) }
		inline uint32_t disable(uint32_t gicd_typer_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_typer_val, 0x40000) }
	}

	namespace lpis
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_typer, 17) }
		inline uint32_t is_enabled(uint32_t gicd_typer_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_typer_val, 17) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_typer, 17) }
		inline uint32_t is_disabled(uint32_t gicd_typer_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_typer_val, 17) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_typer, 0x20000) }
		inline uint32_t enable(uint32_t gicd_typer_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_typer_val, 0x20000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_typer, 0x20000) }
		inline uint32_t disable(uint32_t gicd_typer_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_typer_val, 0x20000) }
	}

	namespace mbis
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_typer, 16) }
		inline uint32_t is_enabled(uint32_t gicd_typer_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_typer_val, 16) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_typer, 16) }
		inline uint32_t is_disabled(uint32_t gicd_typer_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_typer_val, 16) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_typer, 0x10000) }
		inline uint32_t enable(uint32_t gicd_typer_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_typer_val, 0x10000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_typer, 0x10000) }
		inline uint32_t disable(uint32_t gicd_typer_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_typer_val, 0x10000) }
	}

	namespace securityextn
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicd_typer, 10) }
		inline uint32_t is_enabled(uint32_t gicd_typer_val) noexcept { IS_BIT_ENABLED_FUNC(gicd_typer_val, 10) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicd_typer, 10) }
		inline uint32_t is_disabled(uint32_t gicd_typer_val) noexcept { IS_BIT_DISABLED_FUNC(gicd_typer_val, 10) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicd_typer, 0x400) }
		inline uint32_t enable(uint32_t gicd_typer_val) noexcept { SET_BITS_BY_MASK_FUNC(gicd_typer_val, 0x400) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicd_typer, 0x400) }
		inline uint32_t disable(uint32_t gicd_typer_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicd_typer_val, 0x400) }
	}

	namespace cpunumber
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_typer, 0xe0, 5) }
		inline uint32_t get(uint32_t gicd_typer_val) noexcept { GET_BITFIELD_FUNC(gicd_typer_val, 0xe0, 5) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_typer, value, 0xe0, 5) }
		inline uint32_t set(uint32_t gicd_typer, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_typer, value, 0xe0, 5) }
	}

	namespace itlinesnumber
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicd_typer, 0x1f, 0) }
		inline uint32_t get(uint32_t gicd_typer_val) noexcept { GET_BITFIELD_FUNC(gicd_typer_val, 0x1f, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicd_typer, value, 0x1f, 0) }
		inline uint32_t set(uint32_t gicd_typer, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicd_typer, value, 0x1f, 0) }
	}
}

// GICH_APR<n> (Active Priorities Registers)
// These registers track which preemption levels are active in the virtual CPU interface, and indicate the current active priority. Corresponding bits are set to 1 in this register when an interrupt is acknowledged, based on GICH_LR<n>.Priority, and the least significant bit set is cleared on EOI.
namespace gich_apr<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gich_apr<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gich_apr<n>, val) }

	namespace p_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gich_apr<n>, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gich_apr<n>_val) noexcept { GET_BITFIELD_FUNC(gich_apr<n>_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gich_apr<n>, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gich_apr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gich_apr<n>, value, 0xffffffff, 0) }
	}
}

// GICH_EISR (End Interrupt Status Register)
// Indicates which List registers have outstanding EOI maintenance interrupts.
namespace gich_eisr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gich_eisr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gich_eisr, val) }

	namespace status_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gich_eisr, 0xffff, 0) }
		inline uint32_t get(uint32_t gich_eisr_val) noexcept { GET_BITFIELD_FUNC(gich_eisr_val, 0xffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gich_eisr, value, 0xffff, 0) }
		inline uint32_t set(uint32_t gich_eisr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gich_eisr, value, 0xffff, 0) }
	}
}

// GICH_ELRSR (Empty List Register Status Register)
// Indicates which List registers contain valid interrupts.
namespace gich_elrsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gich_elrsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gich_elrsr, val) }

	namespace status_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gich_elrsr, 0xffff, 0) }
		inline uint32_t get(uint32_t gich_elrsr_val) noexcept { GET_BITFIELD_FUNC(gich_elrsr_val, 0xffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gich_elrsr, value, 0xffff, 0) }
		inline uint32_t set(uint32_t gich_elrsr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gich_elrsr, value, 0xffff, 0) }
	}
}

// GICH_HCR (Hypervisor Control Register)
// Controls the virtual CPU interface.
namespace gich_hcr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gich_hcr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gich_hcr, val) }

	namespace eoicount
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gich_hcr, 0xf8000000, 27) }
		inline uint32_t get(uint32_t gich_hcr_val) noexcept { GET_BITFIELD_FUNC(gich_hcr_val, 0xf8000000, 27) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gich_hcr, value, 0xf8000000, 27) }
		inline uint32_t set(uint32_t gich_hcr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gich_hcr, value, 0xf8000000, 27) }
	}

	namespace vgrp1die
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_hcr, 7) }
		inline uint32_t is_enabled(uint32_t gich_hcr_val) noexcept { IS_BIT_ENABLED_FUNC(gich_hcr_val, 7) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_hcr, 7) }
		inline uint32_t is_disabled(uint32_t gich_hcr_val) noexcept { IS_BIT_DISABLED_FUNC(gich_hcr_val, 7) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_hcr, 0x80) }
		inline uint32_t enable(uint32_t gich_hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_hcr_val, 0x80) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_hcr, 0x80) }
		inline uint32_t disable(uint32_t gich_hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_hcr_val, 0x80) }
	}

	namespace vgrp1eie
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_hcr, 6) }
		inline uint32_t is_enabled(uint32_t gich_hcr_val) noexcept { IS_BIT_ENABLED_FUNC(gich_hcr_val, 6) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_hcr, 6) }
		inline uint32_t is_disabled(uint32_t gich_hcr_val) noexcept { IS_BIT_DISABLED_FUNC(gich_hcr_val, 6) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_hcr, 0x40) }
		inline uint32_t enable(uint32_t gich_hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_hcr_val, 0x40) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_hcr, 0x40) }
		inline uint32_t disable(uint32_t gich_hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_hcr_val, 0x40) }
	}

	namespace vgrp0die
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_hcr, 5) }
		inline uint32_t is_enabled(uint32_t gich_hcr_val) noexcept { IS_BIT_ENABLED_FUNC(gich_hcr_val, 5) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_hcr, 5) }
		inline uint32_t is_disabled(uint32_t gich_hcr_val) noexcept { IS_BIT_DISABLED_FUNC(gich_hcr_val, 5) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_hcr, 0x20) }
		inline uint32_t enable(uint32_t gich_hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_hcr_val, 0x20) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_hcr, 0x20) }
		inline uint32_t disable(uint32_t gich_hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_hcr_val, 0x20) }
	}

	namespace vgrp0eie
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_hcr, 4) }
		inline uint32_t is_enabled(uint32_t gich_hcr_val) noexcept { IS_BIT_ENABLED_FUNC(gich_hcr_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_hcr, 4) }
		inline uint32_t is_disabled(uint32_t gich_hcr_val) noexcept { IS_BIT_DISABLED_FUNC(gich_hcr_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_hcr, 0x10) }
		inline uint32_t enable(uint32_t gich_hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_hcr_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_hcr, 0x10) }
		inline uint32_t disable(uint32_t gich_hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_hcr_val, 0x10) }
	}

	namespace npie
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_hcr, 3) }
		inline uint32_t is_enabled(uint32_t gich_hcr_val) noexcept { IS_BIT_ENABLED_FUNC(gich_hcr_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_hcr, 3) }
		inline uint32_t is_disabled(uint32_t gich_hcr_val) noexcept { IS_BIT_DISABLED_FUNC(gich_hcr_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_hcr, 0x8) }
		inline uint32_t enable(uint32_t gich_hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_hcr_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_hcr, 0x8) }
		inline uint32_t disable(uint32_t gich_hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_hcr_val, 0x8) }
	}

	namespace lrenpie
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_hcr, 2) }
		inline uint32_t is_enabled(uint32_t gich_hcr_val) noexcept { IS_BIT_ENABLED_FUNC(gich_hcr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_hcr, 2) }
		inline uint32_t is_disabled(uint32_t gich_hcr_val) noexcept { IS_BIT_DISABLED_FUNC(gich_hcr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_hcr, 0x4) }
		inline uint32_t enable(uint32_t gich_hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_hcr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_hcr, 0x4) }
		inline uint32_t disable(uint32_t gich_hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_hcr_val, 0x4) }
	}

	namespace uie
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_hcr, 1) }
		inline uint32_t is_enabled(uint32_t gich_hcr_val) noexcept { IS_BIT_ENABLED_FUNC(gich_hcr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_hcr, 1) }
		inline uint32_t is_disabled(uint32_t gich_hcr_val) noexcept { IS_BIT_DISABLED_FUNC(gich_hcr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_hcr, 0x2) }
		inline uint32_t enable(uint32_t gich_hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_hcr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_hcr, 0x2) }
		inline uint32_t disable(uint32_t gich_hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_hcr_val, 0x2) }
	}

	namespace en
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_hcr, 0) }
		inline uint32_t is_enabled(uint32_t gich_hcr_val) noexcept { IS_BIT_ENABLED_FUNC(gich_hcr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_hcr, 0) }
		inline uint32_t is_disabled(uint32_t gich_hcr_val) noexcept { IS_BIT_DISABLED_FUNC(gich_hcr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_hcr, 0x1) }
		inline uint32_t enable(uint32_t gich_hcr_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_hcr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_hcr, 0x1) }
		inline uint32_t disable(uint32_t gich_hcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_hcr_val, 0x1) }
	}
}

// GICH_LR<n> (List Registers)
// These registers provide context information for the virtual CPU interface.
namespace gich_lr<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gich_lr<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gich_lr<n>, val) }

	namespace hw
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_lr<n>, 31) }
		inline uint32_t is_enabled(uint32_t gich_lr<n>_val) noexcept { IS_BIT_ENABLED_FUNC(gich_lr<n>_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_lr<n>, 31) }
		inline uint32_t is_disabled(uint32_t gich_lr<n>_val) noexcept { IS_BIT_DISABLED_FUNC(gich_lr<n>_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_lr<n>, 0x80000000) }
		inline uint32_t enable(uint32_t gich_lr<n>_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_lr<n>_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_lr<n>, 0x80000000) }
		inline uint32_t disable(uint32_t gich_lr<n>_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_lr<n>_val, 0x80000000) }
	}

	namespace group
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_lr<n>, 30) }
		inline uint32_t is_enabled(uint32_t gich_lr<n>_val) noexcept { IS_BIT_ENABLED_FUNC(gich_lr<n>_val, 30) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_lr<n>, 30) }
		inline uint32_t is_disabled(uint32_t gich_lr<n>_val) noexcept { IS_BIT_DISABLED_FUNC(gich_lr<n>_val, 30) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_lr<n>, 0x40000000) }
		inline uint32_t enable(uint32_t gich_lr<n>_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_lr<n>_val, 0x40000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_lr<n>, 0x40000000) }
		inline uint32_t disable(uint32_t gich_lr<n>_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_lr<n>_val, 0x40000000) }
	}

	namespace state
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gich_lr<n>, 0x30000000, 28) }
		inline uint32_t get(uint32_t gich_lr<n>_val) noexcept { GET_BITFIELD_FUNC(gich_lr<n>_val, 0x30000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gich_lr<n>, value, 0x30000000, 28) }
		inline uint32_t set(uint32_t gich_lr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gich_lr<n>, value, 0x30000000, 28) }
	}

	namespace priority
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gich_lr<n>, 0xf800000, 23) }
		inline uint32_t get(uint32_t gich_lr<n>_val) noexcept { GET_BITFIELD_FUNC(gich_lr<n>_val, 0xf800000, 23) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gich_lr<n>, value, 0xf800000, 23) }
		inline uint32_t set(uint32_t gich_lr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gich_lr<n>, value, 0xf800000, 23) }
	}

	namespace pintid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gich_lr<n>, 0xffc00, 10) }
		inline uint32_t get(uint32_t gich_lr<n>_val) noexcept { GET_BITFIELD_FUNC(gich_lr<n>_val, 0xffc00, 10) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gich_lr<n>, value, 0xffc00, 10) }
		inline uint32_t set(uint32_t gich_lr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gich_lr<n>, value, 0xffc00, 10) }
	}

	namespace vintid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gich_lr<n>, 0x3ff, 0) }
		inline uint32_t get(uint32_t gich_lr<n>_val) noexcept { GET_BITFIELD_FUNC(gich_lr<n>_val, 0x3ff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gich_lr<n>, value, 0x3ff, 0) }
		inline uint32_t set(uint32_t gich_lr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gich_lr<n>, value, 0x3ff, 0) }
	}
}

// GICH_MISR (Maintenance Interrupt Status Register)
// Indicates which maintenance interrupts are asserted.
namespace gich_misr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gich_misr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gich_misr, val) }

	namespace vgrp1d
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_misr, 7) }
		inline uint32_t is_enabled(uint32_t gich_misr_val) noexcept { IS_BIT_ENABLED_FUNC(gich_misr_val, 7) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_misr, 7) }
		inline uint32_t is_disabled(uint32_t gich_misr_val) noexcept { IS_BIT_DISABLED_FUNC(gich_misr_val, 7) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_misr, 0x80) }
		inline uint32_t enable(uint32_t gich_misr_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_misr_val, 0x80) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_misr, 0x80) }
		inline uint32_t disable(uint32_t gich_misr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_misr_val, 0x80) }
	}

	namespace vgrp1e
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_misr, 6) }
		inline uint32_t is_enabled(uint32_t gich_misr_val) noexcept { IS_BIT_ENABLED_FUNC(gich_misr_val, 6) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_misr, 6) }
		inline uint32_t is_disabled(uint32_t gich_misr_val) noexcept { IS_BIT_DISABLED_FUNC(gich_misr_val, 6) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_misr, 0x40) }
		inline uint32_t enable(uint32_t gich_misr_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_misr_val, 0x40) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_misr, 0x40) }
		inline uint32_t disable(uint32_t gich_misr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_misr_val, 0x40) }
	}

	namespace vgrp0d
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_misr, 5) }
		inline uint32_t is_enabled(uint32_t gich_misr_val) noexcept { IS_BIT_ENABLED_FUNC(gich_misr_val, 5) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_misr, 5) }
		inline uint32_t is_disabled(uint32_t gich_misr_val) noexcept { IS_BIT_DISABLED_FUNC(gich_misr_val, 5) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_misr, 0x20) }
		inline uint32_t enable(uint32_t gich_misr_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_misr_val, 0x20) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_misr, 0x20) }
		inline uint32_t disable(uint32_t gich_misr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_misr_val, 0x20) }
	}

	namespace vgrp0e
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_misr, 4) }
		inline uint32_t is_enabled(uint32_t gich_misr_val) noexcept { IS_BIT_ENABLED_FUNC(gich_misr_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_misr, 4) }
		inline uint32_t is_disabled(uint32_t gich_misr_val) noexcept { IS_BIT_DISABLED_FUNC(gich_misr_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_misr, 0x10) }
		inline uint32_t enable(uint32_t gich_misr_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_misr_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_misr, 0x10) }
		inline uint32_t disable(uint32_t gich_misr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_misr_val, 0x10) }
	}

	namespace np
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_misr, 3) }
		inline uint32_t is_enabled(uint32_t gich_misr_val) noexcept { IS_BIT_ENABLED_FUNC(gich_misr_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_misr, 3) }
		inline uint32_t is_disabled(uint32_t gich_misr_val) noexcept { IS_BIT_DISABLED_FUNC(gich_misr_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_misr, 0x8) }
		inline uint32_t enable(uint32_t gich_misr_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_misr_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_misr, 0x8) }
		inline uint32_t disable(uint32_t gich_misr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_misr_val, 0x8) }
	}

	namespace lrenp
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_misr, 2) }
		inline uint32_t is_enabled(uint32_t gich_misr_val) noexcept { IS_BIT_ENABLED_FUNC(gich_misr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_misr, 2) }
		inline uint32_t is_disabled(uint32_t gich_misr_val) noexcept { IS_BIT_DISABLED_FUNC(gich_misr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_misr, 0x4) }
		inline uint32_t enable(uint32_t gich_misr_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_misr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_misr, 0x4) }
		inline uint32_t disable(uint32_t gich_misr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_misr_val, 0x4) }
	}

	namespace u
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_misr, 1) }
		inline uint32_t is_enabled(uint32_t gich_misr_val) noexcept { IS_BIT_ENABLED_FUNC(gich_misr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_misr, 1) }
		inline uint32_t is_disabled(uint32_t gich_misr_val) noexcept { IS_BIT_DISABLED_FUNC(gich_misr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_misr, 0x2) }
		inline uint32_t enable(uint32_t gich_misr_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_misr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_misr, 0x2) }
		inline uint32_t disable(uint32_t gich_misr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_misr_val, 0x2) }
	}

	namespace eoi
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_misr, 0) }
		inline uint32_t is_enabled(uint32_t gich_misr_val) noexcept { IS_BIT_ENABLED_FUNC(gich_misr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_misr, 0) }
		inline uint32_t is_disabled(uint32_t gich_misr_val) noexcept { IS_BIT_DISABLED_FUNC(gich_misr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_misr, 0x1) }
		inline uint32_t enable(uint32_t gich_misr_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_misr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_misr, 0x1) }
		inline uint32_t disable(uint32_t gich_misr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_misr_val, 0x1) }
	}
}

// GICH_VMCR (Virtual Machine Control Register)
// Enables the hypervisor to save and restore the virtual machine view of the GIC state. This register is updated when a virtual machine updates the virtual CPU interface registers.
namespace gich_vmcr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gich_vmcr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gich_vmcr, val) }

	namespace vpmr
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gich_vmcr, 0xff000000, 24) }
		inline uint32_t get(uint32_t gich_vmcr_val) noexcept { GET_BITFIELD_FUNC(gich_vmcr_val, 0xff000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gich_vmcr, value, 0xff000000, 24) }
		inline uint32_t set(uint32_t gich_vmcr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gich_vmcr, value, 0xff000000, 24) }
	}

	namespace vbpr0
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gich_vmcr, 0xe00000, 21) }
		inline uint32_t get(uint32_t gich_vmcr_val) noexcept { GET_BITFIELD_FUNC(gich_vmcr_val, 0xe00000, 21) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gich_vmcr, value, 0xe00000, 21) }
		inline uint32_t set(uint32_t gich_vmcr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gich_vmcr, value, 0xe00000, 21) }
	}

	namespace vbpr1
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gich_vmcr, 0x1c0000, 18) }
		inline uint32_t get(uint32_t gich_vmcr_val) noexcept { GET_BITFIELD_FUNC(gich_vmcr_val, 0x1c0000, 18) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gich_vmcr, value, 0x1c0000, 18) }
		inline uint32_t set(uint32_t gich_vmcr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gich_vmcr, value, 0x1c0000, 18) }
	}

	namespace veoim
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_vmcr, 9) }
		inline uint32_t is_enabled(uint32_t gich_vmcr_val) noexcept { IS_BIT_ENABLED_FUNC(gich_vmcr_val, 9) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_vmcr, 9) }
		inline uint32_t is_disabled(uint32_t gich_vmcr_val) noexcept { IS_BIT_DISABLED_FUNC(gich_vmcr_val, 9) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_vmcr, 0x200) }
		inline uint32_t enable(uint32_t gich_vmcr_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_vmcr_val, 0x200) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_vmcr, 0x200) }
		inline uint32_t disable(uint32_t gich_vmcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_vmcr_val, 0x200) }
	}

	namespace vcbpr
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_vmcr, 4) }
		inline uint32_t is_enabled(uint32_t gich_vmcr_val) noexcept { IS_BIT_ENABLED_FUNC(gich_vmcr_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_vmcr, 4) }
		inline uint32_t is_disabled(uint32_t gich_vmcr_val) noexcept { IS_BIT_DISABLED_FUNC(gich_vmcr_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_vmcr, 0x10) }
		inline uint32_t enable(uint32_t gich_vmcr_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_vmcr_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_vmcr, 0x10) }
		inline uint32_t disable(uint32_t gich_vmcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_vmcr_val, 0x10) }
	}

	namespace vfiqen
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_vmcr, 3) }
		inline uint32_t is_enabled(uint32_t gich_vmcr_val) noexcept { IS_BIT_ENABLED_FUNC(gich_vmcr_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_vmcr, 3) }
		inline uint32_t is_disabled(uint32_t gich_vmcr_val) noexcept { IS_BIT_DISABLED_FUNC(gich_vmcr_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_vmcr, 0x8) }
		inline uint32_t enable(uint32_t gich_vmcr_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_vmcr_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_vmcr, 0x8) }
		inline uint32_t disable(uint32_t gich_vmcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_vmcr_val, 0x8) }
	}

	namespace vackctl
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_vmcr, 2) }
		inline uint32_t is_enabled(uint32_t gich_vmcr_val) noexcept { IS_BIT_ENABLED_FUNC(gich_vmcr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_vmcr, 2) }
		inline uint32_t is_disabled(uint32_t gich_vmcr_val) noexcept { IS_BIT_DISABLED_FUNC(gich_vmcr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_vmcr, 0x4) }
		inline uint32_t enable(uint32_t gich_vmcr_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_vmcr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_vmcr, 0x4) }
		inline uint32_t disable(uint32_t gich_vmcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_vmcr_val, 0x4) }
	}

	namespace veng1
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_vmcr, 1) }
		inline uint32_t is_enabled(uint32_t gich_vmcr_val) noexcept { IS_BIT_ENABLED_FUNC(gich_vmcr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_vmcr, 1) }
		inline uint32_t is_disabled(uint32_t gich_vmcr_val) noexcept { IS_BIT_DISABLED_FUNC(gich_vmcr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_vmcr, 0x2) }
		inline uint32_t enable(uint32_t gich_vmcr_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_vmcr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_vmcr, 0x2) }
		inline uint32_t disable(uint32_t gich_vmcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_vmcr_val, 0x2) }
	}

	namespace veng0
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_vmcr, 0) }
		inline uint32_t is_enabled(uint32_t gich_vmcr_val) noexcept { IS_BIT_ENABLED_FUNC(gich_vmcr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_vmcr, 0) }
		inline uint32_t is_disabled(uint32_t gich_vmcr_val) noexcept { IS_BIT_DISABLED_FUNC(gich_vmcr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_vmcr, 0x1) }
		inline uint32_t enable(uint32_t gich_vmcr_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_vmcr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_vmcr, 0x1) }
		inline uint32_t disable(uint32_t gich_vmcr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_vmcr_val, 0x1) }
	}
}

// GICH_VTR (Virtual Type Register)
// Indicates the number of implemented virtual priority bits and List registers.
namespace gich_vtr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gich_vtr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gich_vtr, val) }

	namespace pribits
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gich_vtr, 0xe0000000, 29) }
		inline uint32_t get(uint32_t gich_vtr_val) noexcept { GET_BITFIELD_FUNC(gich_vtr_val, 0xe0000000, 29) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gich_vtr, value, 0xe0000000, 29) }
		inline uint32_t set(uint32_t gich_vtr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gich_vtr, value, 0xe0000000, 29) }
	}

	namespace prebits
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gich_vtr, 0x1c000000, 26) }
		inline uint32_t get(uint32_t gich_vtr_val) noexcept { GET_BITFIELD_FUNC(gich_vtr_val, 0x1c000000, 26) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gich_vtr, value, 0x1c000000, 26) }
		inline uint32_t set(uint32_t gich_vtr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gich_vtr, value, 0x1c000000, 26) }
	}

	namespace idbits
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gich_vtr, 0x3800000, 23) }
		inline uint32_t get(uint32_t gich_vtr_val) noexcept { GET_BITFIELD_FUNC(gich_vtr_val, 0x3800000, 23) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gich_vtr, value, 0x3800000, 23) }
		inline uint32_t set(uint32_t gich_vtr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gich_vtr, value, 0x3800000, 23) }
	}

	namespace seis
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_vtr, 22) }
		inline uint32_t is_enabled(uint32_t gich_vtr_val) noexcept { IS_BIT_ENABLED_FUNC(gich_vtr_val, 22) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_vtr, 22) }
		inline uint32_t is_disabled(uint32_t gich_vtr_val) noexcept { IS_BIT_DISABLED_FUNC(gich_vtr_val, 22) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_vtr, 0x400000) }
		inline uint32_t enable(uint32_t gich_vtr_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_vtr_val, 0x400000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_vtr, 0x400000) }
		inline uint32_t disable(uint32_t gich_vtr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_vtr_val, 0x400000) }
	}

	namespace a3v
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gich_vtr, 21) }
		inline uint32_t is_enabled(uint32_t gich_vtr_val) noexcept { IS_BIT_ENABLED_FUNC(gich_vtr_val, 21) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gich_vtr, 21) }
		inline uint32_t is_disabled(uint32_t gich_vtr_val) noexcept { IS_BIT_DISABLED_FUNC(gich_vtr_val, 21) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gich_vtr, 0x200000) }
		inline uint32_t enable(uint32_t gich_vtr_val) noexcept { SET_BITS_BY_MASK_FUNC(gich_vtr_val, 0x200000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gich_vtr, 0x200000) }
		inline uint32_t disable(uint32_t gich_vtr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gich_vtr_val, 0x200000) }
	}

	namespace listregs
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gich_vtr, 0x1f, 0) }
		inline uint32_t get(uint32_t gich_vtr_val) noexcept { GET_BITFIELD_FUNC(gich_vtr_val, 0x1f, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gich_vtr, value, 0x1f, 0) }
		inline uint32_t set(uint32_t gich_vtr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gich_vtr, value, 0x1f, 0) }
	}
}

// GICR_CLRLPIR (Clear LPI Pending Register)
// Clears the pending state of the specified LPI.
namespace gicr_clrlpir
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(gicr_clrlpir) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_clrlpir, val) }

	namespace pintid
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_clrlpir, 0xffffffff, 0) }
		inline uint64_t get(uint64_t gicr_clrlpir_val) noexcept { GET_BITFIELD_FUNC(gicr_clrlpir_val, 0xffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_clrlpir, value, 0xffffffff, 0) }
		inline uint64_t set(uint64_t gicr_clrlpir, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_clrlpir, value, 0xffffffff, 0) }
	}
}

// GICR_CTLR (Redistributor Control Register)
// Controls the operation of a Redistributor, and enables the signaling of LPIs by the Redistributor to the connected PE.
namespace gicr_ctlr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicr_ctlr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_ctlr, val) }

	namespace uwp
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicr_ctlr, 31) }
		inline uint32_t is_enabled(uint32_t gicr_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicr_ctlr_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicr_ctlr, 31) }
		inline uint32_t is_disabled(uint32_t gicr_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicr_ctlr_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicr_ctlr, 0x80000000) }
		inline uint32_t enable(uint32_t gicr_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicr_ctlr_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicr_ctlr, 0x80000000) }
		inline uint32_t disable(uint32_t gicr_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicr_ctlr_val, 0x80000000) }
	}

	namespace dpg1s
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicr_ctlr, 26) }
		inline uint32_t is_enabled(uint32_t gicr_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicr_ctlr_val, 26) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicr_ctlr, 26) }
		inline uint32_t is_disabled(uint32_t gicr_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicr_ctlr_val, 26) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicr_ctlr, 0x4000000) }
		inline uint32_t enable(uint32_t gicr_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicr_ctlr_val, 0x4000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicr_ctlr, 0x4000000) }
		inline uint32_t disable(uint32_t gicr_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicr_ctlr_val, 0x4000000) }
	}

	namespace dpg1ns
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicr_ctlr, 25) }
		inline uint32_t is_enabled(uint32_t gicr_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicr_ctlr_val, 25) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicr_ctlr, 25) }
		inline uint32_t is_disabled(uint32_t gicr_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicr_ctlr_val, 25) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicr_ctlr, 0x2000000) }
		inline uint32_t enable(uint32_t gicr_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicr_ctlr_val, 0x2000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicr_ctlr, 0x2000000) }
		inline uint32_t disable(uint32_t gicr_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicr_ctlr_val, 0x2000000) }
	}

	namespace dpg0
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicr_ctlr, 24) }
		inline uint32_t is_enabled(uint32_t gicr_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicr_ctlr_val, 24) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicr_ctlr, 24) }
		inline uint32_t is_disabled(uint32_t gicr_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicr_ctlr_val, 24) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicr_ctlr, 0x1000000) }
		inline uint32_t enable(uint32_t gicr_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicr_ctlr_val, 0x1000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicr_ctlr, 0x1000000) }
		inline uint32_t disable(uint32_t gicr_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicr_ctlr_val, 0x1000000) }
	}

	namespace rwp
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicr_ctlr, 3) }
		inline uint32_t is_enabled(uint32_t gicr_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicr_ctlr_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicr_ctlr, 3) }
		inline uint32_t is_disabled(uint32_t gicr_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicr_ctlr_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicr_ctlr, 0x8) }
		inline uint32_t enable(uint32_t gicr_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicr_ctlr_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicr_ctlr, 0x8) }
		inline uint32_t disable(uint32_t gicr_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicr_ctlr_val, 0x8) }
	}

	namespace enablelpis
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicr_ctlr, 0) }
		inline uint32_t is_enabled(uint32_t gicr_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicr_ctlr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicr_ctlr, 0) }
		inline uint32_t is_disabled(uint32_t gicr_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicr_ctlr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicr_ctlr, 0x1) }
		inline uint32_t enable(uint32_t gicr_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicr_ctlr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicr_ctlr, 0x1) }
		inline uint32_t disable(uint32_t gicr_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicr_ctlr_val, 0x1) }
	}
}

// GICR_ICACTIVER0 (Interrupt Clear-Active Register 0)
// Deactivates the corresponding SGI or PPI. These registers are used when saving and restoring GIC state.
namespace gicr_icactiver0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicr_icactiver0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_icactiver0, val) }

	namespace clear_active_bit_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_icactiver0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gicr_icactiver0_val) noexcept { GET_BITFIELD_FUNC(gicr_icactiver0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_icactiver0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gicr_icactiver0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_icactiver0, value, 0xffffffff, 0) }
	}
}

// GICR_ICENABLER0 (Interrupt Clear-Enable Register 0)
// Disables forwarding of the corresponding SGI or PPI to the CPU interfaces.
namespace gicr_icenabler0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicr_icenabler0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_icenabler0, val) }

	namespace clear_enable_bit_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_icenabler0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gicr_icenabler0_val) noexcept { GET_BITFIELD_FUNC(gicr_icenabler0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_icenabler0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gicr_icenabler0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_icenabler0, value, 0xffffffff, 0) }
	}
}

// GICR_ICFGR0 (Interrupt Configuration Register 0)
// Determines whether the corresponding SGI is edge-triggered or level-sensitive.
namespace gicr_icfgr0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicr_icfgr0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_icfgr0, val) }

	namespace int_config_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_icfgr0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gicr_icfgr0_val) noexcept { GET_BITFIELD_FUNC(gicr_icfgr0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_icfgr0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gicr_icfgr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_icfgr0, value, 0xffffffff, 0) }
	}
}

// GICR_ICFGR1 (Interrupt Configuration Register 1)
// Determines whether the corresponding PPI is edge-triggered or level-sensitive.
namespace gicr_icfgr1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicr_icfgr1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_icfgr1, val) }

	namespace int_config_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_icfgr1, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gicr_icfgr1_val) noexcept { GET_BITFIELD_FUNC(gicr_icfgr1_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_icfgr1, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gicr_icfgr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_icfgr1, value, 0xffffffff, 0) }
	}
}

// GICR_ICPENDR0 (Interrupt Clear-Pending Register 0)
// Removes the pending state from the corresponding SGI or PPI.
namespace gicr_icpendr0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicr_icpendr0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_icpendr0, val) }

	namespace clear_pending_bit_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_icpendr0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gicr_icpendr0_val) noexcept { GET_BITFIELD_FUNC(gicr_icpendr0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_icpendr0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gicr_icpendr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_icpendr0, value, 0xffffffff, 0) }
	}
}

// GICR_IGROUPR0 (Interrupt Group Register 0)
// Controls whether the corresponding SGI or PPI is in Group 0 or Group 1.
namespace gicr_igroupr0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicr_igroupr0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_igroupr0, val) }

	namespace redistributor_group_status_bit_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_igroupr0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gicr_igroupr0_val) noexcept { GET_BITFIELD_FUNC(gicr_igroupr0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_igroupr0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gicr_igroupr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_igroupr0, value, 0xffffffff, 0) }
	}
}

// GICR_IGRPMODR0 (Interrupt Group Modifier Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicr_igrpmodr0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicr_igrpmodr0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_igrpmodr0, val) }

	namespace group_modifier_bit_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_igrpmodr0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gicr_igrpmodr0_val) noexcept { GET_BITFIELD_FUNC(gicr_igrpmodr0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_igrpmodr0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gicr_igrpmodr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_igrpmodr0, value, 0xffffffff, 0) }
	}
}

// GICR_IIDR (Redistributor Implementer Identification Register)
// Provides information about the implementer and revision of the Redistributor.
namespace gicr_iidr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicr_iidr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_iidr, val) }

	namespace productid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_iidr, 0xff000000, 24) }
		inline uint32_t get(uint32_t gicr_iidr_val) noexcept { GET_BITFIELD_FUNC(gicr_iidr_val, 0xff000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_iidr, value, 0xff000000, 24) }
		inline uint32_t set(uint32_t gicr_iidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_iidr, value, 0xff000000, 24) }
	}

	namespace variant
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_iidr, 0xf0000, 16) }
		inline uint32_t get(uint32_t gicr_iidr_val) noexcept { GET_BITFIELD_FUNC(gicr_iidr_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_iidr, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t gicr_iidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_iidr, value, 0xf0000, 16) }
	}

	namespace revision
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_iidr, 0xf000, 12) }
		inline uint32_t get(uint32_t gicr_iidr_val) noexcept { GET_BITFIELD_FUNC(gicr_iidr_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_iidr, value, 0xf000, 12) }
		inline uint32_t set(uint32_t gicr_iidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_iidr, value, 0xf000, 12) }
	}

	namespace implementer
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_iidr, 0xfff, 0) }
		inline uint32_t get(uint32_t gicr_iidr_val) noexcept { GET_BITFIELD_FUNC(gicr_iidr_val, 0xfff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_iidr, value, 0xfff, 0) }
		inline uint32_t set(uint32_t gicr_iidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_iidr, value, 0xfff, 0) }
	}
}

// GICR_INVALLR (Redistributor Invalidate All Register)
// Invalidates any cached configuration data of all physical LPIs, causing the GIC to reload the interrupt configuration from the physical LPI Configuration table at the address specified by GICR_PROPBASER.
namespace gicr_invallr
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(gicr_invallr) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_invallr, val) }
}

// GICR_INVLPIR (Redistributor Invalidate LPI Register)
// Invalidates the cached configuration data of a specified LPI, causing the GIC to reload the interrupt configuration from the physical LPI Configuration table at the address specified by GICR_PROPBASER.
namespace gicr_invlpir
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(gicr_invlpir) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_invlpir, val) }

	namespace pintid
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_invlpir, 0xffffffff, 0) }
		inline uint64_t get(uint64_t gicr_invlpir_val) noexcept { GET_BITFIELD_FUNC(gicr_invlpir_val, 0xffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_invlpir, value, 0xffffffff, 0) }
		inline uint64_t set(uint64_t gicr_invlpir, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_invlpir, value, 0xffffffff, 0) }
	}
}

// GICR_IPRIORITYR<n> (Interrupt Priority Registers)
// Holds the priority of the corresponding interrupt for each SGI and PPI supported by the GIC.
namespace gicr_ipriorityr<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicr_ipriorityr<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_ipriorityr<n>, val) }

	namespace priority_offset_3b
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_ipriorityr<n>, 0xff000000, 24) }
		inline uint32_t get(uint32_t gicr_ipriorityr<n>_val) noexcept { GET_BITFIELD_FUNC(gicr_ipriorityr<n>_val, 0xff000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_ipriorityr<n>, value, 0xff000000, 24) }
		inline uint32_t set(uint32_t gicr_ipriorityr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_ipriorityr<n>, value, 0xff000000, 24) }
	}

	namespace priority_offset_2b
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_ipriorityr<n>, 0xff0000, 16) }
		inline uint32_t get(uint32_t gicr_ipriorityr<n>_val) noexcept { GET_BITFIELD_FUNC(gicr_ipriorityr<n>_val, 0xff0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_ipriorityr<n>, value, 0xff0000, 16) }
		inline uint32_t set(uint32_t gicr_ipriorityr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_ipriorityr<n>, value, 0xff0000, 16) }
	}

	namespace priority_offset_1b
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_ipriorityr<n>, 0xff00, 8) }
		inline uint32_t get(uint32_t gicr_ipriorityr<n>_val) noexcept { GET_BITFIELD_FUNC(gicr_ipriorityr<n>_val, 0xff00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_ipriorityr<n>, value, 0xff00, 8) }
		inline uint32_t set(uint32_t gicr_ipriorityr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_ipriorityr<n>, value, 0xff00, 8) }
	}

	namespace priority_offset_0b
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_ipriorityr<n>, 0xff, 0) }
		inline uint32_t get(uint32_t gicr_ipriorityr<n>_val) noexcept { GET_BITFIELD_FUNC(gicr_ipriorityr<n>_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_ipriorityr<n>, value, 0xff, 0) }
		inline uint32_t set(uint32_t gicr_ipriorityr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_ipriorityr<n>, value, 0xff, 0) }
	}
}

// GICR_ISACTIVER0 (Interrupt Set-Active Register 0)
// Activates the corresponding SGI or PPI. These registers are used when saving and restoring GIC state.
namespace gicr_isactiver0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicr_isactiver0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_isactiver0, val) }

	namespace set_active_bit_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_isactiver0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gicr_isactiver0_val) noexcept { GET_BITFIELD_FUNC(gicr_isactiver0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_isactiver0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gicr_isactiver0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_isactiver0, value, 0xffffffff, 0) }
	}
}

// GICR_ISENABLER0 (Interrupt Set-Enable Register 0)
// Enables forwarding of the corresponding SGI or PPI to the CPU interfaces.
namespace gicr_isenabler0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicr_isenabler0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_isenabler0, val) }

	namespace set_enable_bit_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_isenabler0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gicr_isenabler0_val) noexcept { GET_BITFIELD_FUNC(gicr_isenabler0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_isenabler0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gicr_isenabler0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_isenabler0, value, 0xffffffff, 0) }
	}
}

// GICR_ISPENDR0 (Interrupt Set-Pending Register 0)
// Adds the pending state to the corresponding SGI or PPI.
namespace gicr_ispendr0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicr_ispendr0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_ispendr0, val) }

	namespace set_pending_bit_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_ispendr0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gicr_ispendr0_val) noexcept { GET_BITFIELD_FUNC(gicr_ispendr0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_ispendr0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gicr_ispendr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_ispendr0, value, 0xffffffff, 0) }
	}
}

// GICR_NSACR (Non-secure Access Control Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicr_nsacr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicr_nsacr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_nsacr, val) }

	namespace ns_access_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_nsacr, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gicr_nsacr_val) noexcept { GET_BITFIELD_FUNC(gicr_nsacr_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_nsacr, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gicr_nsacr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_nsacr, value, 0xffffffff, 0) }
	}
}

// GICR_PENDBASER (Redistributor LPI Pending Table Base Address Register)
// Specifies the base address of the LPI Pending table, and the Shareability and Cacheability of accesses to the LPI Pending table.
namespace gicr_pendbaser
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(gicr_pendbaser) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_pendbaser, val) }

	namespace ptz
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicr_pendbaser, 62) }
		inline uint64_t is_enabled(uint64_t gicr_pendbaser_val) noexcept { IS_BIT_ENABLED_FUNC(gicr_pendbaser_val, 62) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicr_pendbaser, 62) }
		inline uint64_t is_disabled(uint64_t gicr_pendbaser_val) noexcept { IS_BIT_DISABLED_FUNC(gicr_pendbaser_val, 62) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicr_pendbaser, 0x4000000000000000) }
		inline uint64_t enable(uint64_t gicr_pendbaser_val) noexcept { SET_BITS_BY_MASK_FUNC(gicr_pendbaser_val, 0x4000000000000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicr_pendbaser, 0x4000000000000000) }
		inline uint64_t disable(uint64_t gicr_pendbaser_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicr_pendbaser_val, 0x4000000000000000) }
	}

	namespace outercache
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_pendbaser, 0x700000000000000, 56) }
		inline uint64_t get(uint64_t gicr_pendbaser_val) noexcept { GET_BITFIELD_FUNC(gicr_pendbaser_val, 0x700000000000000, 56) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_pendbaser, value, 0x700000000000000, 56) }
		inline uint64_t set(uint64_t gicr_pendbaser, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_pendbaser, value, 0x700000000000000, 56) }
	}

	namespace physical_address
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_pendbaser, 0xfffffffff0000, 16) }
		inline uint64_t get(uint64_t gicr_pendbaser_val) noexcept { GET_BITFIELD_FUNC(gicr_pendbaser_val, 0xfffffffff0000, 16) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_pendbaser, value, 0xfffffffff0000, 16) }
		inline uint64_t set(uint64_t gicr_pendbaser, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_pendbaser, value, 0xfffffffff0000, 16) }
	}

	namespace shareability
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_pendbaser, 0xc00, 10) }
		inline uint64_t get(uint64_t gicr_pendbaser_val) noexcept { GET_BITFIELD_FUNC(gicr_pendbaser_val, 0xc00, 10) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_pendbaser, value, 0xc00, 10) }
		inline uint64_t set(uint64_t gicr_pendbaser, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_pendbaser, value, 0xc00, 10) }
	}

	namespace innercache
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_pendbaser, 0x380, 7) }
		inline uint64_t get(uint64_t gicr_pendbaser_val) noexcept { GET_BITFIELD_FUNC(gicr_pendbaser_val, 0x380, 7) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_pendbaser, value, 0x380, 7) }
		inline uint64_t set(uint64_t gicr_pendbaser, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_pendbaser, value, 0x380, 7) }
	}
}

// GICR_PROPBASER (Redistributor Properties Base Address Register)
// Specifies the base address of the LPI Configuration table, and the Shareability and Cacheability of accesses to the LPI Configuration table.
namespace gicr_propbaser
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(gicr_propbaser) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_propbaser, val) }

	namespace outercache
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_propbaser, 0x700000000000000, 56) }
		inline uint64_t get(uint64_t gicr_propbaser_val) noexcept { GET_BITFIELD_FUNC(gicr_propbaser_val, 0x700000000000000, 56) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_propbaser, value, 0x700000000000000, 56) }
		inline uint64_t set(uint64_t gicr_propbaser, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_propbaser, value, 0x700000000000000, 56) }
	}

	namespace physical_address
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_propbaser, 0xffffffffff000, 12) }
		inline uint64_t get(uint64_t gicr_propbaser_val) noexcept { GET_BITFIELD_FUNC(gicr_propbaser_val, 0xffffffffff000, 12) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_propbaser, value, 0xffffffffff000, 12) }
		inline uint64_t set(uint64_t gicr_propbaser, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_propbaser, value, 0xffffffffff000, 12) }
	}

	namespace shareability
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_propbaser, 0xc00, 10) }
		inline uint64_t get(uint64_t gicr_propbaser_val) noexcept { GET_BITFIELD_FUNC(gicr_propbaser_val, 0xc00, 10) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_propbaser, value, 0xc00, 10) }
		inline uint64_t set(uint64_t gicr_propbaser, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_propbaser, value, 0xc00, 10) }
	}

	namespace innercache
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_propbaser, 0x380, 7) }
		inline uint64_t get(uint64_t gicr_propbaser_val) noexcept { GET_BITFIELD_FUNC(gicr_propbaser_val, 0x380, 7) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_propbaser, value, 0x380, 7) }
		inline uint64_t set(uint64_t gicr_propbaser, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_propbaser, value, 0x380, 7) }
	}

	namespace idbits
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_propbaser, 0x1f, 0) }
		inline uint64_t get(uint64_t gicr_propbaser_val) noexcept { GET_BITFIELD_FUNC(gicr_propbaser_val, 0x1f, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_propbaser, value, 0x1f, 0) }
		inline uint64_t set(uint64_t gicr_propbaser, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_propbaser, value, 0x1f, 0) }
	}
}

// GICR_SETLPIR (Set LPI Pending Register)
// Generates an LPI by setting the pending state of the specified LPI.
namespace gicr_setlpir
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(gicr_setlpir) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_setlpir, val) }

	namespace pintid
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_setlpir, 0xffffffff, 0) }
		inline uint64_t get(uint64_t gicr_setlpir_val) noexcept { GET_BITFIELD_FUNC(gicr_setlpir_val, 0xffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_setlpir, value, 0xffffffff, 0) }
		inline uint64_t set(uint64_t gicr_setlpir, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_setlpir, value, 0xffffffff, 0) }
	}
}

// GICR_STATUSR (Error Reporting Status Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicr_statusr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicr_statusr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_statusr, val) }

	namespace wrod
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicr_statusr, 3) }
		inline uint32_t is_enabled(uint32_t gicr_statusr_val) noexcept { IS_BIT_ENABLED_FUNC(gicr_statusr_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicr_statusr, 3) }
		inline uint32_t is_disabled(uint32_t gicr_statusr_val) noexcept { IS_BIT_DISABLED_FUNC(gicr_statusr_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicr_statusr, 0x8) }
		inline uint32_t enable(uint32_t gicr_statusr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicr_statusr_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicr_statusr, 0x8) }
		inline uint32_t disable(uint32_t gicr_statusr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicr_statusr_val, 0x8) }
	}

	namespace rwod
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicr_statusr, 2) }
		inline uint32_t is_enabled(uint32_t gicr_statusr_val) noexcept { IS_BIT_ENABLED_FUNC(gicr_statusr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicr_statusr, 2) }
		inline uint32_t is_disabled(uint32_t gicr_statusr_val) noexcept { IS_BIT_DISABLED_FUNC(gicr_statusr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicr_statusr, 0x4) }
		inline uint32_t enable(uint32_t gicr_statusr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicr_statusr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicr_statusr, 0x4) }
		inline uint32_t disable(uint32_t gicr_statusr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicr_statusr_val, 0x4) }
	}

	namespace wrd
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicr_statusr, 1) }
		inline uint32_t is_enabled(uint32_t gicr_statusr_val) noexcept { IS_BIT_ENABLED_FUNC(gicr_statusr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicr_statusr, 1) }
		inline uint32_t is_disabled(uint32_t gicr_statusr_val) noexcept { IS_BIT_DISABLED_FUNC(gicr_statusr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicr_statusr, 0x2) }
		inline uint32_t enable(uint32_t gicr_statusr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicr_statusr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicr_statusr, 0x2) }
		inline uint32_t disable(uint32_t gicr_statusr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicr_statusr_val, 0x2) }
	}

	namespace rrd
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicr_statusr, 0) }
		inline uint32_t is_enabled(uint32_t gicr_statusr_val) noexcept { IS_BIT_ENABLED_FUNC(gicr_statusr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicr_statusr, 0) }
		inline uint32_t is_disabled(uint32_t gicr_statusr_val) noexcept { IS_BIT_DISABLED_FUNC(gicr_statusr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicr_statusr, 0x1) }
		inline uint32_t enable(uint32_t gicr_statusr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicr_statusr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicr_statusr, 0x1) }
		inline uint32_t disable(uint32_t gicr_statusr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicr_statusr_val, 0x1) }
	}
}

// GICR_SYNCR (Redistributor Synchronize Register)
// Indicates completion of physical Redistributor operations.
namespace gicr_syncr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicr_syncr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_syncr, val) }

	namespace busy
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicr_syncr, 0) }
		inline uint32_t is_enabled(uint32_t gicr_syncr_val) noexcept { IS_BIT_ENABLED_FUNC(gicr_syncr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicr_syncr, 0) }
		inline uint32_t is_disabled(uint32_t gicr_syncr_val) noexcept { IS_BIT_DISABLED_FUNC(gicr_syncr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicr_syncr, 0x1) }
		inline uint32_t enable(uint32_t gicr_syncr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicr_syncr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicr_syncr, 0x1) }
		inline uint32_t disable(uint32_t gicr_syncr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicr_syncr_val, 0x1) }
	}
}

// GICR_TYPER (Redistributor Type Register)
// Provides information about the configuration of this Redistributor.
namespace gicr_typer
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(gicr_typer) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_typer, val) }

	namespace affinity_value
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_typer, 0xffffffff00000000, 32) }
		inline uint64_t get(uint64_t gicr_typer_val) noexcept { GET_BITFIELD_FUNC(gicr_typer_val, 0xffffffff00000000, 32) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_typer, value, 0xffffffff00000000, 32) }
		inline uint64_t set(uint64_t gicr_typer, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_typer, value, 0xffffffff00000000, 32) }
	}

	namespace commonlpiaff
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_typer, 0x3000000, 24) }
		inline uint64_t get(uint64_t gicr_typer_val) noexcept { GET_BITFIELD_FUNC(gicr_typer_val, 0x3000000, 24) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_typer, value, 0x3000000, 24) }
		inline uint64_t set(uint64_t gicr_typer, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_typer, value, 0x3000000, 24) }
	}

	namespace processor_number
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_typer, 0xffff00, 8) }
		inline uint64_t get(uint64_t gicr_typer_val) noexcept { GET_BITFIELD_FUNC(gicr_typer_val, 0xffff00, 8) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_typer, value, 0xffff00, 8) }
		inline uint64_t set(uint64_t gicr_typer, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_typer, value, 0xffff00, 8) }
	}

	namespace dpgs
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicr_typer, 5) }
		inline uint64_t is_enabled(uint64_t gicr_typer_val) noexcept { IS_BIT_ENABLED_FUNC(gicr_typer_val, 5) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicr_typer, 5) }
		inline uint64_t is_disabled(uint64_t gicr_typer_val) noexcept { IS_BIT_DISABLED_FUNC(gicr_typer_val, 5) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicr_typer, 0x20) }
		inline uint64_t enable(uint64_t gicr_typer_val) noexcept { SET_BITS_BY_MASK_FUNC(gicr_typer_val, 0x20) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicr_typer, 0x20) }
		inline uint64_t disable(uint64_t gicr_typer_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicr_typer_val, 0x20) }
	}

	namespace last
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicr_typer, 4) }
		inline uint64_t is_enabled(uint64_t gicr_typer_val) noexcept { IS_BIT_ENABLED_FUNC(gicr_typer_val, 4) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicr_typer, 4) }
		inline uint64_t is_disabled(uint64_t gicr_typer_val) noexcept { IS_BIT_DISABLED_FUNC(gicr_typer_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicr_typer, 0x10) }
		inline uint64_t enable(uint64_t gicr_typer_val) noexcept { SET_BITS_BY_MASK_FUNC(gicr_typer_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicr_typer, 0x10) }
		inline uint64_t disable(uint64_t gicr_typer_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicr_typer_val, 0x10) }
	}

	namespace directlpi
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicr_typer, 3) }
		inline uint64_t is_enabled(uint64_t gicr_typer_val) noexcept { IS_BIT_ENABLED_FUNC(gicr_typer_val, 3) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicr_typer, 3) }
		inline uint64_t is_disabled(uint64_t gicr_typer_val) noexcept { IS_BIT_DISABLED_FUNC(gicr_typer_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicr_typer, 0x8) }
		inline uint64_t enable(uint64_t gicr_typer_val) noexcept { SET_BITS_BY_MASK_FUNC(gicr_typer_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicr_typer, 0x8) }
		inline uint64_t disable(uint64_t gicr_typer_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicr_typer_val, 0x8) }
	}

	namespace vlpis
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicr_typer, 1) }
		inline uint64_t is_enabled(uint64_t gicr_typer_val) noexcept { IS_BIT_ENABLED_FUNC(gicr_typer_val, 1) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicr_typer, 1) }
		inline uint64_t is_disabled(uint64_t gicr_typer_val) noexcept { IS_BIT_DISABLED_FUNC(gicr_typer_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicr_typer, 0x2) }
		inline uint64_t enable(uint64_t gicr_typer_val) noexcept { SET_BITS_BY_MASK_FUNC(gicr_typer_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicr_typer, 0x2) }
		inline uint64_t disable(uint64_t gicr_typer_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicr_typer_val, 0x2) }
	}

	namespace plpis
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicr_typer, 0) }
		inline uint64_t is_enabled(uint64_t gicr_typer_val) noexcept { IS_BIT_ENABLED_FUNC(gicr_typer_val, 0) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicr_typer, 0) }
		inline uint64_t is_disabled(uint64_t gicr_typer_val) noexcept { IS_BIT_DISABLED_FUNC(gicr_typer_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicr_typer, 0x1) }
		inline uint64_t enable(uint64_t gicr_typer_val) noexcept { SET_BITS_BY_MASK_FUNC(gicr_typer_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicr_typer, 0x1) }
		inline uint64_t disable(uint64_t gicr_typer_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicr_typer_val, 0x1) }
	}
}

// GICR_VPENDBASER (Virtual Redistributor LPI Pending Table Base Address Register)
// Specifies the base address of the memory that holds the virtual LPI Pending table for the currently scheduled virtual machine.
namespace gicr_vpendbaser
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(gicr_vpendbaser) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_vpendbaser, val) }

	namespace valid
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicr_vpendbaser, 63) }
		inline uint64_t is_enabled(uint64_t gicr_vpendbaser_val) noexcept { IS_BIT_ENABLED_FUNC(gicr_vpendbaser_val, 63) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicr_vpendbaser, 63) }
		inline uint64_t is_disabled(uint64_t gicr_vpendbaser_val) noexcept { IS_BIT_DISABLED_FUNC(gicr_vpendbaser_val, 63) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicr_vpendbaser, 0x8000000000000000) }
		inline uint64_t enable(uint64_t gicr_vpendbaser_val) noexcept { SET_BITS_BY_MASK_FUNC(gicr_vpendbaser_val, 0x8000000000000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicr_vpendbaser, 0x8000000000000000) }
		inline uint64_t disable(uint64_t gicr_vpendbaser_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicr_vpendbaser_val, 0x8000000000000000) }
	}

	namespace idai
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicr_vpendbaser, 62) }
		inline uint64_t is_enabled(uint64_t gicr_vpendbaser_val) noexcept { IS_BIT_ENABLED_FUNC(gicr_vpendbaser_val, 62) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicr_vpendbaser, 62) }
		inline uint64_t is_disabled(uint64_t gicr_vpendbaser_val) noexcept { IS_BIT_DISABLED_FUNC(gicr_vpendbaser_val, 62) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicr_vpendbaser, 0x4000000000000000) }
		inline uint64_t enable(uint64_t gicr_vpendbaser_val) noexcept { SET_BITS_BY_MASK_FUNC(gicr_vpendbaser_val, 0x4000000000000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicr_vpendbaser, 0x4000000000000000) }
		inline uint64_t disable(uint64_t gicr_vpendbaser_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicr_vpendbaser_val, 0x4000000000000000) }
	}

	namespace pendinglast
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicr_vpendbaser, 61) }
		inline uint64_t is_enabled(uint64_t gicr_vpendbaser_val) noexcept { IS_BIT_ENABLED_FUNC(gicr_vpendbaser_val, 61) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicr_vpendbaser, 61) }
		inline uint64_t is_disabled(uint64_t gicr_vpendbaser_val) noexcept { IS_BIT_DISABLED_FUNC(gicr_vpendbaser_val, 61) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicr_vpendbaser, 0x2000000000000000) }
		inline uint64_t enable(uint64_t gicr_vpendbaser_val) noexcept { SET_BITS_BY_MASK_FUNC(gicr_vpendbaser_val, 0x2000000000000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicr_vpendbaser, 0x2000000000000000) }
		inline uint64_t disable(uint64_t gicr_vpendbaser_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicr_vpendbaser_val, 0x2000000000000000) }
	}

	namespace dirty
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicr_vpendbaser, 60) }
		inline uint64_t is_enabled(uint64_t gicr_vpendbaser_val) noexcept { IS_BIT_ENABLED_FUNC(gicr_vpendbaser_val, 60) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicr_vpendbaser, 60) }
		inline uint64_t is_disabled(uint64_t gicr_vpendbaser_val) noexcept { IS_BIT_DISABLED_FUNC(gicr_vpendbaser_val, 60) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicr_vpendbaser, 0x1000000000000000) }
		inline uint64_t enable(uint64_t gicr_vpendbaser_val) noexcept { SET_BITS_BY_MASK_FUNC(gicr_vpendbaser_val, 0x1000000000000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicr_vpendbaser, 0x1000000000000000) }
		inline uint64_t disable(uint64_t gicr_vpendbaser_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicr_vpendbaser_val, 0x1000000000000000) }
	}

	namespace outercache
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_vpendbaser, 0x700000000000000, 56) }
		inline uint64_t get(uint64_t gicr_vpendbaser_val) noexcept { GET_BITFIELD_FUNC(gicr_vpendbaser_val, 0x700000000000000, 56) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_vpendbaser, value, 0x700000000000000, 56) }
		inline uint64_t set(uint64_t gicr_vpendbaser, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_vpendbaser, value, 0x700000000000000, 56) }
	}

	namespace physical_address
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_vpendbaser, 0xfffffffff0000, 16) }
		inline uint64_t get(uint64_t gicr_vpendbaser_val) noexcept { GET_BITFIELD_FUNC(gicr_vpendbaser_val, 0xfffffffff0000, 16) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_vpendbaser, value, 0xfffffffff0000, 16) }
		inline uint64_t set(uint64_t gicr_vpendbaser, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_vpendbaser, value, 0xfffffffff0000, 16) }
	}

	namespace shareability
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_vpendbaser, 0xc00, 10) }
		inline uint64_t get(uint64_t gicr_vpendbaser_val) noexcept { GET_BITFIELD_FUNC(gicr_vpendbaser_val, 0xc00, 10) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_vpendbaser, value, 0xc00, 10) }
		inline uint64_t set(uint64_t gicr_vpendbaser, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_vpendbaser, value, 0xc00, 10) }
	}

	namespace innercache
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_vpendbaser, 0x380, 7) }
		inline uint64_t get(uint64_t gicr_vpendbaser_val) noexcept { GET_BITFIELD_FUNC(gicr_vpendbaser_val, 0x380, 7) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_vpendbaser, value, 0x380, 7) }
		inline uint64_t set(uint64_t gicr_vpendbaser, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_vpendbaser, value, 0x380, 7) }
	}
}

// GICR_VPROPBASER (Virtual Redistributor Properties Base Address Register)
// Specifies the base address of the memory that holds the virtual LPI Configuration table for the currently scheduled virtual machine.
namespace gicr_vpropbaser
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(gicr_vpropbaser) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_vpropbaser, val) }

	namespace outercache
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_vpropbaser, 0x700000000000000, 56) }
		inline uint64_t get(uint64_t gicr_vpropbaser_val) noexcept { GET_BITFIELD_FUNC(gicr_vpropbaser_val, 0x700000000000000, 56) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_vpropbaser, value, 0x700000000000000, 56) }
		inline uint64_t set(uint64_t gicr_vpropbaser, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_vpropbaser, value, 0x700000000000000, 56) }
	}

	namespace physical_address
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_vpropbaser, 0xffffffffff000, 12) }
		inline uint64_t get(uint64_t gicr_vpropbaser_val) noexcept { GET_BITFIELD_FUNC(gicr_vpropbaser_val, 0xffffffffff000, 12) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_vpropbaser, value, 0xffffffffff000, 12) }
		inline uint64_t set(uint64_t gicr_vpropbaser, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_vpropbaser, value, 0xffffffffff000, 12) }
	}

	namespace shareability
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_vpropbaser, 0xc00, 10) }
		inline uint64_t get(uint64_t gicr_vpropbaser_val) noexcept { GET_BITFIELD_FUNC(gicr_vpropbaser_val, 0xc00, 10) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_vpropbaser, value, 0xc00, 10) }
		inline uint64_t set(uint64_t gicr_vpropbaser, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_vpropbaser, value, 0xc00, 10) }
	}

	namespace innercache
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_vpropbaser, 0x380, 7) }
		inline uint64_t get(uint64_t gicr_vpropbaser_val) noexcept { GET_BITFIELD_FUNC(gicr_vpropbaser_val, 0x380, 7) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_vpropbaser, value, 0x380, 7) }
		inline uint64_t set(uint64_t gicr_vpropbaser, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_vpropbaser, value, 0x380, 7) }
	}

	namespace idbits
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicr_vpropbaser, 0x1f, 0) }
		inline uint64_t get(uint64_t gicr_vpropbaser_val) noexcept { GET_BITFIELD_FUNC(gicr_vpropbaser_val, 0x1f, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicr_vpropbaser, value, 0x1f, 0) }
		inline uint64_t set(uint64_t gicr_vpropbaser, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicr_vpropbaser, value, 0x1f, 0) }
	}
}

// GICR_WAKER (Redistributor Wake Register)
// Permits software to control the behavior of the 
namespace gicr_waker
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicr_waker) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicr_waker, val) }

	namespace childrenasleep
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicr_waker, 2) }
		inline uint32_t is_enabled(uint32_t gicr_waker_val) noexcept { IS_BIT_ENABLED_FUNC(gicr_waker_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicr_waker, 2) }
		inline uint32_t is_disabled(uint32_t gicr_waker_val) noexcept { IS_BIT_DISABLED_FUNC(gicr_waker_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicr_waker, 0x4) }
		inline uint32_t enable(uint32_t gicr_waker_val) noexcept { SET_BITS_BY_MASK_FUNC(gicr_waker_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicr_waker, 0x4) }
		inline uint32_t disable(uint32_t gicr_waker_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicr_waker_val, 0x4) }
	}

	namespace processorsleep
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicr_waker, 1) }
		inline uint32_t is_enabled(uint32_t gicr_waker_val) noexcept { IS_BIT_ENABLED_FUNC(gicr_waker_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicr_waker, 1) }
		inline uint32_t is_disabled(uint32_t gicr_waker_val) noexcept { IS_BIT_DISABLED_FUNC(gicr_waker_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicr_waker, 0x2) }
		inline uint32_t enable(uint32_t gicr_waker_val) noexcept { SET_BITS_BY_MASK_FUNC(gicr_waker_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicr_waker, 0x2) }
		inline uint32_t disable(uint32_t gicr_waker_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicr_waker_val, 0x2) }
	}
}

// GICV_ABPR (Virtual Machine Aliased Binary Point Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicv_abpr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicv_abpr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicv_abpr, val) }

	namespace binary_point
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicv_abpr, 0x7, 0) }
		inline uint32_t get(uint32_t gicv_abpr_val) noexcept { GET_BITFIELD_FUNC(gicv_abpr_val, 0x7, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicv_abpr, value, 0x7, 0) }
		inline uint32_t set(uint32_t gicv_abpr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicv_abpr, value, 0x7, 0) }
	}
}

// GICV_AEOIR (Virtual Machine Aliased End Of Interrupt Register)
// A write to this register performs a priority drop for the specified Group 1 virtual interrupt and, if GICV_CTLR.EOImode == 0, also deactivates the interrupt.
namespace gicv_aeoir
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicv_aeoir) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicv_aeoir, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicv_aeoir, 0x1ffffff, 0) }
		inline uint32_t get(uint32_t gicv_aeoir_val) noexcept { GET_BITFIELD_FUNC(gicv_aeoir_val, 0x1ffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicv_aeoir, value, 0x1ffffff, 0) }
		inline uint32_t set(uint32_t gicv_aeoir, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicv_aeoir, value, 0x1ffffff, 0) }
	}
}

// GICV_AHPPIR (Virtual Machine Aliased Highest Priority Pending Interrupt Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicv_ahppir
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicv_ahppir) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicv_ahppir, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicv_ahppir, 0x1ffffff, 0) }
		inline uint32_t get(uint32_t gicv_ahppir_val) noexcept { GET_BITFIELD_FUNC(gicv_ahppir_val, 0x1ffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicv_ahppir, value, 0x1ffffff, 0) }
		inline uint32_t set(uint32_t gicv_ahppir, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicv_ahppir, value, 0x1ffffff, 0) }
	}
}

// GICV_AIAR (Virtual Machine Aliased Interrupt Acknowledge Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicv_aiar
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicv_aiar) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicv_aiar, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicv_aiar, 0x1ffffff, 0) }
		inline uint32_t get(uint32_t gicv_aiar_val) noexcept { GET_BITFIELD_FUNC(gicv_aiar_val, 0x1ffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicv_aiar, value, 0x1ffffff, 0) }
		inline uint32_t set(uint32_t gicv_aiar, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicv_aiar, value, 0x1ffffff, 0) }
	}
}

// GICV_APR<n> (Virtual Machine Active Priorities Registers)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicv_apr<n>
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicv_apr<n>) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicv_apr<n>, val) }

	namespace p_x_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicv_apr<n>, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gicv_apr<n>_val) noexcept { GET_BITFIELD_FUNC(gicv_apr<n>_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicv_apr<n>, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gicv_apr<n>, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicv_apr<n>, value, 0xffffffff, 0) }
	}
}

// GICV_BPR (Virtual Machine Binary Point Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicv_bpr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicv_bpr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicv_bpr, val) }

	namespace binary_point
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicv_bpr, 0x7, 0) }
		inline uint32_t get(uint32_t gicv_bpr_val) noexcept { GET_BITFIELD_FUNC(gicv_bpr_val, 0x7, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicv_bpr, value, 0x7, 0) }
		inline uint32_t set(uint32_t gicv_bpr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicv_bpr, value, 0x7, 0) }
	}
}

// GICV_CTLR (Virtual Machine Control Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicv_ctlr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicv_ctlr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicv_ctlr, val) }

	namespace eoimode
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicv_ctlr, 9) }
		inline uint32_t is_enabled(uint32_t gicv_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicv_ctlr_val, 9) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicv_ctlr, 9) }
		inline uint32_t is_disabled(uint32_t gicv_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicv_ctlr_val, 9) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicv_ctlr, 0x200) }
		inline uint32_t enable(uint32_t gicv_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicv_ctlr_val, 0x200) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicv_ctlr, 0x200) }
		inline uint32_t disable(uint32_t gicv_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicv_ctlr_val, 0x200) }
	}

	namespace cbpr
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicv_ctlr, 4) }
		inline uint32_t is_enabled(uint32_t gicv_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicv_ctlr_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicv_ctlr, 4) }
		inline uint32_t is_disabled(uint32_t gicv_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicv_ctlr_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicv_ctlr, 0x10) }
		inline uint32_t enable(uint32_t gicv_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicv_ctlr_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicv_ctlr, 0x10) }
		inline uint32_t disable(uint32_t gicv_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicv_ctlr_val, 0x10) }
	}

	namespace fiqen
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicv_ctlr, 3) }
		inline uint32_t is_enabled(uint32_t gicv_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicv_ctlr_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicv_ctlr, 3) }
		inline uint32_t is_disabled(uint32_t gicv_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicv_ctlr_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicv_ctlr, 0x8) }
		inline uint32_t enable(uint32_t gicv_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicv_ctlr_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicv_ctlr, 0x8) }
		inline uint32_t disable(uint32_t gicv_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicv_ctlr_val, 0x8) }
	}

	namespace ackctl
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicv_ctlr, 2) }
		inline uint32_t is_enabled(uint32_t gicv_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicv_ctlr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicv_ctlr, 2) }
		inline uint32_t is_disabled(uint32_t gicv_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicv_ctlr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicv_ctlr, 0x4) }
		inline uint32_t enable(uint32_t gicv_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicv_ctlr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicv_ctlr, 0x4) }
		inline uint32_t disable(uint32_t gicv_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicv_ctlr_val, 0x4) }
	}

	namespace enablegrp1
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicv_ctlr, 1) }
		inline uint32_t is_enabled(uint32_t gicv_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicv_ctlr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicv_ctlr, 1) }
		inline uint32_t is_disabled(uint32_t gicv_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicv_ctlr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicv_ctlr, 0x2) }
		inline uint32_t enable(uint32_t gicv_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicv_ctlr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicv_ctlr, 0x2) }
		inline uint32_t disable(uint32_t gicv_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicv_ctlr_val, 0x2) }
	}

	namespace enablegrp0
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicv_ctlr, 0) }
		inline uint32_t is_enabled(uint32_t gicv_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gicv_ctlr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicv_ctlr, 0) }
		inline uint32_t is_disabled(uint32_t gicv_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gicv_ctlr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicv_ctlr, 0x1) }
		inline uint32_t enable(uint32_t gicv_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicv_ctlr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicv_ctlr, 0x1) }
		inline uint32_t disable(uint32_t gicv_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicv_ctlr_val, 0x1) }
	}
}

// GICV_DIR (Virtual Machine Deactivate Interrupt Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicv_dir
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicv_dir) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicv_dir, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicv_dir, 0x1ffffff, 0) }
		inline uint32_t get(uint32_t gicv_dir_val) noexcept { GET_BITFIELD_FUNC(gicv_dir_val, 0x1ffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicv_dir, value, 0x1ffffff, 0) }
		inline uint32_t set(uint32_t gicv_dir, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicv_dir, value, 0x1ffffff, 0) }
	}
}

// GICV_EOIR (Virtual Machine End Of Interrupt Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicv_eoir
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicv_eoir) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicv_eoir, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicv_eoir, 0x1ffffff, 0) }
		inline uint32_t get(uint32_t gicv_eoir_val) noexcept { GET_BITFIELD_FUNC(gicv_eoir_val, 0x1ffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicv_eoir, value, 0x1ffffff, 0) }
		inline uint32_t set(uint32_t gicv_eoir, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicv_eoir, value, 0x1ffffff, 0) }
	}
}

// GICV_HPPIR (Virtual Machine Highest Priority Pending Interrupt Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicv_hppir
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicv_hppir) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicv_hppir, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicv_hppir, 0x1ffffff, 0) }
		inline uint32_t get(uint32_t gicv_hppir_val) noexcept { GET_BITFIELD_FUNC(gicv_hppir_val, 0x1ffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicv_hppir, value, 0x1ffffff, 0) }
		inline uint32_t set(uint32_t gicv_hppir, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicv_hppir, value, 0x1ffffff, 0) }
	}
}

// GICV_IAR (Virtual Machine Interrupt Acknowledge Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicv_iar
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicv_iar) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicv_iar, val) }

	namespace intid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicv_iar, 0x1ffffff, 0) }
		inline uint32_t get(uint32_t gicv_iar_val) noexcept { GET_BITFIELD_FUNC(gicv_iar_val, 0x1ffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicv_iar, value, 0x1ffffff, 0) }
		inline uint32_t set(uint32_t gicv_iar, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicv_iar, value, 0x1ffffff, 0) }
	}
}

// GICV_IIDR (Virtual Machine CPU Interface Identification Register)
// Provides information about the implementer and revision of the virtual CPU interface.
namespace gicv_iidr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicv_iidr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicv_iidr, val) }

	namespace productid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicv_iidr, 0xfff00000, 20) }
		inline uint32_t get(uint32_t gicv_iidr_val) noexcept { GET_BITFIELD_FUNC(gicv_iidr_val, 0xfff00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicv_iidr, value, 0xfff00000, 20) }
		inline uint32_t set(uint32_t gicv_iidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicv_iidr, value, 0xfff00000, 20) }
	}

	namespace architecture_version
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicv_iidr, 0xf0000, 16) }
		inline uint32_t get(uint32_t gicv_iidr_val) noexcept { GET_BITFIELD_FUNC(gicv_iidr_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicv_iidr, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t gicv_iidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicv_iidr, value, 0xf0000, 16) }
	}

	namespace revision
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicv_iidr, 0xf000, 12) }
		inline uint32_t get(uint32_t gicv_iidr_val) noexcept { GET_BITFIELD_FUNC(gicv_iidr_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicv_iidr, value, 0xf000, 12) }
		inline uint32_t set(uint32_t gicv_iidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicv_iidr, value, 0xf000, 12) }
	}

	namespace implementer
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicv_iidr, 0xfff, 0) }
		inline uint32_t get(uint32_t gicv_iidr_val) noexcept { GET_BITFIELD_FUNC(gicv_iidr_val, 0xfff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicv_iidr, value, 0xfff, 0) }
		inline uint32_t set(uint32_t gicv_iidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicv_iidr, value, 0xfff, 0) }
	}
}

// GICV_PMR (Virtual Machine Priority Mask Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicv_pmr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicv_pmr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicv_pmr, val) }

	namespace priority
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicv_pmr, 0xff, 0) }
		inline uint32_t get(uint32_t gicv_pmr_val) noexcept { GET_BITFIELD_FUNC(gicv_pmr_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicv_pmr, value, 0xff, 0) }
		inline uint32_t set(uint32_t gicv_pmr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicv_pmr, value, 0xff, 0) }
	}
}

// GICV_RPR (Virtual Machine Running Priority Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicv_rpr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicv_rpr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicv_rpr, val) }

	namespace priority
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gicv_rpr, 0xff, 0) }
		inline uint32_t get(uint32_t gicv_rpr_val) noexcept { GET_BITFIELD_FUNC(gicv_rpr_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gicv_rpr, value, 0xff, 0) }
		inline uint32_t set(uint32_t gicv_rpr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gicv_rpr, value, 0xff, 0) }
	}
}

// GICV_STATUSR (Virtual Machine Error Reporting Status Register)
// See the ARMv8 architecture reference manual for a description of this register
namespace gicv_statusr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gicv_statusr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gicv_statusr, val) }

	namespace wrod
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicv_statusr, 3) }
		inline uint32_t is_enabled(uint32_t gicv_statusr_val) noexcept { IS_BIT_ENABLED_FUNC(gicv_statusr_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicv_statusr, 3) }
		inline uint32_t is_disabled(uint32_t gicv_statusr_val) noexcept { IS_BIT_DISABLED_FUNC(gicv_statusr_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicv_statusr, 0x8) }
		inline uint32_t enable(uint32_t gicv_statusr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicv_statusr_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicv_statusr, 0x8) }
		inline uint32_t disable(uint32_t gicv_statusr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicv_statusr_val, 0x8) }
	}

	namespace rwod
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicv_statusr, 2) }
		inline uint32_t is_enabled(uint32_t gicv_statusr_val) noexcept { IS_BIT_ENABLED_FUNC(gicv_statusr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicv_statusr, 2) }
		inline uint32_t is_disabled(uint32_t gicv_statusr_val) noexcept { IS_BIT_DISABLED_FUNC(gicv_statusr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicv_statusr, 0x4) }
		inline uint32_t enable(uint32_t gicv_statusr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicv_statusr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicv_statusr, 0x4) }
		inline uint32_t disable(uint32_t gicv_statusr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicv_statusr_val, 0x4) }
	}

	namespace wrd
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicv_statusr, 1) }
		inline uint32_t is_enabled(uint32_t gicv_statusr_val) noexcept { IS_BIT_ENABLED_FUNC(gicv_statusr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicv_statusr, 1) }
		inline uint32_t is_disabled(uint32_t gicv_statusr_val) noexcept { IS_BIT_DISABLED_FUNC(gicv_statusr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicv_statusr, 0x2) }
		inline uint32_t enable(uint32_t gicv_statusr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicv_statusr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicv_statusr, 0x2) }
		inline uint32_t disable(uint32_t gicv_statusr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicv_statusr_val, 0x2) }
	}

	namespace rrd
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gicv_statusr, 0) }
		inline uint32_t is_enabled(uint32_t gicv_statusr_val) noexcept { IS_BIT_ENABLED_FUNC(gicv_statusr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gicv_statusr, 0) }
		inline uint32_t is_disabled(uint32_t gicv_statusr_val) noexcept { IS_BIT_DISABLED_FUNC(gicv_statusr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gicv_statusr, 0x1) }
		inline uint32_t enable(uint32_t gicv_statusr_val) noexcept { SET_BITS_BY_MASK_FUNC(gicv_statusr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gicv_statusr, 0x1) }
		inline uint32_t disable(uint32_t gicv_statusr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gicv_statusr_val, 0x1) }
	}
}

// GITS_BASER<n> (ITS Translation Table Descriptors)
// Specifies the base address and size of the ITS translation tables.
namespace gits_baser<n>
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(gits_baser<n>) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gits_baser<n>, val) }

	namespace valid
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gits_baser<n>, 63) }
		inline uint64_t is_enabled(uint64_t gits_baser<n>_val) noexcept { IS_BIT_ENABLED_FUNC(gits_baser<n>_val, 63) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gits_baser<n>, 63) }
		inline uint64_t is_disabled(uint64_t gits_baser<n>_val) noexcept { IS_BIT_DISABLED_FUNC(gits_baser<n>_val, 63) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gits_baser<n>, 0x8000000000000000) }
		inline uint64_t enable(uint64_t gits_baser<n>_val) noexcept { SET_BITS_BY_MASK_FUNC(gits_baser<n>_val, 0x8000000000000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gits_baser<n>, 0x8000000000000000) }
		inline uint64_t disable(uint64_t gits_baser<n>_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gits_baser<n>_val, 0x8000000000000000) }
	}

	namespace indirect
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gits_baser<n>, 62) }
		inline uint64_t is_enabled(uint64_t gits_baser<n>_val) noexcept { IS_BIT_ENABLED_FUNC(gits_baser<n>_val, 62) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gits_baser<n>, 62) }
		inline uint64_t is_disabled(uint64_t gits_baser<n>_val) noexcept { IS_BIT_DISABLED_FUNC(gits_baser<n>_val, 62) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gits_baser<n>, 0x4000000000000000) }
		inline uint64_t enable(uint64_t gits_baser<n>_val) noexcept { SET_BITS_BY_MASK_FUNC(gits_baser<n>_val, 0x4000000000000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gits_baser<n>, 0x4000000000000000) }
		inline uint64_t disable(uint64_t gits_baser<n>_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gits_baser<n>_val, 0x4000000000000000) }
	}

	namespace innercache
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_baser<n>, 0x3800000000000000, 59) }
		inline uint64_t get(uint64_t gits_baser<n>_val) noexcept { GET_BITFIELD_FUNC(gits_baser<n>_val, 0x3800000000000000, 59) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_baser<n>, value, 0x3800000000000000, 59) }
		inline uint64_t set(uint64_t gits_baser<n>, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_baser<n>, value, 0x3800000000000000, 59) }
	}

	namespace type
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_baser<n>, 0x700000000000000, 56) }
		inline uint64_t get(uint64_t gits_baser<n>_val) noexcept { GET_BITFIELD_FUNC(gits_baser<n>_val, 0x700000000000000, 56) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_baser<n>, value, 0x700000000000000, 56) }
		inline uint64_t set(uint64_t gits_baser<n>, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_baser<n>, value, 0x700000000000000, 56) }
	}

	namespace outercache
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_baser<n>, 0xe0000000000000, 53) }
		inline uint64_t get(uint64_t gits_baser<n>_val) noexcept { GET_BITFIELD_FUNC(gits_baser<n>_val, 0xe0000000000000, 53) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_baser<n>, value, 0xe0000000000000, 53) }
		inline uint64_t set(uint64_t gits_baser<n>, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_baser<n>, value, 0xe0000000000000, 53) }
	}

	namespace entry_size
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_baser<n>, 0x1f000000000000, 48) }
		inline uint64_t get(uint64_t gits_baser<n>_val) noexcept { GET_BITFIELD_FUNC(gits_baser<n>_val, 0x1f000000000000, 48) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_baser<n>, value, 0x1f000000000000, 48) }
		inline uint64_t set(uint64_t gits_baser<n>, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_baser<n>, value, 0x1f000000000000, 48) }
	}

	namespace physical_address
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_baser<n>, 0xfffffffff000, 12) }
		inline uint64_t get(uint64_t gits_baser<n>_val) noexcept { GET_BITFIELD_FUNC(gits_baser<n>_val, 0xfffffffff000, 12) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_baser<n>, value, 0xfffffffff000, 12) }
		inline uint64_t set(uint64_t gits_baser<n>, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_baser<n>, value, 0xfffffffff000, 12) }
	}

	namespace shareability
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_baser<n>, 0xc00, 10) }
		inline uint64_t get(uint64_t gits_baser<n>_val) noexcept { GET_BITFIELD_FUNC(gits_baser<n>_val, 0xc00, 10) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_baser<n>, value, 0xc00, 10) }
		inline uint64_t set(uint64_t gits_baser<n>, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_baser<n>, value, 0xc00, 10) }
	}

	namespace page_size
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_baser<n>, 0x300, 8) }
		inline uint64_t get(uint64_t gits_baser<n>_val) noexcept { GET_BITFIELD_FUNC(gits_baser<n>_val, 0x300, 8) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_baser<n>, value, 0x300, 8) }
		inline uint64_t set(uint64_t gits_baser<n>, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_baser<n>, value, 0x300, 8) }
	}

	namespace size
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_baser<n>, 0xff, 0) }
		inline uint64_t get(uint64_t gits_baser<n>_val) noexcept { GET_BITFIELD_FUNC(gits_baser<n>_val, 0xff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_baser<n>, value, 0xff, 0) }
		inline uint64_t set(uint64_t gits_baser<n>, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_baser<n>, value, 0xff, 0) }
	}
}

// GITS_CBASER (ITS Command Queue Descriptor)
// Specifies the base address and size of the ITS command queue.
namespace gits_cbaser
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(gits_cbaser) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gits_cbaser, val) }

	namespace valid
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gits_cbaser, 63) }
		inline uint64_t is_enabled(uint64_t gits_cbaser_val) noexcept { IS_BIT_ENABLED_FUNC(gits_cbaser_val, 63) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gits_cbaser, 63) }
		inline uint64_t is_disabled(uint64_t gits_cbaser_val) noexcept { IS_BIT_DISABLED_FUNC(gits_cbaser_val, 63) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gits_cbaser, 0x8000000000000000) }
		inline uint64_t enable(uint64_t gits_cbaser_val) noexcept { SET_BITS_BY_MASK_FUNC(gits_cbaser_val, 0x8000000000000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gits_cbaser, 0x8000000000000000) }
		inline uint64_t disable(uint64_t gits_cbaser_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gits_cbaser_val, 0x8000000000000000) }
	}

	namespace innercache
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_cbaser, 0x3800000000000000, 59) }
		inline uint64_t get(uint64_t gits_cbaser_val) noexcept { GET_BITFIELD_FUNC(gits_cbaser_val, 0x3800000000000000, 59) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_cbaser, value, 0x3800000000000000, 59) }
		inline uint64_t set(uint64_t gits_cbaser, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_cbaser, value, 0x3800000000000000, 59) }
	}

	namespace outercache
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_cbaser, 0xe0000000000000, 53) }
		inline uint64_t get(uint64_t gits_cbaser_val) noexcept { GET_BITFIELD_FUNC(gits_cbaser_val, 0xe0000000000000, 53) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_cbaser, value, 0xe0000000000000, 53) }
		inline uint64_t set(uint64_t gits_cbaser, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_cbaser, value, 0xe0000000000000, 53) }
	}

	namespace physical_address
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_cbaser, 0xffffffffff000, 12) }
		inline uint64_t get(uint64_t gits_cbaser_val) noexcept { GET_BITFIELD_FUNC(gits_cbaser_val, 0xffffffffff000, 12) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_cbaser, value, 0xffffffffff000, 12) }
		inline uint64_t set(uint64_t gits_cbaser, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_cbaser, value, 0xffffffffff000, 12) }
	}

	namespace shareability
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_cbaser, 0xc00, 10) }
		inline uint64_t get(uint64_t gits_cbaser_val) noexcept { GET_BITFIELD_FUNC(gits_cbaser_val, 0xc00, 10) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_cbaser, value, 0xc00, 10) }
		inline uint64_t set(uint64_t gits_cbaser, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_cbaser, value, 0xc00, 10) }
	}

	namespace size
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_cbaser, 0xff, 0) }
		inline uint64_t get(uint64_t gits_cbaser_val) noexcept { GET_BITFIELD_FUNC(gits_cbaser_val, 0xff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_cbaser, value, 0xff, 0) }
		inline uint64_t set(uint64_t gits_cbaser, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_cbaser, value, 0xff, 0) }
	}
}

// GITS_CREADR (ITS Read Register)
// Specifies the offset from GITS_CBASER where the ITS reads the next ITS command.
namespace gits_creadr
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(gits_creadr) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gits_creadr, val) }

	namespace offset
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_creadr, 0xfffe0, 5) }
		inline uint64_t get(uint64_t gits_creadr_val) noexcept { GET_BITFIELD_FUNC(gits_creadr_val, 0xfffe0, 5) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_creadr, value, 0xfffe0, 5) }
		inline uint64_t set(uint64_t gits_creadr, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_creadr, value, 0xfffe0, 5) }
	}

	namespace stalled
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gits_creadr, 0) }
		inline uint64_t is_enabled(uint64_t gits_creadr_val) noexcept { IS_BIT_ENABLED_FUNC(gits_creadr_val, 0) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gits_creadr, 0) }
		inline uint64_t is_disabled(uint64_t gits_creadr_val) noexcept { IS_BIT_DISABLED_FUNC(gits_creadr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gits_creadr, 0x1) }
		inline uint64_t enable(uint64_t gits_creadr_val) noexcept { SET_BITS_BY_MASK_FUNC(gits_creadr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gits_creadr, 0x1) }
		inline uint64_t disable(uint64_t gits_creadr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gits_creadr_val, 0x1) }
	}
}

// GITS_CTLR (ITS Control Register)
// Controls the operation of an ITS.
namespace gits_ctlr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gits_ctlr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gits_ctlr, val) }

	namespace quiescent
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gits_ctlr, 31) }
		inline uint32_t is_enabled(uint32_t gits_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gits_ctlr_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gits_ctlr, 31) }
		inline uint32_t is_disabled(uint32_t gits_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gits_ctlr_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gits_ctlr, 0x80000000) }
		inline uint32_t enable(uint32_t gits_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gits_ctlr_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gits_ctlr, 0x80000000) }
		inline uint32_t disable(uint32_t gits_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gits_ctlr_val, 0x80000000) }
	}

	namespace its_number
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_ctlr, 0xf0, 4) }
		inline uint32_t get(uint32_t gits_ctlr_val) noexcept { GET_BITFIELD_FUNC(gits_ctlr_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_ctlr, value, 0xf0, 4) }
		inline uint32_t set(uint32_t gits_ctlr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_ctlr, value, 0xf0, 4) }
	}

	namespace imde
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gits_ctlr, 1) }
		inline uint32_t is_enabled(uint32_t gits_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gits_ctlr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gits_ctlr, 1) }
		inline uint32_t is_disabled(uint32_t gits_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gits_ctlr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gits_ctlr, 0x2) }
		inline uint32_t enable(uint32_t gits_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gits_ctlr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gits_ctlr, 0x2) }
		inline uint32_t disable(uint32_t gits_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gits_ctlr_val, 0x2) }
	}

	namespace enabled
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gits_ctlr, 0) }
		inline uint32_t is_enabled(uint32_t gits_ctlr_val) noexcept { IS_BIT_ENABLED_FUNC(gits_ctlr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gits_ctlr, 0) }
		inline uint32_t is_disabled(uint32_t gits_ctlr_val) noexcept { IS_BIT_DISABLED_FUNC(gits_ctlr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gits_ctlr, 0x1) }
		inline uint32_t enable(uint32_t gits_ctlr_val) noexcept { SET_BITS_BY_MASK_FUNC(gits_ctlr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gits_ctlr, 0x1) }
		inline uint32_t disable(uint32_t gits_ctlr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gits_ctlr_val, 0x1) }
	}
}

// GITS_CWRITER (ITS Write Register)
// Specifies the offset from GITS_CBASER where software writes the next ITS command.
namespace gits_cwriter
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(gits_cwriter) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gits_cwriter, val) }

	namespace offset
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_cwriter, 0xfffe0, 5) }
		inline uint64_t get(uint64_t gits_cwriter_val) noexcept { GET_BITFIELD_FUNC(gits_cwriter_val, 0xfffe0, 5) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_cwriter, value, 0xfffe0, 5) }
		inline uint64_t set(uint64_t gits_cwriter, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_cwriter, value, 0xfffe0, 5) }
	}

	namespace retry
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gits_cwriter, 0) }
		inline uint64_t is_enabled(uint64_t gits_cwriter_val) noexcept { IS_BIT_ENABLED_FUNC(gits_cwriter_val, 0) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gits_cwriter, 0) }
		inline uint64_t is_disabled(uint64_t gits_cwriter_val) noexcept { IS_BIT_DISABLED_FUNC(gits_cwriter_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gits_cwriter, 0x1) }
		inline uint64_t enable(uint64_t gits_cwriter_val) noexcept { SET_BITS_BY_MASK_FUNC(gits_cwriter_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gits_cwriter, 0x1) }
		inline uint64_t disable(uint64_t gits_cwriter_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gits_cwriter_val, 0x1) }
	}
}

// GITS_IIDR (ITS Identification Register)
// Provides information about the implementer and revision of the ITS.
namespace gits_iidr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gits_iidr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gits_iidr, val) }

	namespace productid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_iidr, 0xff000000, 24) }
		inline uint32_t get(uint32_t gits_iidr_val) noexcept { GET_BITFIELD_FUNC(gits_iidr_val, 0xff000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_iidr, value, 0xff000000, 24) }
		inline uint32_t set(uint32_t gits_iidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_iidr, value, 0xff000000, 24) }
	}

	namespace variant
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_iidr, 0xf0000, 16) }
		inline uint32_t get(uint32_t gits_iidr_val) noexcept { GET_BITFIELD_FUNC(gits_iidr_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_iidr, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t gits_iidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_iidr, value, 0xf0000, 16) }
	}

	namespace revision
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_iidr, 0xf000, 12) }
		inline uint32_t get(uint32_t gits_iidr_val) noexcept { GET_BITFIELD_FUNC(gits_iidr_val, 0xf000, 12) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_iidr, value, 0xf000, 12) }
		inline uint32_t set(uint32_t gits_iidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_iidr, value, 0xf000, 12) }
	}

	namespace implementer
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_iidr, 0xfff, 0) }
		inline uint32_t get(uint32_t gits_iidr_val) noexcept { GET_BITFIELD_FUNC(gits_iidr_val, 0xfff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_iidr, value, 0xfff, 0) }
		inline uint32_t set(uint32_t gits_iidr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_iidr, value, 0xfff, 0) }
	}
}

// GITS_TRANSLATER (ITS Translation Register)
// Written by a requesting a Device to signal an interrupt for translation by the ITS.
namespace gits_translater
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(gits_translater) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gits_translater, val) }

	namespace eventid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_translater, 0xffffffff, 0) }
		inline uint32_t get(uint32_t gits_translater_val) noexcept { GET_BITFIELD_FUNC(gits_translater_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_translater, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t gits_translater, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_translater, value, 0xffffffff, 0) }
	}
}

// GITS_TYPER (ITS Type Register)
// Specifies the features that an ITS supports.
namespace gits_typer
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(gits_typer) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(gits_typer, val) }

	namespace vmovp
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gits_typer, 37) }
		inline uint64_t is_enabled(uint64_t gits_typer_val) noexcept { IS_BIT_ENABLED_FUNC(gits_typer_val, 37) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gits_typer, 37) }
		inline uint64_t is_disabled(uint64_t gits_typer_val) noexcept { IS_BIT_DISABLED_FUNC(gits_typer_val, 37) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gits_typer, 0x2000000000) }
		inline uint64_t enable(uint64_t gits_typer_val) noexcept { SET_BITS_BY_MASK_FUNC(gits_typer_val, 0x2000000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gits_typer, 0x2000000000) }
		inline uint64_t disable(uint64_t gits_typer_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gits_typer_val, 0x2000000000) }
	}

	namespace cil
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gits_typer, 36) }
		inline uint64_t is_enabled(uint64_t gits_typer_val) noexcept { IS_BIT_ENABLED_FUNC(gits_typer_val, 36) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gits_typer, 36) }
		inline uint64_t is_disabled(uint64_t gits_typer_val) noexcept { IS_BIT_DISABLED_FUNC(gits_typer_val, 36) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gits_typer, 0x1000000000) }
		inline uint64_t enable(uint64_t gits_typer_val) noexcept { SET_BITS_BY_MASK_FUNC(gits_typer_val, 0x1000000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gits_typer, 0x1000000000) }
		inline uint64_t disable(uint64_t gits_typer_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gits_typer_val, 0x1000000000) }
	}

	namespace cidbits
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_typer, 0xf00000000, 32) }
		inline uint64_t get(uint64_t gits_typer_val) noexcept { GET_BITFIELD_FUNC(gits_typer_val, 0xf00000000, 32) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_typer, value, 0xf00000000, 32) }
		inline uint64_t set(uint64_t gits_typer, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_typer, value, 0xf00000000, 32) }
	}

	namespace hcc
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_typer, 0xff000000, 24) }
		inline uint64_t get(uint64_t gits_typer_val) noexcept { GET_BITFIELD_FUNC(gits_typer_val, 0xff000000, 24) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_typer, value, 0xff000000, 24) }
		inline uint64_t set(uint64_t gits_typer, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_typer, value, 0xff000000, 24) }
	}

	namespace pta
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gits_typer, 19) }
		inline uint64_t is_enabled(uint64_t gits_typer_val) noexcept { IS_BIT_ENABLED_FUNC(gits_typer_val, 19) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gits_typer, 19) }
		inline uint64_t is_disabled(uint64_t gits_typer_val) noexcept { IS_BIT_DISABLED_FUNC(gits_typer_val, 19) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gits_typer, 0x80000) }
		inline uint64_t enable(uint64_t gits_typer_val) noexcept { SET_BITS_BY_MASK_FUNC(gits_typer_val, 0x80000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gits_typer, 0x80000) }
		inline uint64_t disable(uint64_t gits_typer_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gits_typer_val, 0x80000) }
	}

	namespace seis
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gits_typer, 18) }
		inline uint64_t is_enabled(uint64_t gits_typer_val) noexcept { IS_BIT_ENABLED_FUNC(gits_typer_val, 18) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gits_typer, 18) }
		inline uint64_t is_disabled(uint64_t gits_typer_val) noexcept { IS_BIT_DISABLED_FUNC(gits_typer_val, 18) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gits_typer, 0x40000) }
		inline uint64_t enable(uint64_t gits_typer_val) noexcept { SET_BITS_BY_MASK_FUNC(gits_typer_val, 0x40000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gits_typer, 0x40000) }
		inline uint64_t disable(uint64_t gits_typer_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gits_typer_val, 0x40000) }
	}

	namespace devbits
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_typer, 0x3e000, 13) }
		inline uint64_t get(uint64_t gits_typer_val) noexcept { GET_BITFIELD_FUNC(gits_typer_val, 0x3e000, 13) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_typer, value, 0x3e000, 13) }
		inline uint64_t set(uint64_t gits_typer, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_typer, value, 0x3e000, 13) }
	}

	namespace id_bits
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_typer, 0x1f00, 8) }
		inline uint64_t get(uint64_t gits_typer_val) noexcept { GET_BITFIELD_FUNC(gits_typer_val, 0x1f00, 8) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_typer, value, 0x1f00, 8) }
		inline uint64_t set(uint64_t gits_typer, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_typer, value, 0x1f00, 8) }
	}

	namespace itt_entry_size
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(gits_typer, 0xf0, 4) }
		inline uint64_t get(uint64_t gits_typer_val) noexcept { GET_BITFIELD_FUNC(gits_typer_val, 0xf0, 4) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(gits_typer, value, 0xf0, 4) }
		inline uint64_t set(uint64_t gits_typer, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(gits_typer, value, 0xf0, 4) }
	}

	namespace cct
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gits_typer, 2) }
		inline uint64_t is_enabled(uint64_t gits_typer_val) noexcept { IS_BIT_ENABLED_FUNC(gits_typer_val, 2) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gits_typer, 2) }
		inline uint64_t is_disabled(uint64_t gits_typer_val) noexcept { IS_BIT_DISABLED_FUNC(gits_typer_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gits_typer, 0x4) }
		inline uint64_t enable(uint64_t gits_typer_val) noexcept { SET_BITS_BY_MASK_FUNC(gits_typer_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gits_typer, 0x4) }
		inline uint64_t disable(uint64_t gits_typer_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gits_typer_val, 0x4) }
	}

	namespace virtual
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gits_typer, 1) }
		inline uint64_t is_enabled(uint64_t gits_typer_val) noexcept { IS_BIT_ENABLED_FUNC(gits_typer_val, 1) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gits_typer, 1) }
		inline uint64_t is_disabled(uint64_t gits_typer_val) noexcept { IS_BIT_DISABLED_FUNC(gits_typer_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gits_typer, 0x2) }
		inline uint64_t enable(uint64_t gits_typer_val) noexcept { SET_BITS_BY_MASK_FUNC(gits_typer_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gits_typer, 0x2) }
		inline uint64_t disable(uint64_t gits_typer_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gits_typer_val, 0x2) }
	}

	namespace physical
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(gits_typer, 0) }
		inline uint64_t is_enabled(uint64_t gits_typer_val) noexcept { IS_BIT_ENABLED_FUNC(gits_typer_val, 0) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(gits_typer, 0) }
		inline uint64_t is_disabled(uint64_t gits_typer_val) noexcept { IS_BIT_DISABLED_FUNC(gits_typer_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(gits_typer, 0x1) }
		inline uint64_t enable(uint64_t gits_typer_val) noexcept { SET_BITS_BY_MASK_FUNC(gits_typer_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(gits_typer, 0x1) }
		inline uint64_t disable(uint64_t gits_typer_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(gits_typer_val, 0x1) }
	}
}

// MIDR_EL1 (Main ID Register)
// Provides identification information for the PE, including an implementer code for the device and a device ID number.
namespace midr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(midr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(midr_el1, val) }

	namespace implementer
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(midr_el1, 0xff000000, 24) }
		inline uint32_t get(uint32_t midr_el1_val) noexcept { GET_BITFIELD_FUNC(midr_el1_val, 0xff000000, 24) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(midr_el1, value, 0xff000000, 24) }
		inline uint32_t set(uint32_t midr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(midr_el1, value, 0xff000000, 24) }
	}

	namespace variant
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(midr_el1, 0xf00000, 20) }
		inline uint32_t get(uint32_t midr_el1_val) noexcept { GET_BITFIELD_FUNC(midr_el1_val, 0xf00000, 20) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(midr_el1, value, 0xf00000, 20) }
		inline uint32_t set(uint32_t midr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(midr_el1, value, 0xf00000, 20) }
	}

	namespace architecture
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(midr_el1, 0xf0000, 16) }
		inline uint32_t get(uint32_t midr_el1_val) noexcept { GET_BITFIELD_FUNC(midr_el1_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(midr_el1, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t midr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(midr_el1, value, 0xf0000, 16) }
	}

	namespace partnum
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(midr_el1, 0xfff0, 4) }
		inline uint32_t get(uint32_t midr_el1_val) noexcept { GET_BITFIELD_FUNC(midr_el1_val, 0xfff0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(midr_el1, value, 0xfff0, 4) }
		inline uint32_t set(uint32_t midr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(midr_el1, value, 0xfff0, 4) }
	}

	namespace revision
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(midr_el1, 0xf, 0) }
		inline uint32_t get(uint32_t midr_el1_val) noexcept { GET_BITFIELD_FUNC(midr_el1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(midr_el1, value, 0xf, 0) }
		inline uint32_t set(uint32_t midr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(midr_el1, value, 0xf, 0) }
	}
}

// OSLAR_EL1 (OS Lock Access Register)
// Used to lock or unlock the OS lock.
namespace oslar_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(oslar_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(oslar_el1, val) }

	namespace oslk
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(oslar_el1, 0) }
		inline uint32_t is_enabled(uint32_t oslar_el1_val) noexcept { IS_BIT_ENABLED_FUNC(oslar_el1_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(oslar_el1, 0) }
		inline uint32_t is_disabled(uint32_t oslar_el1_val) noexcept { IS_BIT_DISABLED_FUNC(oslar_el1_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(oslar_el1, 0x1) }
		inline uint32_t enable(uint32_t oslar_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(oslar_el1_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(oslar_el1, 0x1) }
		inline uint32_t disable(uint32_t oslar_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(oslar_el1_val, 0x1) }
	}
}

// PMAUTHSTATUS (Performance Monitors Authentication Status register)
// Provides information about the state of the IMPLEMENTATION DEFINED authentication interface for Performance Monitors.
namespace pmauthstatus
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmauthstatus) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmauthstatus, val) }

	namespace snid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmauthstatus, 0xc0, 6) }
		inline uint32_t get(uint32_t pmauthstatus_val) noexcept { GET_BITFIELD_FUNC(pmauthstatus_val, 0xc0, 6) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmauthstatus, value, 0xc0, 6) }
		inline uint32_t set(uint32_t pmauthstatus, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmauthstatus, value, 0xc0, 6) }
	}

	namespace sid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmauthstatus, 0x30, 4) }
		inline uint32_t get(uint32_t pmauthstatus_val) noexcept { GET_BITFIELD_FUNC(pmauthstatus_val, 0x30, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmauthstatus, value, 0x30, 4) }
		inline uint32_t set(uint32_t pmauthstatus, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmauthstatus, value, 0x30, 4) }
	}

	namespace nsnid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmauthstatus, 0xc, 2) }
		inline uint32_t get(uint32_t pmauthstatus_val) noexcept { GET_BITFIELD_FUNC(pmauthstatus_val, 0xc, 2) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmauthstatus, value, 0xc, 2) }
		inline uint32_t set(uint32_t pmauthstatus, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmauthstatus, value, 0xc, 2) }
	}

	namespace nsid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmauthstatus, 0x3, 0) }
		inline uint32_t get(uint32_t pmauthstatus_val) noexcept { GET_BITFIELD_FUNC(pmauthstatus_val, 0x3, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmauthstatus, value, 0x3, 0) }
		inline uint32_t set(uint32_t pmauthstatus, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmauthstatus, value, 0x3, 0) }
	}
}

// PMCCFILTR_EL0 (Performance Monitors Cycle Counter Filter Register)
// Determines the modes in which the Cycle Counter, PMCCNTR_EL0, increments.
namespace pmccfiltr_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmccfiltr_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmccfiltr_el0, val) }

	namespace p
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmccfiltr_el0, 31) }
		inline uint32_t is_enabled(uint32_t pmccfiltr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmccfiltr_el0_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmccfiltr_el0, 31) }
		inline uint32_t is_disabled(uint32_t pmccfiltr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmccfiltr_el0_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr_el0, 0x80000000) }
		inline uint32_t enable(uint32_t pmccfiltr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmccfiltr_el0_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr_el0, 0x80000000) }
		inline uint32_t disable(uint32_t pmccfiltr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmccfiltr_el0_val, 0x80000000) }
	}

	namespace u
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmccfiltr_el0, 30) }
		inline uint32_t is_enabled(uint32_t pmccfiltr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmccfiltr_el0_val, 30) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmccfiltr_el0, 30) }
		inline uint32_t is_disabled(uint32_t pmccfiltr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmccfiltr_el0_val, 30) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr_el0, 0x40000000) }
		inline uint32_t enable(uint32_t pmccfiltr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmccfiltr_el0_val, 0x40000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr_el0, 0x40000000) }
		inline uint32_t disable(uint32_t pmccfiltr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmccfiltr_el0_val, 0x40000000) }
	}

	namespace nsk
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmccfiltr_el0, 29) }
		inline uint32_t is_enabled(uint32_t pmccfiltr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmccfiltr_el0_val, 29) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmccfiltr_el0, 29) }
		inline uint32_t is_disabled(uint32_t pmccfiltr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmccfiltr_el0_val, 29) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr_el0, 0x20000000) }
		inline uint32_t enable(uint32_t pmccfiltr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmccfiltr_el0_val, 0x20000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr_el0, 0x20000000) }
		inline uint32_t disable(uint32_t pmccfiltr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmccfiltr_el0_val, 0x20000000) }
	}

	namespace nsu
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmccfiltr_el0, 28) }
		inline uint32_t is_enabled(uint32_t pmccfiltr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmccfiltr_el0_val, 28) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmccfiltr_el0, 28) }
		inline uint32_t is_disabled(uint32_t pmccfiltr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmccfiltr_el0_val, 28) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr_el0, 0x10000000) }
		inline uint32_t enable(uint32_t pmccfiltr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmccfiltr_el0_val, 0x10000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr_el0, 0x10000000) }
		inline uint32_t disable(uint32_t pmccfiltr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmccfiltr_el0_val, 0x10000000) }
	}

	namespace nsh
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmccfiltr_el0, 27) }
		inline uint32_t is_enabled(uint32_t pmccfiltr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmccfiltr_el0_val, 27) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmccfiltr_el0, 27) }
		inline uint32_t is_disabled(uint32_t pmccfiltr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmccfiltr_el0_val, 27) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr_el0, 0x8000000) }
		inline uint32_t enable(uint32_t pmccfiltr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmccfiltr_el0_val, 0x8000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr_el0, 0x8000000) }
		inline uint32_t disable(uint32_t pmccfiltr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmccfiltr_el0_val, 0x8000000) }
	}

	namespace m
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmccfiltr_el0, 26) }
		inline uint32_t is_enabled(uint32_t pmccfiltr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmccfiltr_el0_val, 26) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmccfiltr_el0, 26) }
		inline uint32_t is_disabled(uint32_t pmccfiltr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmccfiltr_el0_val, 26) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr_el0, 0x4000000) }
		inline uint32_t enable(uint32_t pmccfiltr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmccfiltr_el0_val, 0x4000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmccfiltr_el0, 0x4000000) }
		inline uint32_t disable(uint32_t pmccfiltr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmccfiltr_el0_val, 0x4000000) }
	}
}

// PMCCNTR_EL0 (Performance Monitors Cycle Counter)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmccntr_el0
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(pmccntr_el0) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmccntr_el0, val) }

	namespace ccnt
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmccntr_el0, 0xffffffffffffffff, 0) }
		inline uint64_t get(uint64_t pmccntr_el0_val) noexcept { GET_BITFIELD_FUNC(pmccntr_el0_val, 0xffffffffffffffff, 0) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmccntr_el0, value, 0xffffffffffffffff, 0) }
		inline uint64_t set(uint64_t pmccntr_el0, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmccntr_el0, value, 0xffffffffffffffff, 0) }
	}
}

// PMCEID0 (Performance Monitors Common Event Identification register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmceid0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmceid0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmceid0, val) }

	namespace id_31:0_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmceid0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t pmceid0_val) noexcept { GET_BITFIELD_FUNC(pmceid0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmceid0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t pmceid0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmceid0, value, 0xffffffff, 0) }
	}
}

// PMCEID1 (Performance Monitors Common Event Identification register 1)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmceid1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmceid1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmceid1, val) }

	namespace id_63:32_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmceid1, 0xffffffff, 0) }
		inline uint32_t get(uint32_t pmceid1_val) noexcept { GET_BITFIELD_FUNC(pmceid1_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmceid1, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t pmceid1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmceid1, value, 0xffffffff, 0) }
	}
}

// PMCEID2 (Performance Monitors Common Event Identification register 2)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmceid2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmceid2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmceid2, val) }

	namespace idhi_31:0_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmceid2, 0xffffffff, 0) }
		inline uint32_t get(uint32_t pmceid2_val) noexcept { GET_BITFIELD_FUNC(pmceid2_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmceid2, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t pmceid2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmceid2, value, 0xffffffff, 0) }
	}
}

// PMCEID3 (Performance Monitors Common Event Identification register 3)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmceid3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmceid3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmceid3, val) }

	namespace idhi_63:32_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmceid3, 0xffffffff, 0) }
		inline uint32_t get(uint32_t pmceid3_val) noexcept { GET_BITFIELD_FUNC(pmceid3_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmceid3, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t pmceid3, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmceid3, value, 0xffffffff, 0) }
	}
}

// PMCFGR (Performance Monitors Configuration Register)
// Contains PMU-specific configuration data.
namespace pmcfgr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmcfgr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmcfgr, val) }

	namespace ncg
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmcfgr, 0xf0000000, 28) }
		inline uint32_t get(uint32_t pmcfgr_val) noexcept { GET_BITFIELD_FUNC(pmcfgr_val, 0xf0000000, 28) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmcfgr, value, 0xf0000000, 28) }
		inline uint32_t set(uint32_t pmcfgr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmcfgr, value, 0xf0000000, 28) }
	}

	namespace uen
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcfgr, 19) }
		inline uint32_t is_enabled(uint32_t pmcfgr_val) noexcept { IS_BIT_ENABLED_FUNC(pmcfgr_val, 19) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcfgr, 19) }
		inline uint32_t is_disabled(uint32_t pmcfgr_val) noexcept { IS_BIT_DISABLED_FUNC(pmcfgr_val, 19) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcfgr, 0x80000) }
		inline uint32_t enable(uint32_t pmcfgr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcfgr_val, 0x80000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcfgr, 0x80000) }
		inline uint32_t disable(uint32_t pmcfgr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcfgr_val, 0x80000) }
	}

	namespace wt
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcfgr, 18) }
		inline uint32_t is_enabled(uint32_t pmcfgr_val) noexcept { IS_BIT_ENABLED_FUNC(pmcfgr_val, 18) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcfgr, 18) }
		inline uint32_t is_disabled(uint32_t pmcfgr_val) noexcept { IS_BIT_DISABLED_FUNC(pmcfgr_val, 18) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcfgr, 0x40000) }
		inline uint32_t enable(uint32_t pmcfgr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcfgr_val, 0x40000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcfgr, 0x40000) }
		inline uint32_t disable(uint32_t pmcfgr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcfgr_val, 0x40000) }
	}

	namespace na
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcfgr, 17) }
		inline uint32_t is_enabled(uint32_t pmcfgr_val) noexcept { IS_BIT_ENABLED_FUNC(pmcfgr_val, 17) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcfgr, 17) }
		inline uint32_t is_disabled(uint32_t pmcfgr_val) noexcept { IS_BIT_DISABLED_FUNC(pmcfgr_val, 17) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcfgr, 0x20000) }
		inline uint32_t enable(uint32_t pmcfgr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcfgr_val, 0x20000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcfgr, 0x20000) }
		inline uint32_t disable(uint32_t pmcfgr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcfgr_val, 0x20000) }
	}

	namespace ex
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcfgr, 16) }
		inline uint32_t is_enabled(uint32_t pmcfgr_val) noexcept { IS_BIT_ENABLED_FUNC(pmcfgr_val, 16) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcfgr, 16) }
		inline uint32_t is_disabled(uint32_t pmcfgr_val) noexcept { IS_BIT_DISABLED_FUNC(pmcfgr_val, 16) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcfgr, 0x10000) }
		inline uint32_t enable(uint32_t pmcfgr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcfgr_val, 0x10000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcfgr, 0x10000) }
		inline uint32_t disable(uint32_t pmcfgr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcfgr_val, 0x10000) }
	}

	namespace ccd
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcfgr, 15) }
		inline uint32_t is_enabled(uint32_t pmcfgr_val) noexcept { IS_BIT_ENABLED_FUNC(pmcfgr_val, 15) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcfgr, 15) }
		inline uint32_t is_disabled(uint32_t pmcfgr_val) noexcept { IS_BIT_DISABLED_FUNC(pmcfgr_val, 15) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcfgr, 0x8000) }
		inline uint32_t enable(uint32_t pmcfgr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcfgr_val, 0x8000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcfgr, 0x8000) }
		inline uint32_t disable(uint32_t pmcfgr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcfgr_val, 0x8000) }
	}

	namespace cc
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcfgr, 14) }
		inline uint32_t is_enabled(uint32_t pmcfgr_val) noexcept { IS_BIT_ENABLED_FUNC(pmcfgr_val, 14) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcfgr, 14) }
		inline uint32_t is_disabled(uint32_t pmcfgr_val) noexcept { IS_BIT_DISABLED_FUNC(pmcfgr_val, 14) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcfgr, 0x4000) }
		inline uint32_t enable(uint32_t pmcfgr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcfgr_val, 0x4000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcfgr, 0x4000) }
		inline uint32_t disable(uint32_t pmcfgr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcfgr_val, 0x4000) }
	}

	namespace size
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmcfgr, 0x3f00, 8) }
		inline uint32_t get(uint32_t pmcfgr_val) noexcept { GET_BITFIELD_FUNC(pmcfgr_val, 0x3f00, 8) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmcfgr, value, 0x3f00, 8) }
		inline uint32_t set(uint32_t pmcfgr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmcfgr, value, 0x3f00, 8) }
	}

	namespace n
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmcfgr, 0xff, 0) }
		inline uint32_t get(uint32_t pmcfgr_val) noexcept { GET_BITFIELD_FUNC(pmcfgr_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmcfgr, value, 0xff, 0) }
		inline uint32_t set(uint32_t pmcfgr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmcfgr, value, 0xff, 0) }
	}
}

// PMCID1SR (CONTEXTIDR_EL1 Sample Register)
// Contains the sampled value of CONTEXTIDR_EL1, captured on reading PMPCSR[31:0].
namespace pmcid1sr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmcid1sr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmcid1sr, val) }

	namespace contextidr_el1
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmcid1sr, 0xffffffff, 0) }
		inline uint32_t get(uint32_t pmcid1sr_val) noexcept { GET_BITFIELD_FUNC(pmcid1sr_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmcid1sr, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t pmcid1sr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmcid1sr, value, 0xffffffff, 0) }
	}
}

// PMCID2SR (CONTEXTIDR_EL2 Sample Register)
// Contains the sampled value of CONTEXTIDR_EL2, captured on reading PMPCSR[31:0].
namespace pmcid2sr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmcid2sr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmcid2sr, val) }

	namespace contextidr_el2
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmcid2sr, 0xffffffff, 0) }
		inline uint32_t get(uint32_t pmcid2sr_val) noexcept { GET_BITFIELD_FUNC(pmcid2sr_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmcid2sr, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t pmcid2sr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmcid2sr, value, 0xffffffff, 0) }
	}
}

// PMCIDR0 (Performance Monitors Component Identification Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmcidr0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmcidr0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmcidr0, val) }

	namespace prmbl_0
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmcidr0, 0xff, 0) }
		inline uint32_t get(uint32_t pmcidr0_val) noexcept { GET_BITFIELD_FUNC(pmcidr0_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmcidr0, value, 0xff, 0) }
		inline uint32_t set(uint32_t pmcidr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmcidr0, value, 0xff, 0) }
	}
}

// PMCIDR1 (Performance Monitors Component Identification Register 1)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmcidr1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmcidr1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmcidr1, val) }

	namespace class
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmcidr1, 0xf0, 4) }
		inline uint32_t get(uint32_t pmcidr1_val) noexcept { GET_BITFIELD_FUNC(pmcidr1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmcidr1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t pmcidr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmcidr1, value, 0xf0, 4) }
	}

	namespace prmbl_1
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmcidr1, 0xf, 0) }
		inline uint32_t get(uint32_t pmcidr1_val) noexcept { GET_BITFIELD_FUNC(pmcidr1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmcidr1, value, 0xf, 0) }
		inline uint32_t set(uint32_t pmcidr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmcidr1, value, 0xf, 0) }
	}
}

// PMCIDR2 (Performance Monitors Component Identification Register 2)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmcidr2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmcidr2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmcidr2, val) }

	namespace prmbl_2
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmcidr2, 0xff, 0) }
		inline uint32_t get(uint32_t pmcidr2_val) noexcept { GET_BITFIELD_FUNC(pmcidr2_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmcidr2, value, 0xff, 0) }
		inline uint32_t set(uint32_t pmcidr2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmcidr2, value, 0xff, 0) }
	}
}

// PMCIDR3 (Performance Monitors Component Identification Register 3)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmcidr3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmcidr3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmcidr3, val) }

	namespace prmbl_3
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmcidr3, 0xff, 0) }
		inline uint32_t get(uint32_t pmcidr3_val) noexcept { GET_BITFIELD_FUNC(pmcidr3_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmcidr3, value, 0xff, 0) }
		inline uint32_t set(uint32_t pmcidr3, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmcidr3, value, 0xff, 0) }
	}
}

// PMCNTENCLR_EL0 (Performance Monitors Count Enable Clear register)
// Disables the Cycle Count Register, PMCCNTR_EL0, and any implemented event counters PMEVCNTR<n>. Reading this register shows which counters are enabled.
namespace pmcntenclr_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmcntenclr_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmcntenclr_el0, val) }

	namespace c
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcntenclr_el0, 31) }
		inline uint32_t is_enabled(uint32_t pmcntenclr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmcntenclr_el0_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcntenclr_el0, 31) }
		inline uint32_t is_disabled(uint32_t pmcntenclr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmcntenclr_el0_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcntenclr_el0, 0x80000000) }
		inline uint32_t enable(uint32_t pmcntenclr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcntenclr_el0_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcntenclr_el0, 0x80000000) }
		inline uint32_t disable(uint32_t pmcntenclr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcntenclr_el0_val, 0x80000000) }
	}

	namespace p_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmcntenclr_el0, 0x7fffffff, 0) }
		inline uint32_t get(uint32_t pmcntenclr_el0_val) noexcept { GET_BITFIELD_FUNC(pmcntenclr_el0_val, 0x7fffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmcntenclr_el0, value, 0x7fffffff, 0) }
		inline uint32_t set(uint32_t pmcntenclr_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmcntenclr_el0, value, 0x7fffffff, 0) }
	}
}

// PMCNTENSET_EL0 (Performance Monitors Count Enable Set register)
// Enables the Cycle Count Register, PMCCNTR_EL0, and any implemented event counters PMEVCNTR<n>. Reading this register shows which counters are enabled.
namespace pmcntenset_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmcntenset_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmcntenset_el0, val) }

	namespace c
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcntenset_el0, 31) }
		inline uint32_t is_enabled(uint32_t pmcntenset_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmcntenset_el0_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcntenset_el0, 31) }
		inline uint32_t is_disabled(uint32_t pmcntenset_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmcntenset_el0_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcntenset_el0, 0x80000000) }
		inline uint32_t enable(uint32_t pmcntenset_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcntenset_el0_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcntenset_el0, 0x80000000) }
		inline uint32_t disable(uint32_t pmcntenset_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcntenset_el0_val, 0x80000000) }
	}

	namespace p_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmcntenset_el0, 0x7fffffff, 0) }
		inline uint32_t get(uint32_t pmcntenset_el0_val) noexcept { GET_BITFIELD_FUNC(pmcntenset_el0_val, 0x7fffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmcntenset_el0, value, 0x7fffffff, 0) }
		inline uint32_t set(uint32_t pmcntenset_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmcntenset_el0, value, 0x7fffffff, 0) }
	}
}

// PMCR_EL0 (Performance Monitors Control Register)
// Provides details of the Performance Monitors implementation, including the number of counters implemented, and configures and controls the counters.
namespace pmcr_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmcr_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmcr_el0, val) }

	namespace lc
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcr_el0, 6) }
		inline uint32_t is_enabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmcr_el0_val, 6) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcr_el0, 6) }
		inline uint32_t is_disabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmcr_el0_val, 6) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x40) }
		inline uint32_t enable(uint32_t pmcr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x40) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x40) }
		inline uint32_t disable(uint32_t pmcr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x40) }
	}

	namespace dp
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcr_el0, 5) }
		inline uint32_t is_enabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmcr_el0_val, 5) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcr_el0, 5) }
		inline uint32_t is_disabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmcr_el0_val, 5) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x20) }
		inline uint32_t enable(uint32_t pmcr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x20) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x20) }
		inline uint32_t disable(uint32_t pmcr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x20) }
	}

	namespace x
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcr_el0, 4) }
		inline uint32_t is_enabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmcr_el0_val, 4) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcr_el0, 4) }
		inline uint32_t is_disabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmcr_el0_val, 4) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x10) }
		inline uint32_t enable(uint32_t pmcr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x10) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x10) }
		inline uint32_t disable(uint32_t pmcr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x10) }
	}

	namespace d
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcr_el0, 3) }
		inline uint32_t is_enabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmcr_el0_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcr_el0, 3) }
		inline uint32_t is_disabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmcr_el0_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x8) }
		inline uint32_t enable(uint32_t pmcr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x8) }
		inline uint32_t disable(uint32_t pmcr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x8) }
	}

	namespace c
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcr_el0, 2) }
		inline uint32_t is_enabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmcr_el0_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcr_el0, 2) }
		inline uint32_t is_disabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmcr_el0_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x4) }
		inline uint32_t enable(uint32_t pmcr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x4) }
		inline uint32_t disable(uint32_t pmcr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x4) }
	}

	namespace p
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcr_el0, 1) }
		inline uint32_t is_enabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmcr_el0_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcr_el0, 1) }
		inline uint32_t is_disabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmcr_el0_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x2) }
		inline uint32_t enable(uint32_t pmcr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x2) }
		inline uint32_t disable(uint32_t pmcr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x2) }
	}

	namespace e
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmcr_el0, 0) }
		inline uint32_t is_enabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmcr_el0_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmcr_el0, 0) }
		inline uint32_t is_disabled(uint32_t pmcr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmcr_el0_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x1) }
		inline uint32_t enable(uint32_t pmcr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmcr_el0, 0x1) }
		inline uint32_t disable(uint32_t pmcr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmcr_el0_val, 0x1) }
	}
}

// PMDEVAFF0 (Performance Monitors Device Affinity register 0)
// Copy of the low half of the PE MPIDR_EL1 register that allows a debugger to determine which PE in a multiprocessor system the Performance Monitor component relates to.
namespace pmdevaff0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmdevaff0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmdevaff0, val) }

	namespace none
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmdevaff0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t pmdevaff0_val) noexcept { GET_BITFIELD_FUNC(pmdevaff0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmdevaff0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t pmdevaff0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmdevaff0, value, 0xffffffff, 0) }
	}
}

// PMDEVAFF1 (Performance Monitors Device Affinity register 1)
// Copy of the high half of the PE MPIDR_EL1 register that allows a debugger to determine which PE in a multiprocessor system the Performance Monitor component relates to.
namespace pmdevaff1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmdevaff1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmdevaff1, val) }

	namespace none
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmdevaff1, 0xffffffff, 0) }
		inline uint32_t get(uint32_t pmdevaff1_val) noexcept { GET_BITFIELD_FUNC(pmdevaff1_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmdevaff1, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t pmdevaff1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmdevaff1, value, 0xffffffff, 0) }
	}
}

// PMDEVARCH (Performance Monitors Device Architecture register)
// Identifies the programmers' model architecture of the Performance Monitor component.
namespace pmdevarch
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmdevarch) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmdevarch, val) }

	namespace architect
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmdevarch, 0xffe00000, 21) }
		inline uint32_t get(uint32_t pmdevarch_val) noexcept { GET_BITFIELD_FUNC(pmdevarch_val, 0xffe00000, 21) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmdevarch, value, 0xffe00000, 21) }
		inline uint32_t set(uint32_t pmdevarch, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmdevarch, value, 0xffe00000, 21) }
	}

	namespace present
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmdevarch, 20) }
		inline uint32_t is_enabled(uint32_t pmdevarch_val) noexcept { IS_BIT_ENABLED_FUNC(pmdevarch_val, 20) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmdevarch, 20) }
		inline uint32_t is_disabled(uint32_t pmdevarch_val) noexcept { IS_BIT_DISABLED_FUNC(pmdevarch_val, 20) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmdevarch, 0x100000) }
		inline uint32_t enable(uint32_t pmdevarch_val) noexcept { SET_BITS_BY_MASK_FUNC(pmdevarch_val, 0x100000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmdevarch, 0x100000) }
		inline uint32_t disable(uint32_t pmdevarch_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmdevarch_val, 0x100000) }
	}

	namespace revision
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmdevarch, 0xf0000, 16) }
		inline uint32_t get(uint32_t pmdevarch_val) noexcept { GET_BITFIELD_FUNC(pmdevarch_val, 0xf0000, 16) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmdevarch, value, 0xf0000, 16) }
		inline uint32_t set(uint32_t pmdevarch, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmdevarch, value, 0xf0000, 16) }
	}

	namespace archid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmdevarch, 0xffff, 0) }
		inline uint32_t get(uint32_t pmdevarch_val) noexcept { GET_BITFIELD_FUNC(pmdevarch_val, 0xffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmdevarch, value, 0xffff, 0) }
		inline uint32_t set(uint32_t pmdevarch, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmdevarch, value, 0xffff, 0) }
	}
}

// PMDEVID (Performance Monitors Device ID register)
// Provides information about features of the Performance Monitors implementation.
namespace pmdevid
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmdevid) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmdevid, val) }

	namespace pcsample
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmdevid, 0xf, 0) }
		inline uint32_t get(uint32_t pmdevid_val) noexcept { GET_BITFIELD_FUNC(pmdevid_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmdevid, value, 0xf, 0) }
		inline uint32_t set(uint32_t pmdevid, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmdevid, value, 0xf, 0) }
	}
}

// PMDEVTYPE (Performance Monitors Device Type register)
// Indicates to a debugger that this component is part of a PEs performance monitor interface.
namespace pmdevtype
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmdevtype) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmdevtype, val) }

	namespace sub
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmdevtype, 0xf0, 4) }
		inline uint32_t get(uint32_t pmdevtype_val) noexcept { GET_BITFIELD_FUNC(pmdevtype_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmdevtype, value, 0xf0, 4) }
		inline uint32_t set(uint32_t pmdevtype, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmdevtype, value, 0xf0, 4) }
	}

	namespace major
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmdevtype, 0xf, 0) }
		inline uint32_t get(uint32_t pmdevtype_val) noexcept { GET_BITFIELD_FUNC(pmdevtype_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmdevtype, value, 0xf, 0) }
		inline uint32_t set(uint32_t pmdevtype, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmdevtype, value, 0xf, 0) }
	}
}

// PMEVCNTR<n>_EL0 (Performance Monitors Event Count Registers)
// Holds event counter n, which counts events, where n is 0 to 30.
namespace pmevcntr<n>_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmevcntr<n>_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmevcntr<n>_el0, val) }

	namespace event_counter_n
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmevcntr<n>_el0, 0xffffffff, 0) }
		inline uint32_t get(uint32_t pmevcntr<n>_el0_val) noexcept { GET_BITFIELD_FUNC(pmevcntr<n>_el0_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmevcntr<n>_el0, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t pmevcntr<n>_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmevcntr<n>_el0, value, 0xffffffff, 0) }
	}
}

// PMEVTYPER<n>_EL0 (Performance Monitors Event Type Registers)
// Configures event counter n, where n is 0 to 30.
namespace pmevtyper<n>_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmevtyper<n>_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmevtyper<n>_el0, val) }
}

// PMINTENCLR_EL1 (Performance Monitors Interrupt Enable Clear register)
// Disables the generation of interrupt requests on overflows from the Cycle Count Register, PMCCNTR_EL0, and the event counters PMEVCNTR<n>_EL0. Reading the register shows which overflow interrupt requests are enabled.
namespace pmintenclr_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmintenclr_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmintenclr_el1, val) }

	namespace c
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmintenclr_el1, 31) }
		inline uint32_t is_enabled(uint32_t pmintenclr_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmintenclr_el1_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmintenclr_el1, 31) }
		inline uint32_t is_disabled(uint32_t pmintenclr_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmintenclr_el1_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmintenclr_el1, 0x80000000) }
		inline uint32_t enable(uint32_t pmintenclr_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmintenclr_el1_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmintenclr_el1, 0x80000000) }
		inline uint32_t disable(uint32_t pmintenclr_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmintenclr_el1_val, 0x80000000) }
	}

	namespace p_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmintenclr_el1, 0x7fffffff, 0) }
		inline uint32_t get(uint32_t pmintenclr_el1_val) noexcept { GET_BITFIELD_FUNC(pmintenclr_el1_val, 0x7fffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmintenclr_el1, value, 0x7fffffff, 0) }
		inline uint32_t set(uint32_t pmintenclr_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmintenclr_el1, value, 0x7fffffff, 0) }
	}
}

// PMINTENSET_EL1 (Performance Monitors Interrupt Enable Set register)
// Enables the generation of interrupt requests on overflows from the Cycle Count Register, PMCCNTR_EL0, and the event counters PMEVCNTR<n>_EL0. Reading the register shows which overflow interrupt requests are enabled.
namespace pmintenset_el1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmintenset_el1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmintenset_el1, val) }

	namespace c
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmintenset_el1, 31) }
		inline uint32_t is_enabled(uint32_t pmintenset_el1_val) noexcept { IS_BIT_ENABLED_FUNC(pmintenset_el1_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmintenset_el1, 31) }
		inline uint32_t is_disabled(uint32_t pmintenset_el1_val) noexcept { IS_BIT_DISABLED_FUNC(pmintenset_el1_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmintenset_el1, 0x80000000) }
		inline uint32_t enable(uint32_t pmintenset_el1_val) noexcept { SET_BITS_BY_MASK_FUNC(pmintenset_el1_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmintenset_el1, 0x80000000) }
		inline uint32_t disable(uint32_t pmintenset_el1_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmintenset_el1_val, 0x80000000) }
	}

	namespace p_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmintenset_el1, 0x7fffffff, 0) }
		inline uint32_t get(uint32_t pmintenset_el1_val) noexcept { GET_BITFIELD_FUNC(pmintenset_el1_val, 0x7fffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmintenset_el1, value, 0x7fffffff, 0) }
		inline uint32_t set(uint32_t pmintenset_el1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmintenset_el1, value, 0x7fffffff, 0) }
	}
}

// PMITCTRL (Performance Monitors Integration mode Control register)
// Enables the Performance Monitors to switch from default mode into integration mode, where test software can control directly the inputs and outputs of the PE, for integration testing or topology detection.
namespace pmitctrl
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmitctrl) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmitctrl, val) }

	namespace ime
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmitctrl, 0) }
		inline uint32_t is_enabled(uint32_t pmitctrl_val) noexcept { IS_BIT_ENABLED_FUNC(pmitctrl_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmitctrl, 0) }
		inline uint32_t is_disabled(uint32_t pmitctrl_val) noexcept { IS_BIT_DISABLED_FUNC(pmitctrl_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmitctrl, 0x1) }
		inline uint32_t enable(uint32_t pmitctrl_val) noexcept { SET_BITS_BY_MASK_FUNC(pmitctrl_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmitctrl, 0x1) }
		inline uint32_t disable(uint32_t pmitctrl_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmitctrl_val, 0x1) }
	}
}

// PMLAR (Performance Monitors Lock Access Register)
// Allows or disallows access to the Performance Monitors registers through a memory-mapped interface.
namespace pmlar
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmlar) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmlar, val) }

	namespace key
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmlar, 0xffffffff, 0) }
		inline uint32_t get(uint32_t pmlar_val) noexcept { GET_BITFIELD_FUNC(pmlar_val, 0xffffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmlar, value, 0xffffffff, 0) }
		inline uint32_t set(uint32_t pmlar, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmlar, value, 0xffffffff, 0) }
	}
}

// PMLSR (Performance Monitors Lock Status Register)
// Indicates the current status of the software lock for Performance Monitors registers.
namespace pmlsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmlsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmlsr, val) }

	namespace ntt
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmlsr, 2) }
		inline uint32_t is_enabled(uint32_t pmlsr_val) noexcept { IS_BIT_ENABLED_FUNC(pmlsr_val, 2) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmlsr, 2) }
		inline uint32_t is_disabled(uint32_t pmlsr_val) noexcept { IS_BIT_DISABLED_FUNC(pmlsr_val, 2) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmlsr, 0x4) }
		inline uint32_t enable(uint32_t pmlsr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmlsr_val, 0x4) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmlsr, 0x4) }
		inline uint32_t disable(uint32_t pmlsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmlsr_val, 0x4) }
	}

	namespace slk
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmlsr, 1) }
		inline uint32_t is_enabled(uint32_t pmlsr_val) noexcept { IS_BIT_ENABLED_FUNC(pmlsr_val, 1) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmlsr, 1) }
		inline uint32_t is_disabled(uint32_t pmlsr_val) noexcept { IS_BIT_DISABLED_FUNC(pmlsr_val, 1) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmlsr, 0x2) }
		inline uint32_t enable(uint32_t pmlsr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmlsr_val, 0x2) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmlsr, 0x2) }
		inline uint32_t disable(uint32_t pmlsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmlsr_val, 0x2) }
	}

	namespace sli
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmlsr, 0) }
		inline uint32_t is_enabled(uint32_t pmlsr_val) noexcept { IS_BIT_ENABLED_FUNC(pmlsr_val, 0) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmlsr, 0) }
		inline uint32_t is_disabled(uint32_t pmlsr_val) noexcept { IS_BIT_DISABLED_FUNC(pmlsr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmlsr, 0x1) }
		inline uint32_t enable(uint32_t pmlsr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmlsr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmlsr, 0x1) }
		inline uint32_t disable(uint32_t pmlsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmlsr_val, 0x1) }
	}
}

// PMOVSCLR_EL0 (Performance Monitors Overflow Flag Status Clear register)
// Contains the state of the overflow bit for the Cycle Count Register, PMCCNTR_EL0, and each of the implemented event counters PMEVCNTR<n>. Writing to this register clears these bits.
namespace pmovsclr_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmovsclr_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmovsclr_el0, val) }

	namespace c
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmovsclr_el0, 31) }
		inline uint32_t is_enabled(uint32_t pmovsclr_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmovsclr_el0_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmovsclr_el0, 31) }
		inline uint32_t is_disabled(uint32_t pmovsclr_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmovsclr_el0_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmovsclr_el0, 0x80000000) }
		inline uint32_t enable(uint32_t pmovsclr_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmovsclr_el0_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmovsclr_el0, 0x80000000) }
		inline uint32_t disable(uint32_t pmovsclr_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmovsclr_el0_val, 0x80000000) }
	}

	namespace p_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmovsclr_el0, 0x7fffffff, 0) }
		inline uint32_t get(uint32_t pmovsclr_el0_val) noexcept { GET_BITFIELD_FUNC(pmovsclr_el0_val, 0x7fffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmovsclr_el0, value, 0x7fffffff, 0) }
		inline uint32_t set(uint32_t pmovsclr_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmovsclr_el0, value, 0x7fffffff, 0) }
	}
}

// PMOVSSET_EL0 (Performance Monitors Overflow Flag Status Set register)
// Sets the state of the overflow bit for the Cycle Count Register, PMCCNTR_EL0, and each of the implemented event counters PMEVCNTR<n>.
namespace pmovsset_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmovsset_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmovsset_el0, val) }

	namespace c
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmovsset_el0, 31) }
		inline uint32_t is_enabled(uint32_t pmovsset_el0_val) noexcept { IS_BIT_ENABLED_FUNC(pmovsset_el0_val, 31) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmovsset_el0, 31) }
		inline uint32_t is_disabled(uint32_t pmovsset_el0_val) noexcept { IS_BIT_DISABLED_FUNC(pmovsset_el0_val, 31) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmovsset_el0, 0x80000000) }
		inline uint32_t enable(uint32_t pmovsset_el0_val) noexcept { SET_BITS_BY_MASK_FUNC(pmovsset_el0_val, 0x80000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmovsset_el0, 0x80000000) }
		inline uint32_t disable(uint32_t pmovsset_el0_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmovsset_el0_val, 0x80000000) }
	}

	namespace p_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmovsset_el0, 0x7fffffff, 0) }
		inline uint32_t get(uint32_t pmovsset_el0_val) noexcept { GET_BITFIELD_FUNC(pmovsset_el0_val, 0x7fffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmovsset_el0, value, 0x7fffffff, 0) }
		inline uint32_t set(uint32_t pmovsset_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmovsset_el0, value, 0x7fffffff, 0) }
	}
}

// PMPCSR (Program Counter Sample Register)
// Holds a sampled instruction address value.
namespace pmpcsr
{
	inline uint64_t get(void) noexcept { GET_SYSREG_FUNC(pmpcsr) }
	inline void set(uint64_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmpcsr, val) }

	namespace ns
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmpcsr, 63) }
		inline uint64_t is_enabled(uint64_t pmpcsr_val) noexcept { IS_BIT_ENABLED_FUNC(pmpcsr_val, 63) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmpcsr, 63) }
		inline uint64_t is_disabled(uint64_t pmpcsr_val) noexcept { IS_BIT_DISABLED_FUNC(pmpcsr_val, 63) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmpcsr, 0x8000000000000000) }
		inline uint64_t enable(uint64_t pmpcsr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmpcsr_val, 0x8000000000000000) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmpcsr, 0x8000000000000000) }
		inline uint64_t disable(uint64_t pmpcsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmpcsr_val, 0x8000000000000000) }
	}

	namespace el
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmpcsr, 0x6000000000000000, 61) }
		inline uint64_t get(uint64_t pmpcsr_val) noexcept { GET_BITFIELD_FUNC(pmpcsr_val, 0x6000000000000000, 61) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmpcsr, value, 0x6000000000000000, 61) }
		inline uint64_t set(uint64_t pmpcsr, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmpcsr, value, 0x6000000000000000, 61) }
	}

	namespace pc_sample_55:32_
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmpcsr, 0xffffff00000000, 32) }
		inline uint64_t get(uint64_t pmpcsr_val) noexcept { GET_BITFIELD_FUNC(pmpcsr_val, 0xffffff00000000, 32) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmpcsr, value, 0xffffff00000000, 32) }
		inline uint64_t set(uint64_t pmpcsr, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmpcsr, value, 0xffffff00000000, 32) }
	}

	namespace pc_sample_31:1_
	{
		inline uint64_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmpcsr, 0xfffffffe, 1) }
		inline uint64_t get(uint64_t pmpcsr_val) noexcept { GET_BITFIELD_FUNC(pmpcsr_val, 0xfffffffe, 1) }
		inline void set(uint64_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmpcsr, value, 0xfffffffe, 1) }
		inline uint64_t set(uint64_t pmpcsr, uint64_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmpcsr, value, 0xfffffffe, 1) }
	}

	namespace sbz
	{
		inline uint64_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmpcsr, 0) }
		inline uint64_t is_enabled(uint64_t pmpcsr_val) noexcept { IS_BIT_ENABLED_FUNC(pmpcsr_val, 0) }
		inline uint64_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmpcsr, 0) }
		inline uint64_t is_disabled(uint64_t pmpcsr_val) noexcept { IS_BIT_DISABLED_FUNC(pmpcsr_val, 0) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmpcsr, 0x1) }
		inline uint64_t enable(uint64_t pmpcsr_val) noexcept { SET_BITS_BY_MASK_FUNC(pmpcsr_val, 0x1) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmpcsr, 0x1) }
		inline uint64_t disable(uint64_t pmpcsr_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmpcsr_val, 0x1) }
	}
}

// PMPIDR0 (Performance Monitors Peripheral Identification Register 0)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmpidr0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmpidr0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmpidr0, val) }

	namespace part_0
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmpidr0, 0xff, 0) }
		inline uint32_t get(uint32_t pmpidr0_val) noexcept { GET_BITFIELD_FUNC(pmpidr0_val, 0xff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmpidr0, value, 0xff, 0) }
		inline uint32_t set(uint32_t pmpidr0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmpidr0, value, 0xff, 0) }
	}
}

// PMPIDR1 (Performance Monitors Peripheral Identification Register 1)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmpidr1
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmpidr1) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmpidr1, val) }

	namespace des_0
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmpidr1, 0xf0, 4) }
		inline uint32_t get(uint32_t pmpidr1_val) noexcept { GET_BITFIELD_FUNC(pmpidr1_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmpidr1, value, 0xf0, 4) }
		inline uint32_t set(uint32_t pmpidr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmpidr1, value, 0xf0, 4) }
	}

	namespace part_1
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmpidr1, 0xf, 0) }
		inline uint32_t get(uint32_t pmpidr1_val) noexcept { GET_BITFIELD_FUNC(pmpidr1_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmpidr1, value, 0xf, 0) }
		inline uint32_t set(uint32_t pmpidr1, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmpidr1, value, 0xf, 0) }
	}
}

// PMPIDR2 (Performance Monitors Peripheral Identification Register 2)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmpidr2
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmpidr2) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmpidr2, val) }

	namespace revision
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmpidr2, 0xf0, 4) }
		inline uint32_t get(uint32_t pmpidr2_val) noexcept { GET_BITFIELD_FUNC(pmpidr2_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmpidr2, value, 0xf0, 4) }
		inline uint32_t set(uint32_t pmpidr2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmpidr2, value, 0xf0, 4) }
	}

	namespace jedec
	{
		inline uint32_t is_enabled() noexcept { IS_SYSREG_BIT_ENABLED_FUNC(pmpidr2, 3) }
		inline uint32_t is_enabled(uint32_t pmpidr2_val) noexcept { IS_BIT_ENABLED_FUNC(pmpidr2_val, 3) }
		inline uint32_t is_disabled() noexcept { IS_SYSREG_BIT_DISABLED_FUNC(pmpidr2, 3) }
		inline uint32_t is_disabled(uint32_t pmpidr2_val) noexcept { IS_BIT_DISABLED_FUNC(pmpidr2_val, 3) }
		inline void enable() noexcept { SET_SYSREG_BITS_BY_MASK_FUNC(pmpidr2, 0x8) }
		inline uint32_t enable(uint32_t pmpidr2_val) noexcept { SET_BITS_BY_MASK_FUNC(pmpidr2_val, 0x8) }
		inline void disable() noexcept { CLEAR_SYSREG_BITS_BY_MASK_FUNC(pmpidr2, 0x8) }
		inline uint32_t disable(uint32_t pmpidr2_val) noexcept { CLEAR_BITS_BY_MASK_FUNC(pmpidr2_val, 0x8) }
	}

	namespace des_1
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmpidr2, 0x7, 0) }
		inline uint32_t get(uint32_t pmpidr2_val) noexcept { GET_BITFIELD_FUNC(pmpidr2_val, 0x7, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmpidr2, value, 0x7, 0) }
		inline uint32_t set(uint32_t pmpidr2, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmpidr2, value, 0x7, 0) }
	}
}

// PMPIDR3 (Performance Monitors Peripheral Identification Register 3)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmpidr3
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmpidr3) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmpidr3, val) }

	namespace revand
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmpidr3, 0xf0, 4) }
		inline uint32_t get(uint32_t pmpidr3_val) noexcept { GET_BITFIELD_FUNC(pmpidr3_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmpidr3, value, 0xf0, 4) }
		inline uint32_t set(uint32_t pmpidr3, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmpidr3, value, 0xf0, 4) }
	}

	namespace cmod
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmpidr3, 0xf, 0) }
		inline uint32_t get(uint32_t pmpidr3_val) noexcept { GET_BITFIELD_FUNC(pmpidr3_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmpidr3, value, 0xf, 0) }
		inline uint32_t set(uint32_t pmpidr3, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmpidr3, value, 0xf, 0) }
	}
}

// PMPIDR4 (Performance Monitors Peripheral Identification Register 4)
// See the ARMv8 architecture reference manual for a description of this register
namespace pmpidr4
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmpidr4) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmpidr4, val) }

	namespace size
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmpidr4, 0xf0, 4) }
		inline uint32_t get(uint32_t pmpidr4_val) noexcept { GET_BITFIELD_FUNC(pmpidr4_val, 0xf0, 4) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmpidr4, value, 0xf0, 4) }
		inline uint32_t set(uint32_t pmpidr4, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmpidr4, value, 0xf0, 4) }
	}

	namespace des_2
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmpidr4, 0xf, 0) }
		inline uint32_t get(uint32_t pmpidr4_val) noexcept { GET_BITFIELD_FUNC(pmpidr4_val, 0xf, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmpidr4, value, 0xf, 0) }
		inline uint32_t set(uint32_t pmpidr4, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmpidr4, value, 0xf, 0) }
	}
}

// PMSWINC_EL0 (Performance Monitors Software Increment register)
// Increments a counter that is configured to count the Software increment event, event 
namespace pmswinc_el0
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmswinc_el0) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmswinc_el0, val) }

	namespace p_n_
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmswinc_el0, 0x7fffffff, 0) }
		inline uint32_t get(uint32_t pmswinc_el0_val) noexcept { GET_BITFIELD_FUNC(pmswinc_el0_val, 0x7fffffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmswinc_el0, value, 0x7fffffff, 0) }
		inline uint32_t set(uint32_t pmswinc_el0, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmswinc_el0, value, 0x7fffffff, 0) }
	}
}

// PMVIDSR (VMID Sample Register)
// Contains the sampled VMID value that is captured on reading PMPCSR[31:0].
namespace pmvidsr
{
	inline uint32_t get(void) noexcept { GET_SYSREG_FUNC(pmvidsr) }
	inline void set(uint32_t val) noexcept { SET_SYSREG_BY_VALUE_FUNC(pmvidsr, val) }

	namespace vmid
	{
		inline uint32_t get() noexcept { GET_SYSREG_FIELD_FUNC(pmvidsr, 0xffff, 0) }
		inline uint32_t get(uint32_t pmvidsr_val) noexcept { GET_BITFIELD_FUNC(pmvidsr_val, 0xffff, 0) }
		inline void set(uint32_t value) noexcept { SET_SYSREG_BITS_BY_VALUE_FUNC(pmvidsr, value, 0xffff, 0) }
		inline uint32_t set(uint32_t pmvidsr, uint32_t value) noexcept { SET_BITS_BY_VALUE_FUNC(pmvidsr, value, 0xffff, 0) }
	}
}
}
#endif

